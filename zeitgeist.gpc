/*

												 Zeitgeist: Call of Duty: Modern Warfare II

														Author:		swedemafia
														Script:		Zeitgeist
														Version:	1.05
														Build Date:	xx XXX 2023
														Support:	https://discord.gg/e27AarXYMJ
														
														
							REQUIREMENTS:
								* 'Controller Vibration' *MUST* be enabled in the in-game settings
								* Zen Studio Beta (current version: 119)
								* In Zen Studio, 'Use Legacy 16Bit Compiler' found in the Device tab *MUST* be disabled
							
							README:
								* https://docs.google.com/document/d/1UQZdi7fMyfoOJBMcWclE7bcUjXQazbRkIO0XBOm-BRI
							
							FEATURES:
							
							MISCELLANEOUS:
							
							NAVIGATION:
								* Enter script menu:
									* Hold LT and press Menu (Xbox)
									* Hold L2 and press Options (PlayStation)
								* Enter Anti-recoil Quick Edit
									* Hold LT and press View (Xbox)
									* Hold L2 and press Share (PlayStation)
								* Selecting values to edit or enabling/disabling Options
									* Press Up or Down
								* Editing values
									* Hold LT/L2 and press Right/Left (cycle setting/increase by 1/decrease by 1)
									* Hold LT/L2 and press Up/Down (increase by 10/decrease by 10)
								* Save Settings
									* Press B/Circle until your Cronus Zen device says "Settings Saved"
									
							CHANGE LOG:
								[Version 1.05]
								* [BUGS]
									- Fixed an issue where Auto Focus would disengage while firing
								* [UPGRADE]
									Aim Assist
										- Rotation Aim Assist now includes a Type option which can be Strafe or a shape
									Anti-Recoil
										- Anti-recoil algorithm now uses rumble feedback for smoother recoil control
								* [NEW]
									Aim Assist
										- Aim & Rotation Assist Shape: Diamond
									Options
										- Auto Ping: automatically ping when firing or repeatedly on an interval when firing
									Miscellaneous
										- Change Log introduced to record bug fixes, upgrades, changes, and new features
									
*/

/**************************************************************/
//	Variables
/**************************************************************/
// (Aim Assist)
int aimAssistAngle;
int aimAssistShapeMin, aimAssistShapeMax;
int aimAssistX, aimAssistY;
int aimAssistRadius, aimAssistShape, aimAssistSpeed;

// (Aim Assist) Aim Assist Type
int polarStick, polarValue;

// (Aim Assist) Idle Target Assist
int idleTargetEngaged, idleTargetTimer;

// (Aim Assist) Rotation Assist
int rotationAngle, rotationCounter, rotationType, rotationSpeed, rotationDirection, rotationRadius;

// (Anti-drift)
int antiDriftStickValue;
int antiDriftLowValue, antiDriftHighValue;
int antiDriftCalibrationLow, antiDriftCalibrationHigh;
int antiDriftCalibrationValue, antiDriftCalibrationRangeValue;
int antiDriftCalibrationState, antiDriftCalibrationInRange, antiDriftCalibrationCanSet;
int antiDriftCalibrationPolarStick, antiDriftCalibrationStick, antiDriftCalibrationDirection;

// (Anti-recoil)
int antiRecoilQuickEdit;
int antiRecoilX, antiRecoilY;
int antiRecoilCounterX, antiRecoilCounterY;
int antiRecoilStateX, antiRecoilStateY;
int antiRecoilRumble;

// Assist/option activation flags
int assistFlags;

// (Controller) Button and Stick Layout
int button[10];
int stick[4];

// (Controller) Current ADS & Fire button values
int holdingADS, holdingFire;

// Display
int displayDepth, displayUpdate;

// Display buffer
int displayBuffer, displayBufferInsertCopyValue, displayBufferInsertNumberOfDigits;
int displayBufferInsertDigits[5];

// Edit menu variables
int editMenuIndex;
int editMenuSelectedColumn, editMenuSelectedPage, editMenuSelectedRow;

// Loop iterators
int i, j;

// Memory and storage variables
int spvar_current_bit, spvar_current_slot, spvar_current_value, spvar_tmp, spvar_bits;

// Mod menu variables
int modMenuIndex, modMenuMin, modMenuMax;

// Profiles
int currentProfile, menuProfile;

// (Options)
int fastMeleeEnabled;

// (Screen saver)
int screenSaverEnabled, screenSaverCounter;

// (Screen saver) Script uptime
int uptimeCounter, uptimeDays, uptimeHours, uptimeMinutes, uptimeSeconds;

// Script paused
int scriptPaused;


/**************************************************************/
//	User-defined configuration variables
/**************************************************************/
// (Aim Assist)
int varAimAssist[3];
int varAimAssistType[3];
int varAimAssistAdsShape[3], varAimAssistFireShape[3];
int varAimAssistAdsRadius[3], varAimAssistFireRadius[3];
int varAimAssistAdsSpeed[3], varAimAssistFireSpeed[3];

// (Aim Assist) Idle Target Assist
int varIdleTargetAssist[3];
int varIdleTargetTime[3], varIdleTargetShape[3], varIdleTargetRadius[3], varIdleTargetSpeed[3];

// (Aim Assist) Rotation Assist
int varRotationAssist[3];
int varRotationAdsType[3], varRotationFireType[3];
int varRotationAdsRadius[3], varRotationFireRadius[3];
int varRotationAdsSpeed[3], varRotationFireSpeed[3];

// (Anti-drift)
int varAntidrift;
int varAntidriftLeft[4], varAntidriftRight[4];

// (Anti-recoil)
int varAntiRecoil[3];
int varAntiRecoilStrength[3];
int varAntiRecoilKickStrength[3], varAntiRecoilKickCounter[3];
int varAntiRecoilStart[3], varAntiRecoilMid[3], varAntiRecoilEnd[3];
int varAntiRecoilStartH[3], varAntiRecoilMidH[3], varAntiRecoilEndH[3];
int varAntiRecoilStartTime[3], varAntiRecoilMidTime[3];
int varAntiRecoilStartTimeH[3], varAntiRecoilMidTimeH[3];

// (Controller)
int varControllerButtonLayout, varControllerStickLayout, varControllerBumperPing, varControllerBumperTriggers, varControllerAdsStickSwap;

// (Options)
int varOptionAkimbo[3], varOptionAkimboSpeed[3];
int varOptionAutoADSFire[3];
int varOptionAutoFocus[3];
int varOptionBackpackSwap, varOptionBackpackSwapType;
int varOptionBunnyHop;
int varOptionAutoPing[3], varOptionAutoPingInterval[3];
int varOptionDropShot[3], varOptionDropShotAimAdjust[3];
int varOptionFastMelee[3];
int varOptionTacticalSprint;
int varOptionQuickScope[3], varOptionQuickScopeDelay[3];

// (Options) Rapid Fire
int varOptionRapidFire[3], varOptionRapidFireSpeed[3];

// (Profiles)
int varProfileColor[3];

// (Settings)
int varBlockRumble;
int varDeadzone[2];
int varInverted;
int varScreenSaver;
int varVMSpeed;

// (Toggles)
int varToggleButton[24];


/**************************************************************/
//	Enumerations
/**************************************************************/
// (Aim Assist) Aim Assist Type IDs
enum { aatDecreasing, aatSteady, aatIncreasing }

// (Aim Assist) Shape IDs
enum {
	aasCircle, aasOval, aasEllipse, aasLemniscate, aasRose, aasDiamond,
	aasFlower, aasOrbit, aasSpiral
}

// (Aim Assist) Rotation Shape IDs
enum {
	rasStrafe, rasCircle, rasOval,
	rasEllipse, rasLemniscate, rasRose, rasDiamond
}

// (Aim Assist) Aim/Rotation/Idle Target Assist status IDs
enum {
	assistOff,
	assistAdsOnly, assistFireOnly, assistAdsAndFire,
	assistAdsOrFire, assistAdsAndFireOrFire,
	assistOn
}

// (Anti-drift) Calibration direction
enum { antiDriftUp, antiDriftDown, antiDriftLeft, antiDriftRight }
// (Anti-drift) Calibratoin stick
enum { antiDriftLeftStick, antiDriftRightStick }
// (Anti-recoil) Status IDs
enum { antiRecoilOff, antiRecoilBasic, antiRecoilAdvanced, antiRecoilExpert }
// (Controller) Bumper/Triggers Flipped IDs
enum { cbtDefault, cbtFlipped }
// (Controller) Bumper Ping Swap IDs
enum { cbpDefault, cbpSwapped }
// (Controller) Button IDs
enum { ads, tactical, ping, focus, fire, lethal, weapon, action, jump, melee }

// (Controller) Button Layout IDs
enum {
	cblDefault, cblTactical, cblLefty,
	cblNomadCharlie, cblNomadCharlieTactical, cblNomadCharlieLefty,
	cblBumperJumper, cblBumperJumperTactical, cblOneHandGunslinger,
	cblStickAndMove, cblBrawler, cblBeast, cblBumperPing,
	cblBumperPingTactical
}

// (Controller) Stick layout IDs
enum { moveY, moveX, aimY, aimX }
// (Controller) Stick layout map IDs
enum { slDefault, slSouthpaw, slLegacy, slLegacySouthpaw, slSouthpawNoClickSwap, slLegacySouthpawNoClickSwap }
// (Display) Formatting IDs
enum { displayString, displayNumber }

// (Display) Text formatting & alignment IDs
enum {
	alignCenter = -2, alignRight, alignLeft = 5,
	alignBottom = -1, alignTop = 5
}

// (Display) Home screen message IDs
enum { homeScriptName, homeScriptVersion, homeScriptAuthor }
// (Display) LED color IDs
enum { red, orange, gold, white, yellow, green, teal, blue, purple, pink }
// (Display) LED (HSB) IDs
enum { hue, saturation, brightness }
// (Menu) Cycle value IDs
enum { cycleValueUp, cycleValueDown }

// (Menu) Edit menu navigation & event IDs
enum {
	// Table Lookup IDs
	editMenuMin, editMenuMax, editMenuShowProfile,
	// Event IDs
	editMenuLeft, editMenuRight, editMenuUp, editMenuDown, editMenuBumperL, editMenuBumperR,
	editMenuAction, editMenuEnter, editMenuExit
}

// (Menu) Mod navigation
enum {
	// Table Lookup IDs
	modMenuPrevious, modMenuCurrent, modMenuNext,
	// Event IDs
	modMenuDown, modMenuUp,
	modMenuEnter, modMenuExit
}

// (Options) Auto ADS/Fire
enum { autoADSFireOff, autoADSFireAutoADS, autoADSFireAutoFire }
// (Options) Fast Melee
enum { fastMeleeOff, fastMeleeHold, fastMeleeToggle }
// (Settings) Deadzone IDs
enum { deadzoneLeft, deadzoneRight }
// (Settings) Screen saver IDs
enum { screenSaverOff, screenSaverBlank, screenSaverUptime, screenSaverVisualizer }
// (Settings) VM speed IDs
enum { vmSpeed4, vmSpeed6, vmSpeed8, vmSpeed10 }

// (Toggle) Array IDs
enum {
	toggleProfile = 0,
	toggleUniversal = 2,
	// Options
	toggleAkimbo = 4,
	toggleAutoADS = 6,
	toggleAutoFocus = 8,
	toggleAutoPing = 10,
	toggleBackpackSwap = 12,
	toggleDropShot = 14,
	toggleFastMelee = 16,
	toggleRapidFire = 18,
	toggleTacticalSprint = 20,
	toggleQuickScope = 22
}

/**************************************************************/
//	Constants (strings)
/**************************************************************/
// (Aim Assist) Aim Assist Type
const string aimAssistTypeName[] = { "Decreasing", "Steady", "Increasing" }
// (Aim Assist) Aim/Rotation/Idle Target Assist status
const string assistStatus[] = { "Off", "ADS Only", "Fire only", "ADS & Fire", "ADS or Fire", "ADS & Fire / Fire",  "On" }
// (Aim Assist) Shapes
const string aimAssistShapeName[] = { "Circle", "Oval", "Ellipse", "Lemniscate", "Rose", "Diamond", "Flower", "Orbit", "Spiral" }
// (Aim Assist) Rotation Shape
const string aimAssistRotationType[] = { "Strafe", "Circle", "Oval", "Ellipse", "Lemniscate", "Rose", "Diamond" }
// (Aim Assist) Type prompt
const string aimAssistTypeMsg[] = { "ADS: ", "Fire: " }
// (Anti-drift) Calibration direction
const string antiDriftCalibrationDirectionPrompt[] = { "Direction: Up", "Direction: Down", "Direction: Left", "Direction: Right" }
// (Anti-drift) Calibration result
const string antiDriftCalibrationResult[] = { "Failed", "Success", "Cancelled", "Reset Value" }
// (Anti-drift) Calibration state
const string antiDriftCalibrationStateMsg[] = { "Press A/Cross", "Waiting" }
// (Anti-drift) Calibration stick
const string antiDriftCalibrationStickPrompt[] = { "Joystick: Left", "Joystick: Right" }
// (Anti-drift) Values display
const string antiDriftValues[] = { "U: ", "D: ", "L: ", "R: " }
// (Anti-recoil) Anti-recoil Type
const string antiRecoilStatus[] = { "Off", "Basic", "Advanced", "Expert" }
// (Anti-recoil) Anti-recoil Expert Menu
const string antiRecoilExpertMenu[] = { "V-Beg: ", "V-Mid: ", "V-End: ", "H-Beg: ", "H-Mid: ", "H-End: " }
// (Controller) Bumper/triggers Flipped status
const string flippedBumperTriggers[] = { "Default", "Flipped" }
// (Controller) Bumper Ping & ADS Stick Swap status
const string swappedStatus[] = { "Default", "Swapped" }

// (Controller) Button Layout names
const string buttonLayoutName[] = {
	"Default", "Tactical", "Lefty",
	"N0M4D/Charlie", "N0M4D/Charlie Tact", "N0M4D/Charlie L3F7",
	"Bumper Jumper", "Bumper Jumper Tact", "OneHand Gunslinger",
	"Stick and Move", "Brawler", "Beast", "Bumper Ping",
	"Bumper Ping Tac"
}

// (Controller) Button names [PlayStation]
const string controllerButtonsPS4[] = {
	"not set", "", "",
	"R1", "R2", "", "L1", "L2",
	"", "", "", "", "",
	"Up", "Down", "Left", "Right",
	"Triangle", "Circle", "Cross", "Square"
}

// (Controller) Button names [XBOX]
const string controllerButtonsXBOX[] = {
	"not set", "", "",
	"RB", "RT", "", "LB", "LT",
	"", "", "", "", "",
	"Up", "Down", "Left", "Right",
	"Y", "B", "A", "X"
}

// (Controller) Stick Layout names
const string stickLayoutName[] = { "Default", "Southpaw", "Legacy", "Legacy Southpaw", "Southpaw NCS", "Legacy SP NCS" }
// (Display) Home screen messages
const string homeScreenMessages[] = { "Zeitgeist", "Version 1.04", "Swedemafia" }
// (Display) LED color names
const string colorName[] = { "Red", "Orange", "Gold", "White", "Yellow", "Green", "Teal", "Blue", "Purple", "Pink" }
// (Display) On/off Toggle
const string toggleOffOn[] = { "Off", "On" }
// (Display) Script paused notification
const string scriptPausedMsg = "Paused";
// (Options) Akimbo Fire Mode
const string akimboAuto = "Full Automatic";
// (Options) Auto ADS/Fire
const string autoADSFireType[] = { "Off", "ADS on Fire", "Fire on ADS" }
// (Options) Auto Ping
const string autoPing[] = { "Interval: ", "Ping Once on Fire" }
// (Options) Backpack Swap
const string backpackSwap[] = { "Double Tap Swap", "Use Toggle" }
// (Options) Drop Shot Aim Adjust
const string dropShotAimAdjust = "Aim Adjust: "
// (Options) Fast Melee
const string fastMeleeType[] = { "Off", "Hold", "Toggle" }
// (Options) Fire Speed
const string fireSpeed = "Shots/Second: "
// (Options) Quick Scope Delay
const string quickScopeDelay = "Fire Delay: "

// (Profiles) Profile toggle/color prompts
const string profileToggleMsg[] = {
	"Resync: ", "Switch: ", // Profile Switch
	"Button 1: ", "Button 2: ", // Universal Switch
	"Primary:   ", "Secondary: ", "Universal: " // Profile Colors
}

// (Profiles) Profile names
const string profileName[] = { "Primary", "Secondary", "Universal", "All Profiles" }
// (Settings) Deadzone prompt
const string stickName[] = { "Left: ", "Right: " }
// (Settings) Screen saver names
const string screenSaver[] = { "Off", "Blank", "Uptime", "Visualizer" }
// (Settings) VM speed display
const string vmSpeed[] = { "4ms", "6ms", "8ms", "Default" }
// (Settings) Settings saved notification
const string settingsSaved = "Settings Saved";

// (Toggles) Toggle combo messages
const string toggleMessages[] = {
	"Akimbo: ", "Auto ADS/Fire: ", "Auto Focus: ", "Auto Ping: ", "Drop Shot: ",
	"Fast Melee: ", "Rapid Fire: ", "Tact. Sprint: ", "Quick Scope: "
}

/**************************************************************/
//	Constants (integers)
/**************************************************************/
// (Controller) Available toggle buttons
const int8 controllerButtons[] = {
	XB1_VIEW,
	XB1_RB, XB1_RT, XB1_LB, XB1_LT,
	XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT,
	XB1_Y, XB1_B, XB1_A, XB1_X
}

// (Controller) Button Layout map
const int8 buttonLayoutMap[][] = {
	// ADS	  Tact	  Ping	  Focus	  Fire	  Lethal  Switch Action Jump	Melee
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Default
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_A, XB1_B }, // Tactical
	{ XB1_RT, XB1_RB, XB1_UP, XB1_RS, XB1_LT, XB1_LB, XB1_Y, XB1_B, XB1_A, XB1_LS }, // Lefty
	{ XB1_RB, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_LT, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Nomad/Charlie
	{ XB1_RB, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_LT, XB1_Y, XB1_RS, XB1_A, XB1_B }, // Nomad/Charlie Tac
	{ XB1_LB, XB1_RB, XB1_UP, XB1_RS, XB1_LT, XB1_RT, XB1_Y, XB1_B, XB1_A, XB1_LS }, // Nomad/Charlie Left
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_LB, XB1_RS }, // Bumper Jumper
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_LB, XB1_B }, // Bumper Jumper Tact
	{ XB1_LT, XB1_RB, XB1_UP, XB1_LS, XB1_LB, XB1_RT, XB1_Y, XB1_B, XB1_A, XB1_RS }, // One-hand Gunslinger
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_RS, XB1_A }, // Stick and Move
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RS, XB1_Y, XB1_B, XB1_A, XB1_RB }, // Brawler
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RS, XB1_Y, XB1_B, XB1_LB, XB1_RB }, // Beast
	{ XB1_LT, XB1_RB, XB1_LB, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Bumper Ping
	{ XB1_LT, XB1_RB, XB1_LB, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_A, XB1_B }  // Bumper Ping Tactical
}

// (Controller) Stick Layout map
const int8 stickLayoutMap[][] = {
	// Move   	Strafe  	Look    Rotate    
	{ POLAR_LY, POLAR_LX, POLAR_RY, POLAR_RX }, // Default
	{ POLAR_RY, POLAR_RX, POLAR_LY, POLAR_LX }, // Southpaw
	{ POLAR_LY, POLAR_RX, POLAR_RY, POLAR_LX }, // Legacy
	{ POLAR_RY, POLAR_LX, POLAR_LY, POLAR_RX }, // Legacy Southpaw
	{ POLAR_RY, POLAR_RX, POLAR_LY, POLAR_LX }, // Southpaw No Click Swap
	{ POLAR_RY, POLAR_LX, POLAR_LY, POLAR_RX }  // Legacy Southpaw No Click Swap
}

// (Display) HSB color values
const int16 colorValues[][] = {
	{ 0, 100, 75 }, // Red
	{ 10, 100, 75 }, // Orange
	{ 17, 100, 100 }, // Gold
	{ 20, 50, 100 }, // White
	{ 30, 100, 100 }, // Yellow
	{ 120, 100, 75 }, // Green
	{ 135, 100, 75 }, // Teal
	{ 200, 100, 50 }, // Blue
	{ 300, 100, 50 }, // Purple
	{ 359, 50, 75 } // Pink
}

// (Display) Line numbers for OLED_FONT_SMALL
const int8 lineNumber[] = { 22, 34, 46 }
// (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
// (Display) Font width
const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }
// (Setings) VM Speed
const int8 vmSpeedValue[] = { -6, -4, -2, 0 }

/**************************************************************/
//	Menus
/**************************************************************/
// (Menu) Edit menu names
const string editMenuNames[] = {
	/* Aim Assist */			"Aim Assist", "Aim Assist Type", "Aim Assist Shape", "Aim Assist Radius", "Aim Assist Speed",
	/* Rotation Assist */		"Rotation Assist", "Rotation Type", "Rotation Radius", "Rotation Speed",
	/* Idle Target Assist */	"Idle Target Assist", "Idle Target Time", "Idle Target Shape", "Idle Target Radius", "Idle Target Speed",
	//
	// Anti-drift
	"Anti-drift", "Calibration", "Drift Test", "Drift Values",
	// Anti-recoil
	"Anti-recoil",
	/* Basic */					"Strength",
	/* Advanced */				"Kick Strength", "Kick Duration",
	/* Expert */				"Expert Settings",
	//
	// Controller
	"Button Layout", "Bumper Ping", "Bumper/Triggers", "Stick Layout", "ADS Stick Swap",
	// Options
	"Akimbo", "Auto ADS/Fire", "Auto Focus", "Auto Ping", "Backpack Swap", "Bunny Hop", "Drop Shot", "Fast Melee", "Rapid Fire", "Tactical Sprint", "Quick Scope",
	// Profiles
	"Profile Buttons", "Universal Profile", "Profile Colors",
	// Settings
	"Block Rumble", "Deadzone", "Inverted", "Screen Saver", "VM Speed",
	// Toggles
	"Akimbo", "Auto ADS/Fire", "Auto Focus", "Auto Ping", "Backpack Swap", "Drop Shot", "Fast Melee", "Rapid Fire", "Tactical Sprint", "Quick Scope"
}

// (Menu) Edit menu IDs
enum {
	// Aim Assist
	editMenuAimAssist, editMenuAimAssistBoost, editMenuAimAssistShape, editMenuAimAssistRadius, editMenuAimAssistSpeed,
	/* Rotation Assist  */	editMenuRotationAssist, editMenuRotationType, editMenuRotationRadius, editMenuRotationSpeed,
	/* Idle Target */		editMenuIdleTargetAssist, editMenuIdleTargetTime, editMenuIdleTargetShape, editMenuIdleTargetRadius, editMenuIdleTargetSpeed,
	//
	// Anti-drift
	editMenuAntidrift, editMenuAntidriftCalibration, editMenuAntidriftTest, editMenuAntidriftValues,
	// Anti-recoil
	editMenuAntiRecoil,
	/* Basic */ 			editMenuAntiRecoilStrength,
	/* Advanced */			editMenuAntiRecoilKickStrength, editMenuAntiRecoilKickCounter,
	/* Expert */			editMenuAntiRecoilExpert,
	//
	// Controller
	editMenuControllerButtonLayout, editMenuControllerBumperPing, editMenuControllerBumperTriggers, editMenuControllerStickLayout, editMenuControllerAdsStickSwap, 
	// Options
	editMenuAkimbo, editMenuAutoADS, editMenuAutoFocus, editMenuAutoPing, editMenuBackpackSwap, editMenuBunnyHop,
	editMenuDropShot, editMenuFastMelee, editMenuRapidFire, editMenuTacticalSprint, editMenuQuickScope,
	// Profiles
	editMenuProfileSwitch, editMenuUniversalSwitch, editMenuProfileColors,
	// Settings
	editMenuBlockRumble, editMenuDeadzone, editMenuInverted, editMenuScreenSaver, editMenuVMSpeed,
	// Toggles
	editMenuToggleAkimbo, editMenuToggleAutoADS, editMenuToggleAutoFocus, editMenuToggleAutoPing, editMenuToggleBackpackSwap, editMenuToggleDropShot,
	editMenuToggleFastMelee, editMenuToggleRapidFire, editMenuToggleTacticalSprint, editMenuToggleQuickScope
}

// (Display) Edit menu items
const int8 editMenuItems[][] = {
	  // Menu			Head							Tail							Show Profile
	{ /* Aim Assist */ 	editMenuAimAssist, 				editMenuIdleTargetSpeed, 		TRUE },
	{ /* Anti-drift */ 	editMenuAntidrift, 				editMenuAntidriftValues, 		FALSE },
	{ /* Anti-recoil */ editMenuAntiRecoil, 			editMenuAntiRecoilExpert, 		TRUE },
	{ /* Controller */	editMenuControllerButtonLayout, editMenuControllerAdsStickSwap, FALSE },
	{ /* Options */		editMenuAkimbo, 				editMenuQuickScope, 			TRUE },
	{ /* Profiles */	editMenuProfileSwitch, 			editMenuProfileColors, 			FALSE },
	{ /* Settings */	editMenuBlockRumble, 			editMenuVMSpeed, 				FALSE },
	{ /* Toggles */		editMenuToggleAkimbo, 			editMenuToggleQuickScope, 		FALSE }
}

// (Menu) Mod menu names
const string modMenuNames[] = { "Aim Assist", "Anti-drift", "Anti-recoil", "Controller", "Options", "Profiles", "Settings", "Toggles" }

// (Menu) Mod menu IDs
enum {
	modMenuAimAssist, modMenuAntidrift, modMenuAntiRecoil, modMenuController,
	modMenuOptions, modMenuProfiles, modMenuSettings, modMenuToggles
}

// (Display) Mod menu items
const int8 modMenuItems[][] = {
	  // Menu			Previous			Data				Next
	{ /* Aim Assist */	modMenuToggles, 	modMenuAimAssist, 	modMenuAntidrift },
	{ /* Anti-drift */	modMenuAimAssist, 	modMenuAntidrift, 	modMenuAntiRecoil },
	{ /* Anti-recoil */	modMenuAntidrift, 	modMenuAntiRecoil, 	modMenuController },
	{ /* Controller */	modMenuAntiRecoil, 	modMenuController, 	modMenuOptions },
	{ /* Options */		modMenuController, 	modMenuOptions, 	modMenuProfiles },
	{ /* Profiles */	modMenuOptions, 	modMenuProfiles, 	modMenuSettings },
	{ /* Settings */	modMenuProfiles, 	modMenuSettings, 	modMenuToggles },
	{ /* Toggles */		modMenuSettings, 	modMenuToggles,	 	modMenuAimAssist }
}

/**************************************************************/
//	Begin script
/**************************************************************/
init {
	// Initialize menu min/max
	aimAssistShapeMin = aasCircle;
	aimAssistShapeMax = aasSpiral;
	modMenuMin = modMenuAimAssist;
	modMenuMax = modMenuToggles;
	
	displayBuffer = 1; // Initialize display buffer
	loadSettings(); // Load user-defined settings
}

main {
	
	// Calculate uptime
	calculateUptime();
	
	if(!displayDepth) { // Home screen
		// Do not do anything if any specific combos are running
		if(!checkPause()) {
			if(!checkCombos()) {
				// Check for Screen Saver, otherwise display Home Screen
				if(!screenSaverEnabled) {
					if(screenSaverCounter >= 2000) {
						screenSaverEnabled = TRUE; // Enable Screen Saver
						cls_oled(OLED_BLACK); // Clear screen
					} else if(!screenSaverCounter) {
						displayHomeScreen(); // Display Home Screen
						vm_tctrl(vmSpeedValue[varVMSpeed]); // Set VM speed
					}
					screenSaverCounter += get_rtime(); // Increase Screen Saver counter
				} else if(varScreenSaver != screenSaverVisualizer) {
					displayScreenSaver(); // Display Screen Saver
				}
				
				// Check for menu action
				if(get_val(button[ads]) && !antiRecoilQuickEdit && !combo_running(cboSwitchProfile)) {
					// Determine menu to enter, if any
					if(event_press(XB1_MENU)) {
						// Set display depth & enable update
						displayDepth = 1;
						displayUpdate = TRUE;
						// Reset Screen Saver
						screenSaverCounter = 0;
						screenSaverEnabled = FALSE;
						// Set current profile
						menuProfile = currentProfile;
					} else if(event_press(XB1_VIEW)) {
						// Set display depth & enable update
						displayDepth = 2;
						displayUpdate = TRUE;
						// Reset Screen Saver
						screenSaverCounter = 0;
						screenSaverEnabled = FALSE;
						// Enable Anti-recoil Quick Edit
						antiRecoilQuickEdit = TRUE;
						// Determine menu to show based on being enabled or not
						if(!varAntiRecoil[menuProfile]) {
							editMenuIndex = editMenuAntiRecoil;
						} else if(varAntiRecoil[menuProfile] < antiRecoilExpert) {
							editMenuIndex = editMenuAntiRecoilStrength;
						} else {
							editMenuIndex = editMenuAntiRecoilExpert;
						}
					}
				}
			}
			
			// Remove drift and apply deadzone if calibration is not running
			if(!antiDriftCalibrationState) {
				removeDriftAndApplyDeadzone(); // Remove stick drift and apply deadzone
				checkAdsStickSwap(); // Perform check for 'ADS Stick Swap' setting
				checkOptions(); // Execute any running options
				checkTriggers(); // Get trigger state & set hair triggers
				checkAssist(); // Execute any enabled assists (Aim Assist [+etc.], Rotation Assist, Anti-Recoil)
				checkToggles(); // Execute any toggles
				blockActionButtons(); // Block any buttons used in toggles/profile switches
				
				// If Rapid Fire not enabled, Set LED color to notify user of current profile
				if(!varOptionRapidFire[currentProfile] ) {
					setProfileLedColor(currentProfile); 
				} else {
					// If Rapid Fire enabled, enable alert
					combo_run(cboAlertRapidFire);
				}
			}
		}
	} else if(displayDepth == 1) { // Mod menu
		// Set LED to Profile being edited
		setProfileLedColor(menuProfile);
		// Check for mod menu events
		checkModMenuEvent();
		// Check for Profile switches
		checkToggles();
	} else if(displayDepth == 2) { // Edit menu
		if(editMenuIndex == editMenuProfileColors) {
			// Set LED to Profile Color being edited
			setProfileLedColor(editMenuSelectedRow);
		} else if(antiDriftCalibrationState) {
			// Determine stick being calibrated
			if(antiDriftCalibrationStick == antiDriftLeftStick) {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_LY, POLAR_LX);
			} else {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_RY, POLAR_RX);
			}
			// Check calibration range
			checkCalibrationRange();
			// Notify user of calibration state
			setLedColor(iif(antiDriftCalibrationInRange, green, orange));
		} else {
			// Remove drift only in drift test menu
			if(editMenuIndex == editMenuAntidriftTest) {
				removeDriftAndApplyDeadzone();
			}
			// Set LED to Profile being edited
			setProfileLedColor(menuProfile);
		}
		
		// Check for edit menu event
		checkEditMenuEvent();
		 // Check for Profile switches
		checkToggles();
	}
	
	blockMenuButtons(); // Block any buttons pressed if in a menu
	checkBlockRumble(); // Always check for blocking rumbled called for by the game
}


/**************************************************************/
//	Functions
/**************************************************************/
// Block output to controller from menu actions
function blockActionButtons() {
	// Loop through each toggle combination and block if being used
	for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i += 2) {
		if(varToggleButton[i] && varToggleButton[i + 1]) {
			if(get_val(varToggleButton[i]) && get_ptime(varToggleButton[i + 1]) < 250) {
				set_val(varToggleButton[i + 1], 0);
			}
		}
	}
	// Block quick edit recoil and entering the menu buttons
	if(get_val(button[ads])) {
		set_val(XB1_MENU, 0);
		set_val(XB1_VIEW, 0);
	}
}

// Block output to controller from menu actions
function blockMenuButtons() {
	// Block all buttons while in a menu
	if(displayDepth || antiRecoilQuickEdit) {
		block_all_inputs();
	}
}

// Prepares the display buffer for a multiple item menu
function buildSelectedItemBuffer(type, message, value) {
	// Build display
	insertString(message);
	
	// Determine data type being used
	if(type == displayString) {
		insertString(value);
	} else {
		insertNumber(value);
	}
}

// Calculate uptime values
function calculateUptime() {
	uptimeCounter += get_rtime();
	if(uptimeCounter >= 1000) {
		uptimeSeconds++;
		uptimeCounter -= 1000;
		if(uptimeSeconds >= 60) {
			uptimeMinutes++;
			uptimeSeconds = 0;
			if(uptimeMinutes >= 60) {
				uptimeHours++;
				uptimeMinutes = 0;
				if(uptimeHours >= 24) {
					uptimeDays++;
					uptimeHours = 0;
				}
			}
		}
	}
}

// Checks the stick when in calibration mode to make sure the
// user has moved the stick to the appropriate range prior to
// releasing the stick and setting the new value
function checkCalibrationRange() {
	// Determine target range
	if((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) {
		antiDriftCalibrationLow = -11468; // 35
		antiDriftCalibrationHigh = -8191 // 25
	} else {
		antiDriftCalibrationLow = 8191; // 25
		antiDriftCalibrationHigh = 11468; // 35
	}
	
	// Get stick value
	antiDriftCalibrationRangeValue = get_val(antiDriftCalibrationPolarStick);
	
	// See if stick is moved within boundaries
	if((antiDriftCalibrationRangeValue >= antiDriftCalibrationLow) && (antiDriftCalibrationRangeValue <= antiDriftCalibrationHigh)) {
		// Notify user it is in range and allow calibration to proceed
		antiDriftCalibrationInRange = TRUE;
		antiDriftCalibrationCanSet = TRUE;
	} else if(((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) && antiDriftCalibrationRangeValue < antiDriftCalibrationLow) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else if(((antiDriftCalibrationDirection == antiDriftRight) || (antiDriftCalibrationDirection == antiDriftDown)) && antiDriftCalibrationRangeValue > antiDriftCalibrationHigh) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else {
		// Release zone not met
		antiDriftCalibrationInRange = FALSE;
	} 
}

// Checks if a status change combo is running (i.e. action failed/success)
function checkCombos() {
	if(combo_running(cboActionFailed)) {
		return TRUE;
	} else if(combo_running(cboActionSuccess)) {
		return TRUE;
	} else if(combo_running(cboSaveSettings)) {
		return TRUE;
	} else if(combo_running(cboToggleOn) || combo_running(cboToggleOff)) {
		return TRUE;
	}
	return FALSE;
}

// Checks for activation based on ADS and Fire flags
function checkActivation(activation) {
	// Check activation flags
	if(activation) {
		//	ADS Only / Fire Only / ADS & Fire				ADS or Fire										(ADS & Fire OR Fire)
		return ((activation == assistFlags) || ((activation == assistAdsOrFire) && assistFlags) || ((activation == assistAdsAndFireOrFire) && (assistFlags & 2)));
	}
	
	return 0;
}

// Controller ADS stick swap
function checkAdsStickSwap() {
	// Check if ADS stick swap is enabled
	if(varControllerAdsStickSwap == cbpSwapped) {
		stick[aimX] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][moveX], stickLayoutMap[varControllerStickLayout][aimX]);
		stick[aimY] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][moveY], stickLayoutMap[varControllerStickLayout][aimY]);
		stick[moveX] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][aimX], stickLayoutMap[varControllerStickLayout][moveX]);
		stick[moveY] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][aimY], stickLayoutMap[varControllerStickLayout][moveY]);
	}
	// else, do nothing
}

// Determine which Assist mods must be executed
// - Aim Assist (+etc.), Rotation Assist, Anti-recoil
function checkAssist() {
	
	// Set flags
	assistFlags = (holdingADS > 0) | ((holdingFire > 0) << 1);
	assistFlags = (assistFlags & ~varOptionAkimbo[currentProfile]);
	
	// Check Aim Assist
	if(checkActivation(varAimAssist[currentProfile])) {
		executeAimAssist();
	} else if (varAimAssist[currentProfile]) {
		resetAimAssist(); // Correct aim assist
	}
	
	// Check Rotation Assist
	if(checkActivation(varRotationAssist[currentProfile])) {
		executeRotationAssist();
	} else if(varRotationAssist[currentProfile]) {
		rotationCounter = 0; // Reset rotation counter
	}
	
	// Check Anti-recoil
	if(varAntiRecoil[currentProfile] && checkActivation(assistAdsAndFire) && !combo_running(cboOptionDropShot)) {
		executeAntiRecoil();
	} else if(varAntiRecoil[currentProfile]) {
		antiRecoilStateX = 0; // Reset horizontal stage
		antiRecoilStateY = 0; // Reset vertical stage
		antiRecoilCounterX = 0; // Reset horizontal counter
		antiRecoilCounterY = 0; // Reset vertical counter
	}
	
	assistFlags = 0; // Reset assist (aiming/firing) flags
}

// Checks for rumble block state
function checkBlockRumble() {
	if(varBlockRumble) {
		block_rumble();
	}
}

// Check and perform display update
function checkDisplayUpdate() {
	// Check for a display update
	if(displayUpdate) {
		// Clear display
		cls_oled(OLED_BLACK);
		// Determine menu to display
		if(displayDepth == 1) {
			displayModMenu(); // Display mod menu
		} else if(displayDepth == 2) {
			displayEditMenu(); // Display edit menu
		}
	}
}

// Check for edit menu event
function checkEditMenuEvent() {
	// See if edit menu needs to update to the display
	checkDisplayUpdate();
	
	// See if we are setting toggle combination buttons
	switch(editMenuIndex) {
		case editMenuProfileSwitch {
			createToggle(toggleProfile);
			break;
		} case editMenuUniversalSwitch {
			createToggle(toggleUniversal);
			break;
		} case editMenuToggleAkimbo {
			createToggle(toggleAkimbo);
			break;
		} case editMenuToggleAutoADS {
			createToggle(toggleAutoADS);
			break;
		} case editMenuToggleAutoFocus {
			createToggle(toggleAutoFocus);
			break;
		} case editMenuToggleAutoPing {
			createToggle(toggleAutoPing);
			break;
		} case editMenuToggleBackpackSwap {
			createToggle(toggleBackpackSwap);
			break;
		} case editMenuToggleDropShot {
			createToggle(toggleDropShot);
			break;
		} case editMenuToggleFastMelee {
			createToggle(toggleFastMelee);
			break;
		} case editMenuToggleRapidFire {
			createToggle(toggleRapidFire);
			break;
		} case editMenuToggleTacticalSprint {
			createToggle(toggleTacticalSprint);
			break;
		} case editMenuToggleQuickScope {
			createToggle(toggleQuickScope);
			break;
		}
	}
	
	// Check for events (only responsive to presses under 1000ms)
	if(checkEvent(XB1_LEFT)) { // Request edit menu cycle left
		cycleEditMenu(editMenuLeft);
	} else if(checkEvent(XB1_RIGHT)) { // Request edit menu cycle right
		cycleEditMenu(editMenuRight);
	} else if(checkEvent(XB1_UP)) { // Request edit menu cycle up
		cycleEditMenu(editMenuUp);
	} else if(checkEvent(XB1_DOWN)) { // Request edit menu cycle down
		cycleEditMenu(editMenuDown);
	} else if(checkEvent(XB1_LB)) { // Used for anti-drift calibration mode
		cycleEditMenu(editMenuBumperL);
	} else if(checkEvent(XB1_RB)) { // Used for anti-drift calibration mode
		cycleEditMenu(editMenuBumperR);
	} else if(checkEvent(XB1_A)) { // Used for anti-drift calibration mode
		cycleEditMenu(editMenuEnter);
	} else if(checkEvent(XB1_B)) { // Exit edit menu to mod menu
		cycleEditMenu(editMenuExit);
	} else if(checkEvent(XB1_VIEW)) {
		cycleEditMenu(editMenuAction);
	}
	
	if(editMenuIndex == editMenuAntidriftTest) {
		// Constantly update display
		displayUpdate = TRUE;
	}
}

// Determine if an event is being called
function checkEvent(button) {
	return (event_release(button) && (get_ptime(button) < 720));
}

// Check for mod menu event
function checkModMenuEvent() {
	// See if edit menu needs to update to the display
	checkDisplayUpdate();
	
	// Check for events
	if(event_press(XB1_DOWN)) { // Request mod menu cycle downwards
		cycleModMenu(modMenuDown);
	} else if(event_press(XB1_UP)) {// Request mod menu cycle upwards
		cycleModMenu(modMenuUp); 
	} else if(event_press(XB1_A)) { // Request enter mod menu
		cycleModMenu(modMenuEnter);
	} else if(event_press(XB1_B)) { // Exit mod menu to home screen
		cycleModMenu(modMenuExit);
	} else {
		displayUpdate = FALSE;
	}
}

// Checks for running options and executes them if enabled
function checkOptions() {
	// Akimbo
	if(varOptionAkimbo[currentProfile]) {
		if(get_ival(button[ads]) || get_ival(button[fire])) {
			if(varOptionAkimboSpeed[currentProfile]) {
				if(!combo_running(cboOptionAkimbo)) {
					combo_stop(cboOptionTacticalSprint);
					combo_run(cboOptionAkimbo);
				}
			} else {
				set_val(button[ads], 100);
				set_val(button[fire], 100);
			}
		} else {
			combo_stop(cboOptionAkimbo);
		}
	} else {
		// Auto ADS/Fire (ignore if Akimbo enabled)
		if((varOptionAutoADSFire[currentProfile] == autoADSFireAutoADS) && holdingFire) {
			set_val(button[ads], 100);
		} else if((varOptionAutoADSFire[currentProfile] == autoADSFireAutoFire) && holdingADS) {
			set_val(button[fire], 100);
		}
		
		// Auto Focus
		if(varOptionAutoFocus[currentProfile]) {
			// If aiming, execute combo
			if(combo_running(cboOptionAutoFocus) && !combo_running(cboToggleScope) && holdingADS && get_ival(button[focus]) && get_ptime(button[focus]) <= 120) {
				combo_stop(cboOptionAutoFocus);
				combo_run(cboToggleScope);
			} else if(holdingADS && get_ival(button[focus])) {
				// Do not want to restart the combo in middle of holding button[focus] or it may just result in a toggle
				if(!(combo_step_time_left(cboOptionAutoFocus) >= 2800 && combo_step_time_left(cboOptionAutoFocus) <= 2900)) {
					combo_restart(cboOptionAutoFocus);
				}
			} else if(holdingADS) {
				// Execute Auto Focus as long as we are holding ADS
				combo_run(cboOptionAutoFocus);
			} else {
				// Stop Auto Focus
				combo_stop(cboOptionAutoFocus);	
			}
		}
		
		// Rapid Fire (will not work if Akimbo enabled)
		if(varOptionRapidFire[currentProfile] && holdingFire) {
			combo_run(cboOptionRapidFire); // Execute Rapid Fire	
		} else {
			combo_stop(cboOptionRapidFire); // Stop Rapid Fire
		}
		
		// Quick Scope
		if(varOptionQuickScope[currentProfile]) {
			if(!holdingFire && event_press(button[ads])) {
				combo_run(cboOptionQuickScope);
			}
		}
	}
	
	// Auto Ping
	if(varOptionAutoPing[currentProfile]) {
		if(holdingADS) {
			if(!varOptionAutoPingInterval[currentProfile] && event_press(button[fire])) {
				combo_run(cboOptionAutoPingOnce);
			} else if(varOptionAutoPingInterval[currentProfile] && holdingFire) {
				combo_run(cboOptionAutoPing);
			}
		}
	}
	
	// Backpack Swap
	if(varOptionBackpackSwap) {
		if(!varOptionBackpackSwapType && event_press(button[weapon]) && get_brtime(button[weapon]) < 240) {
			combo_run(cboOptionBackpackSwap);
		}
	}
	
	// Bunny Hop
	if(varOptionBunnyHop) {
		if(get_ival(button[jump])) {
			combo_run(cboOptionBunnyHop);
		}
	}
	
	// Drop shot
	if(varOptionDropShot[currentProfile]) {
		if(((holdingADS && holdingFire) || (combo_running(cboOptionAkimbo))) && event_press(button[action])) {
			combo_run(cboOptionDropShot);
		}
	}
	
	// Fast Melee
	if(varOptionFastMelee[currentProfile] == fastMeleeToggle) {
		// Only activate upon release in which it was held under 300ms
		// This will allow a user to assassinate/execute another player
		if(event_release(button[melee]) && get_ptime(button[melee]) < 300) {
			fastMeleeEnabled = !fastMeleeEnabled; // Toggle Fast Melee
		}
		// Determine whether to continue or not
		if(fastMeleeEnabled) {
			// If user ADS or Fire during Fast Melee, disable Fast Melee
			if(!holdingADS && !holdingFire) {
				combo_run(cboOptionFastMelee);
			} else {
				fastMeleeEnabled = !fastMeleeEnabled; // Disable Fast Melee
				combo_stop(cboOptionFastMelee);
			}
		} else {
			combo_stop(cboOptionFastMelee);
		}
	} else if((varOptionFastMelee[currentProfile] == fastMeleeHold) && get_val(button[melee])) {
		combo_run(cboOptionFastMelee); // Execute Fast Melee
		fastMeleeEnabled = TRUE;
	} else if(fastMeleeEnabled) {
		combo_stop(cboOptionFastMelee); // Stop Rapid Fire
		fastMeleeEnabled = FALSE;
	}
	
	// Tactical Sprint
	if(varOptionTacticalSprint) {
		if(get_val(stick[moveY]) <= inv(polarValues[74]) && !holdingADS && !holdingFire) {
			if(!combo_running(cboOptionTacticalSprint) && !combo_running(cboOptionAkimbo)) {
				combo_run(cboOptionTacticalSprint);		
			}
		} else {
			combo_stop(cboOptionTacticalSprint);
		}
	}
}

// Checks if user is attempting to pause the script (i.e. when using a vehicle)
function checkPause() {
	// Check if pause button combination is pressed
	if(!scriptPaused && get_val(button[fire]) && event_press(XB1_RIGHT) && get_brtime(XB1_RIGHT) <= 240) {
		cls_oled(OLED_BLACK); // Clear screen
		scriptPaused = TRUE; // Set pause flag
		screenSaverEnabled = FALSE; // Disable screen saver
		screenSaverCounter = 0; // Reset screen saver timer
		printText(alignCenter, alignCenter, scriptPausedMsg[0], OLED_FONT_SMALL, OLED_WHITE); // Display message
	} else if(scriptPaused && event_press(XB1_X)) {
		cls_oled(OLED_BLACK); // Clear screen
		scriptPaused = FALSE; // Unpause script
		displayUpdate = TRUE; // Enable display update
		combo_stop(cboAlertScriptPaused); // Disable pause mode notification
	} else if(scriptPaused) {
		combo_run(cboAlertScriptPaused); // Enable vehicle mode notification
	}
	
	return scriptPaused;
}

// Checks if the aim assist shape to use is different from
// the last shape and resets aim assist values if needed 
function checkShapeChange(shape) {
	if(shape != aimAssistShape) {
		resetAimAssist();
	}
}

// Checks for toggle combination buttons to be pressed
function checkToggles() {
	// Only check for toggles when not in a menu
	if(!displayDepth) {
		// Loop through all toggle combinations
		for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i += 2) {
			// Only process if a toggle is set
			if(varToggleButton[i] && varToggleButton[i + 1]) {
				// See if toggle is requested
				if(get_val(varToggleButton[i]) && event_press(varToggleButton[i + 1])) {
					if(i == toggleProfile || i == toggleUniversal) {
						dispatchToggle(i);
					} else if(get_brtime(varToggleButton[i + 1]) <= 240) {
						dispatchToggle(i);
					}
					return;
				}
			}
		}
	
		// Switch profile button pressed
		if(varToggleButton[toggleProfile + 1] && (currentProfile != 2) && event_press(varToggleButton[toggleProfile + 1])) {
			displayUpdate = TRUE;
			switchProfile(!currentProfile);
			return;
		}
	}
	
	// Y/Triangle pressed in a edit menu that supports settings per profile
	if(editMenuItems[modMenuIndex][editMenuShowProfile] && event_press(XB1_Y)) {
		menuProfile = iif(menuProfile == 2, 0, menuProfile++);
		displayUpdate = TRUE;
	}
}

// Checks for triggers
function checkTriggers() {
	// Set stick position values and max out if buttons are pressed
	if(holdingADS = get_val(button[ads])) {
		set_val(button[ads], 100);
	}
	if(holdingFire = get_val(button[fire])) {
		set_val(button[fire], 100);
	}
	
	/*
	WARNING: Assignment in conditional detected, did you mean '==' instead of '='?, this warning originated on line xxxx column 4
	WARNING: Assignment in conditional detected, did you mean '==' instead of '='?, this warning originated on line xxxx column 4
	
	No, absolutely not. We want the assignment in the conditional.  We want to set the value and check it at the same time.
	*/
}

// Called to check if OLED should be cleared after an action while using Visualizer screen saver
function clearVisualizer() {
	// Check for visualizer screen saver
	if(screenSaverEnabled && varScreenSaver == screenSaverVisualizer) {
		combo_run(cboClearScreen); // Runs faster in a combo
	}
}

// Correct stick input based on drift low/high values including deadzone and compensate for "lost" values
function correctStickInput(low, high, deadzone, stick) {
	// Calculate the boundaries
	antiDriftLowValue = low - polarValues[deadzone];
	antiDriftHighValue = high + polarValues[deadzone];
	antiDriftStickValue = get_val(stick); // Get stick value
	
	// In the drift zone, so set stick to no movement
	if((antiDriftStickValue >= antiDriftLowValue) && (antiDriftStickValue <= antiDriftHighValue)) {
		set_val(stick, 0);
		
	// If user has moved stick under the lower boundary (left/up)
	} else if(antiDriftStickValue < antiDriftLowValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftLowValue) - ((antiDriftStickValue / 327) * antiDriftLowValue) / 100, -32768, 32767));
		
	// If user has moved stick over the upper boundary (right/down)
	} else if(antiDriftStickValue > antiDriftHighValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftHighValue) + ((antiDriftStickValue / 327) * antiDriftHighValue) / 100, -32768, 32767));
		
	// Just incase stick_value isn't in driftzone and doesn't meet other conditions
	// (i.e. calculations equate to low/high value)
	// At that point we still do not want to make any adjustment because we're not outside of the drift+deadzone
	} else {
		set_val(stick, 0);
	}
}

// Creates a toggle combination
function createToggle(toggle) {
	// Loop through each controllerButtons and see what is being held down for ~3/4 second
	for(i = 0; i < 13; i++) {	
		if(get_val(controllerButtons[i]) && (get_ptime(controllerButtons[i]) >= 720)) { // 720 is multiple of 4,6,8,10
			if(!editMenuSelectedRow) {
				// Setting HOLD
				varToggleButton[toggle] = setToggleButton(varToggleButton[toggle], controllerButtons[i], varToggleButton[toggle + 1]);
				varToggleButton[toggle] = verifyToggleCombo(varToggleButton[toggle], toggle);
			} else {
				// Setting PRESS
				varToggleButton[toggle + 1] = setToggleButton(varToggleButton[toggle + 1], controllerButtons[i], varToggleButton[toggle]);
				varToggleButton[toggle + 1] = verifyToggleCombo(varToggleButton[toggle + 1], toggle);
			}
		}
	}
}

// Cycles the edit menu
function cycleEditMenu(direction) {
	// Enable display update
	displayUpdate = TRUE;
	
	// Determine action from user and handle accordingly
	switch(direction) {
		case editMenuBumperL { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration) { // (Anti-drift) Calibration
				if((antiDriftCalibrationStick != antiDriftLeftStick) && !antiDriftCalibrationState) {
					antiDriftCalibrationStick = antiDriftLeftStick;
				} else {
					menuActionFailed();
				}
			} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
				editMenuSelectedPage = !editMenuSelectedPage; // Toggle pages
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuBumperR { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration) { // (Anti-drift) Calibration
				if((antiDriftCalibrationStick != antiDriftRightStick) && !antiDriftCalibrationState) {
					antiDriftCalibrationStick = antiDriftRightStick;
				} else {
					menuActionFailed();
				}
			} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
				editMenuSelectedPage = !editMenuSelectedPage; // Toggle pages
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuAction { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) {
				if(antiDriftCalibrationStick == antiDriftLeftStick) {
					varAntidriftLeft[antiDriftCalibrationDirection] = 0;
				} else {
					varAntidriftRight[antiDriftCalibrationDirection] = 0;
				}
				antiDriftCalibrationCanSet = 3;
				combo_run(cboCalibrationComplete); // Alert user of status
				antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuEnter { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				// Only set if range was met
				if(antiDriftCalibrationCanSet) {
					determineAntidriftValue(); // Determine the value to set
				}
				combo_run(cboCalibrationComplete); // Alert user of status
			} else if(editMenuIndex == editMenuAntidriftCalibration) {
				antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuExit { // When user presses B/Circle
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				antiDriftCalibrationCanSet = 2; // Flag for cancelled
				combo_run(cboCalibrationComplete);
			} else {
				// Check if we are in anti-recoil quick edit
				if(antiRecoilQuickEdit) {
					displayDepth = 0; // Reset to Home Screen
					antiRecoilQuickEdit = FALSE; // Disable anti-recoil quick edit
					combo_run(cboSaveSettings); // Save settings
				} else {
					displayUpdate = TRUE;
					displayDepth--; // Exit to Mod Menu
					editMenuSelectedColumn = 0; // Reset selected column
					editMenuSelectedPage = 0; // Reset selected page
					editMenuSelectedRow = 0; // Reset selected item index
					editMenuIndex = 0; // Reset index
				}
			}
			break;
		} case editMenuLeft { // When user presses Dpad-Left
			if(get_val(button[ads])) { // When user is holding ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 1, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 1, 1);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape
					if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
						} else {
							varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
						}
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 1, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 1, 1);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuRotationType) { // (Aim Assist) Shape
					if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsType[menuProfile] = cycleListOption(varRotationAdsType[menuProfile], cycleValueDown, rasStrafe, rasDiamond);
						} else {
							varRotationFireType[menuProfile] = cycleListOption(varRotationFireType[menuProfile], cycleValueDown, rasStrafe, rasDiamond);
						}
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 1, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 1, 1);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuRotationSpeed) { // (Aim Assist) Rotation Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 1, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 1, 1);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftLeft) {
						antiDriftCalibrationDirection = antiDriftLeft;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick Value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuAntiRecoilKickCounter) {  // (Anti-recoil) Kick Duration [advanced]
					varAntiRecoilKickCounter[menuProfile] = cycleEditValue(varAntiRecoilKickCounter[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[menuProfile] = cycleEditValue(varAntiRecoilStart[menuProfile], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid[menuProfile] = cycleEditValue(varAntiRecoilMid[menuProfile], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd[menuProfile] = cycleEditValue(varAntiRecoilEnd[menuProfile], cycleValueDown, 1, 0);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[menuProfile] = cycleEditValue(varAntiRecoilStartTime[menuProfile], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[menuProfile] = cycleEditValue(varAntiRecoilMidTime[menuProfile], cycleValueDown, 1, 0);
							}
						}
					} else {
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartH[menuProfile] = cycleEditValue(varAntiRecoilStartH[menuProfile], cycleValueDown, 1, -100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidH[menuProfile] = cycleEditValue(varAntiRecoilMidH[menuProfile], cycleValueDown, 1, -100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEndH[menuProfile] = cycleEditValue(varAntiRecoilEndH[menuProfile], cycleValueDown, 1, -100);
							}
						} else { // Time values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTimeH[menuProfile] = cycleEditValue(varAntiRecoilStartTimeH[menuProfile], cycleValueDown, 1, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTimeH[menuProfile] = cycleEditValue(varAntiRecoilMidTimeH[menuProfile], cycleValueDown, 1, 0);
							}
						}
					}
				} else if(editMenuIndex == editMenuAkimbo) { // (Options) Akimbo (Fire Speed)
					varOptionAkimboSpeed[menuProfile] = cycleEditValue(varOptionAkimboSpeed[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuAutoPing) { // (Options) Auto Ping (Ping Interval)
					varOptionAutoPingInterval[menuProfile] = cycleEditValue(varOptionAutoPingInterval[menuProfile], cycleValueDown, 120, 0);
				} else if(editMenuIndex == editMenuBackpackSwap) { // (Options) Backpack Swap
					varOptionBackpackSwapType = !varOptionBackpackSwapType;
				} else if(editMenuIndex == editMenuDropShot) { // (Options) Drop Shot Aim Adjust
					varOptionDropShotAimAdjust[menuProfile] = cycleEditValue(varOptionDropShotAimAdjust[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuQuickScope) { // (Options) Quick Scope Delay
					varOptionQuickScopeDelay[menuProfile] = cycleEditValue(varOptionQuickScopeDelay[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile colors
					varProfileColor[editMenuSelectedRow] = cycleListOption(varProfileColor[editMenuSelectedRow], cycleValueDown, red, pink);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueDown, 1, 0);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(editMenuSelectedColumn) {
						editMenuSelectedColumn--;
					} else {
						editMenuIndex = editMenuAntiRecoil; 
					}
				} else if((editMenuIndex == editMenuAimAssist) && (varIdleTargetAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if ITA is off
				} else if((editMenuIndex == editMenuIdleTargetAssist) && (varRotationAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if RA is off
				} else if((editMenuIndex == editMenuRotationAssist) && (varAimAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if RA is off
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilOff)) {
					menuActionFailed(); // Anti-recoil must be enabled to see rest of options
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilBasic)) {
					editMenuIndex = editMenuAntiRecoilStrength; // Basic Anti-Recoil can only access Strength menu
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilAdvanced)) {
					editMenuIndex = editMenuAntiRecoilKickCounter; // Advanced Anti-Recoil can access kick counter/duration menu
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilExpert)) { 
					editMenuIndex = editMenuAntiRecoilExpert; // Expert Anti-recoil only has one menu
				} else if(editMenuIndex == editMenuAntiRecoilExpert) {
					editMenuIndex = editMenuAntiRecoil; // Expert Anti-recoil only has one menu
				} else if(editMenuIndex == editMenuAntidrift && !varAntidrift) {
					menuActionFailed(); // Anti-drift must be enabled to see rest of options
				} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
					menuActionFailed(); // Cannot leave calibration menu if calibration is running
				} else {
					editMenuSelectedColumn = 0;
					editMenuSelectedRow = 0;
					editMenuIndex = cycleListOption(editMenuIndex, cycleValueDown, editMenuItems[modMenuIndex][editMenuMin], editMenuItems[modMenuIndex][editMenuMax]);
					// Will not alert in DisplayEditMenu due to constant repeat, so enable here
					if(editMenuIndex == editMenuAntidriftTest) {
						menuActionSuccess();	
					}
				}
			}
			break;
		} case editMenuRight { // When user presses DPad-Right
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 1, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 1, 100);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape
					if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
						} else {
							varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
						}
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 1, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 1, 100);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuRotationType) { // (Aim Assist) Rotation Assist Type
					if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsType[menuProfile] = cycleListOption(varRotationAdsType[menuProfile], cycleValueUp, rasDiamond, rasStrafe);
						} else {
							varRotationFireType[menuProfile] = cycleListOption(varRotationFireType[menuProfile], cycleValueUp, rasDiamond, rasStrafe);
						}
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 1, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 1, 100);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuRotationSpeed) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 1, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 1, 100);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftRight) {
						antiDriftCalibrationDirection = antiDriftRight;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuAntiRecoilKickCounter) {  // (Anti-recoil) Kick duration [advanced]
					varAntiRecoilKickCounter[menuProfile] = cycleEditValue(varAntiRecoilKickCounter[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[menuProfile] = cycleEditValue(varAntiRecoilStart[menuProfile], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid[menuProfile] = cycleEditValue(varAntiRecoilMid[menuProfile], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd[menuProfile] = cycleEditValue(varAntiRecoilEnd[menuProfile], cycleValueUp, 1, 100);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[menuProfile] = cycleEditValue(varAntiRecoilStartTime[menuProfile], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[menuProfile] = cycleEditValue(varAntiRecoilMidTime[menuProfile], cycleValueUp, 1, 100);
							}
						}
					} else {
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartH[menuProfile] = cycleEditValue(varAntiRecoilStartH[menuProfile], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidH[menuProfile] = cycleEditValue(varAntiRecoilMidH[menuProfile], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEndH[menuProfile] = cycleEditValue(varAntiRecoilEndH[menuProfile], cycleValueUp, 1, 100);
							}
						} else { // Time values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTimeH[menuProfile] = cycleEditValue(varAntiRecoilStartTimeH[menuProfile], cycleValueUp, 1, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTimeH[menuProfile] = cycleEditValue(varAntiRecoilMidTimeH[menuProfile], cycleValueUp, 1, 100);
							}
						}
					}
				} else if(editMenuIndex == editMenuAkimbo) { // (Options) Akimbo (Fire Speed)
					varOptionAkimboSpeed[menuProfile] = cycleEditValue(varOptionAkimboSpeed[menuProfile], cycleValueUp, 1, 60);
				} else if(editMenuIndex == editMenuAutoPing) { // (Options) Auto Ping (Ping Interval)
					varOptionAutoPingInterval[menuProfile] = cycleEditValue(varOptionAutoPingInterval[menuProfile], cycleValueUp, 120, 960);
				} else if(editMenuIndex == editMenuBackpackSwap) { // (Options) Backpack Swap
					varOptionBackpackSwapType = !varOptionBackpackSwapType;
				} else if(editMenuIndex == editMenuDropShot) { // (Options) Drop Shot Aim Adjust
					varOptionDropShotAimAdjust[menuProfile] = cycleEditValue(varOptionDropShotAimAdjust[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueUp, 1, 60);
				} else if(editMenuIndex == editMenuQuickScope) { // (Options) Quick Scope Delay
					varOptionQuickScopeDelay[menuProfile] = cycleEditValue(varOptionQuickScopeDelay[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile colors
					varProfileColor[editMenuSelectedRow] = cycleListOption(varProfileColor[editMenuSelectedRow], cycleValueUp, pink, red);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueUp, 1, 30); 	
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(editMenuSelectedRow != 2) {
						if(!editMenuSelectedColumn) {
							editMenuSelectedColumn++;
						} else {
							editMenuSelectedColumn = 0; // Reset column since we are leaving this menu
							editMenuIndex = editMenuAntiRecoil;
						}
					} else {
						menuActionFailed();
					}
				} else if((editMenuIndex == editMenuAimAssist) && (varAimAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if AA is off
				} else if((editMenuIndex == editMenuRotationAssist) && (varRotationAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if RA is off
				} else if((editMenuIndex == editMenuIdleTargetAssist) && (varIdleTargetAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if ITA is off
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilOff)) {
					menuActionFailed(); // Anti-recoil must be enabled to see rest of options 
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilBasic)) {
					editMenuIndex = editMenuAntiRecoilStrength; // Basic Anti-recoil can only access Strength option
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilExpert)) {
					editMenuIndex = editMenuAntiRecoilExpert;
				} else if((editMenuIndex == editMenuAntiRecoilStrength) && (varAntiRecoil[menuProfile] == antiRecoilBasic)) {
					editMenuIndex = editMenuAntiRecoil; // Basic Anti-recoil can only access Strength option and main toggle
				} else if((editMenuIndex == editMenuAntiRecoilStrength) && (varAntiRecoil[menuProfile] == antiRecoilAdvanced)) {
					editMenuIndex = editMenuAntiRecoilKickStrength; // Advanced Anti-recoil can access kick duration/strength
				} else if(editMenuIndex == editMenuAntiRecoilKickCounter) {
					editMenuIndex = editMenuAntiRecoil; // Advanced Anti-recoil cannot go past the counter
				} else if((editMenuIndex == editMenuAntiRecoilExpert) && (varAntiRecoil[menuProfile] == antiRecoilExpert)) {
					editMenuIndex = editMenuAntiRecoil; // Expert Anti-recoil only has one menu
				} else if(editMenuIndex == editMenuAntidrift && !varAntidrift) {
					menuActionFailed(); // Anti-drift must be enabled to see rest of options
				} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
					menuActionFailed(); // Cannot leave calibration menu if calibration is running
				} else {
					editMenuSelectedColumn = 0;
					editMenuSelectedRow = 0;
					editMenuIndex = cycleListOption(editMenuIndex, cycleValueUp, editMenuItems[modMenuIndex][editMenuMax], editMenuItems[modMenuIndex][editMenuMin]);
					// Will not alert in DisplayEditMenu due to constant repeat, so enable here
					if(editMenuIndex == editMenuAntidriftTest) {
						menuActionSuccess();	
					}
				}
			}
			break;
		} case editMenuUp { // When user presses DPad-Up
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 10, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 10, 100);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 10, 100);
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 10, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 10, 100);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 10, 100);
					} 
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 10, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 10, 100);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 10, 100);
					}
				} else if(editMenuIndex == editMenuRotationSpeed) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 10, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 10, 100);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 10, 100)
					}
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftUp) {
						antiDriftCalibrationDirection = antiDriftUp;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuAntiRecoilKickCounter) {  // (Anti-recoil) Kick duration [advanced]
					varAntiRecoilKickCounter[menuProfile] = cycleEditValue(varAntiRecoilKickCounter[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[menuProfile] = cycleEditValue(varAntiRecoilStart[menuProfile], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid[menuProfile] = cycleEditValue(varAntiRecoilMid[menuProfile], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd[menuProfile] = cycleEditValue(varAntiRecoilEnd[menuProfile], cycleValueUp, 10, 100);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[menuProfile] = cycleEditValue(varAntiRecoilStartTime[menuProfile], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[menuProfile] = cycleEditValue(varAntiRecoilMidTime[menuProfile], cycleValueUp, 10, 100);
							}
						}
					} else {
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartH[menuProfile] = cycleEditValue(varAntiRecoilStartH[menuProfile], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidH[menuProfile] = cycleEditValue(varAntiRecoilMidH[menuProfile], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEndH[menuProfile] = cycleEditValue(varAntiRecoilEndH[menuProfile], cycleValueUp, 10, 100);
							}
						} else { // Time values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTimeH[menuProfile] = cycleEditValue(varAntiRecoilStartTimeH[menuProfile], cycleValueUp, 10, 100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTimeH[menuProfile] = cycleEditValue(varAntiRecoilMidTimeH[menuProfile], cycleValueUp, 10, 100);
							}
						}
					}
				} else if(editMenuIndex == editMenuAkimbo) { // (Options) Akimbo (Fire Speed)
					varOptionAkimboSpeed[menuProfile] = cycleEditValue(varOptionAkimboSpeed[menuProfile], cycleValueUp, 10, 60);
				} else if(editMenuIndex == editMenuAutoPing) { // (Options) Auto Ping (Ping Interval)
					varOptionAutoPingInterval[menuProfile] = cycleEditValue(varOptionAutoPingInterval[menuProfile], cycleValueUp, 120, 960);
				} else if(editMenuIndex == editMenuDropShot) { // (Options) Drop Shot Aim Adjust
					varOptionDropShotAimAdjust[menuProfile] = cycleEditValue(varOptionDropShotAimAdjust[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueUp, 10, 60);
				} else if(editMenuIndex == editMenuQuickScope) { // (Options) Quick Scope Delay
					varOptionQuickScopeDelay[menuProfile] = cycleEditValue(varOptionQuickScopeDelay[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueUp, 10, 30);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAimAssist) { // (Aim assist)
					varAimAssist[menuProfile] = cycleListOption(varAimAssist[menuProfile], cycleValueUp, assistAdsAndFireOrFire, assistOff);
				} else if(editMenuIndex == editMenuAimAssistBoost) { // (Aim Assist) Type
					varAimAssistType[menuProfile] = cycleListOption(varAimAssistType[menuProfile], cycleValueUp, aatIncreasing, aatDecreasing);
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape selection
					if(varAimAssist[menuProfile] == assistAdsOnly) { // Ads only
						varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire setting allows selection of ads/fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else { // Fire only
						varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
					}
				} else if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Only available on Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Only available on Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationType) { // (Aim Assist) Rotation Assist Type selection
					if(varRotationAssist[menuProfile] == assistAdsOnly) { // Ads only
						varRotationAdsType[menuProfile] = cycleListOption(varRotationAdsType[menuProfile], cycleValueUp, rasDiamond, rasStrafe);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire setting allows selection of ads/fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else { // Fire only
						varRotationFireType[menuProfile] = cycleListOption(varRotationFireType[menuProfile], cycleValueUp, aasDiamond, aimAssistShapeMin);
					}
				} else if(editMenuIndex == editMenuRotationAssist) { // (Aim Assist) Rotation Assist
					varRotationAssist[menuProfile] = cycleListOption(varRotationAssist[menuProfile], cycleValueUp, assistAdsAndFireOrFire, assistOff);
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Radius selection
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationSpeed) { // (Aim Assist) Rotation speed selection
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuIdleTargetAssist) { // (Aim Assist) Idle Target Assist
					if(varIdleTargetAssist[menuProfile] == assistOff) {
						varIdleTargetAssist[menuProfile] = assistOn;
					} else {
						varIdleTargetAssist[menuProfile] = assistOff;
					}
				} else if(editMenuIndex == editMenuIdleTargetShape) { // (Aim Assist) Idle Target Assist Shape
					varIdleTargetShape[menuProfile] = cycleListOption(varIdleTargetShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
				} else if(editMenuIndex == editMenuAntidrift) { // (Anti-drift)
					varAntidrift = !varAntidrift;
				} else if(editMenuIndex == editMenuAntiRecoil) { // (Anti-recoil)
					varAntiRecoil[menuProfile] = cycleListOption(varAntiRecoil[menuProfile], cycleValueUp, antiRecoilExpert, antiRecoilOff);
				} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuControllerButtonLayout) { // (Controller) Button Layout
					varControllerButtonLayout = cycleListOption(varControllerButtonLayout, cycleValueUp, cblBumperPingTactical, cblDefault);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperPing) { // (Controller) Bumper Ping Swapped
					varControllerBumperPing = cycleListOption(varControllerBumperPing, cycleValueUp, cbpSwapped, cbpDefault);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperTriggers) { // (Controller) Bumper/Triggers Flipped
					varControllerBumperTriggers = !varControllerBumperTriggers;
					setBumperTriggers(); // Refresh bumper/triggers setting
				} else if(editMenuIndex == editMenuControllerStickLayout) { // (Controller) Stick Layout
					varControllerStickLayout = cycleListOption(varControllerStickLayout, cycleValueUp, slLegacySouthpawNoClickSwap, slDefault);
					setStickLayout(); // Refresh stick layout
				} else if(editMenuIndex == editMenuControllerAdsStickSwap) { // (Controller) ADS Stick Swap
					varControllerAdsStickSwap = !varControllerAdsStickSwap;
					if(!varControllerAdsStickSwap) { // No longer swapped, reset layout
						setStickLayout(); // Refresh stick layout
					}
				} else if(editMenuIndex == editMenuAkimbo) { // (Options) Akimbo
					varOptionAkimbo[menuProfile] = !varOptionAkimbo[menuProfile];
				} else if(editMenuIndex == editMenuAutoADS) { // (Options) Auto ADS/Fire
					varOptionAutoADSFire[menuProfile] = cycleListOption(varOptionAutoADSFire[menuProfile], cycleValueUp, autoADSFireAutoFire, autoADSFireOff);
				} else if(editMenuIndex == editMenuAutoFocus) { // (Options) Auto Focus
					varOptionAutoFocus[menuProfile] = !varOptionAutoFocus[menuProfile];
				} else if(editMenuIndex == editMenuAutoPing) { // (Options) Auto Ping
					varOptionAutoPing[menuProfile] = !varOptionAutoPing[menuProfile];
				} else if(editMenuIndex == editMenuBackpackSwap) { // (Options) Backpack Swap
					varOptionBackpackSwap = !varOptionBackpackSwap;
				} else if(editMenuIndex == editMenuBunnyHop) { // (Options) Bunny Hop
					varOptionBunnyHop = !varOptionBunnyHop;
				} else if(editMenuIndex == editMenuDropShot) { // (Options) Drop Shot
					varOptionDropShot[menuProfile] = !varOptionDropShot[menuProfile];
				} else if(editMenuIndex == editMenuFastMelee) { // (Options) Fast Melee
					varOptionFastMelee[menuProfile] = cycleListOption(varOptionFastMelee[menuProfile], cycleValueUp, fastMeleeToggle, fastMeleeOff);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFire[menuProfile] = !varOptionRapidFire[menuProfile];
				} else if(editMenuIndex == editMenuTacticalSprint) { // (Options) Tactical Sprint
					varOptionTacticalSprint = !varOptionTacticalSprint;
				} else if(editMenuIndex == editMenuQuickScope) { // (Options) Quick Scope
					varOptionQuickScope[menuProfile] = !varOptionQuickScope[menuProfile];
				} else if(editMenuIndex == editMenuProfileSwitch) { // (Profiles) Profile Buttons
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuUniversalSwitch) { // (Profiles) Universal Profile
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuBlockRumble) { // (Settings) Block Rumble
					varBlockRumble = !varBlockRumble;
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuInverted) { // (Settings) Inverted
					varInverted = !varInverted;
				} else if(editMenuIndex == editMenuScreenSaver) { // (Settings) Screen Saver
					varScreenSaver = cycleListOption(varScreenSaver, cycleValueUp, screenSaverVisualizer, screenSaverOff);
				} else if(editMenuIndex == editMenuVMSpeed) { // (Settings) VM Speed
					varVMSpeed = cycleEditValue(varVMSpeed, cycleValueUp, 1, vmSpeed10);
				} else if(modMenuIndex == modMenuToggles) { // (Toggles)
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				} else {
					menuActionFailed();
				}
			}
			break;
		} case editMenuDown { // When user presses DPad-Down
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 10, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 10, 1);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 10, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 10, 1);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 10, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 10, 1);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuRotationSpeed) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 10, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedRow) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 10, 1);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftDown) {
						antiDriftCalibrationDirection = antiDriftDown;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuAntiRecoilKickCounter) {  // (Anti-recoil) Kick duration [advanced]
					varAntiRecoilKickCounter[menuProfile] = cycleEditValue(varAntiRecoilKickCounter[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(!editMenuSelectedPage) { // Vertical values
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStart[menuProfile] = cycleEditValue(varAntiRecoilStart[menuProfile], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMid[menuProfile] = cycleEditValue(varAntiRecoilMid[menuProfile], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEnd[menuProfile] = cycleEditValue(varAntiRecoilEnd[menuProfile], cycleValueDown, 10, 0);
							}
						} else {
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTime[menuProfile] = cycleEditValue(varAntiRecoilStartTime[menuProfile], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTime[menuProfile] = cycleEditValue(varAntiRecoilMidTime[menuProfile], cycleValueDown, 10, 0);
							}
						}
					} else {
						if(!editMenuSelectedColumn) { // Strength values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartH[menuProfile] = cycleEditValue(varAntiRecoilStartH[menuProfile], cycleValueDown, 10, -100);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidH[menuProfile] = cycleEditValue(varAntiRecoilMidH[menuProfile], cycleValueDown, 10, -100);
							} else if(editMenuSelectedRow == 2) {
								varAntiRecoilEndH[menuProfile] = cycleEditValue(varAntiRecoilEndH[menuProfile], cycleValueDown, 10, -100);
							}
						} else { // Time values
							if(editMenuSelectedRow == 0) {
								varAntiRecoilStartTimeH[menuProfile] = cycleEditValue(varAntiRecoilStartTimeH[menuProfile], cycleValueDown, 10, 0);
							} else if(editMenuSelectedRow == 1) {
								varAntiRecoilMidTimeH[menuProfile] = cycleEditValue(varAntiRecoilMidTimeH[menuProfile], cycleValueDown, 10, 0);
							}
						}
					}
				} else if(editMenuIndex == editMenuAkimbo) { // (Options) Akimbo (Fire Speed)
					varOptionAkimboSpeed[menuProfile] = cycleEditValue(varOptionAkimboSpeed[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuAutoPing) { // (Options) Auto Ping (Ping Interval)
					varOptionAutoPingInterval[menuProfile] = cycleEditValue(varOptionAutoPingInterval[menuProfile], cycleValueDown, 120, 0);
				} else if(editMenuIndex == editMenuDropShot) { // (Options) Drop Shot Aim Adjust
					varOptionDropShotAimAdjust[menuProfile] = cycleEditValue(varOptionDropShotAimAdjust[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuQuickScope) { // (Options) Quick Scope Delay
					varOptionQuickScopeDelay[menuProfile] = cycleEditValue(varOptionQuickScopeDelay[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedRow] = cycleEditValue(varDeadzone[editMenuSelectedRow], cycleValueDown, 10, 0);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAimAssist) { // (Aim Assist)
					varAimAssist[menuProfile] = cycleListOption(varAimAssist[menuProfile], cycleValueDown, assistOff, assistAdsAndFireOrFire);
				} else if(editMenuIndex == editMenuAimAssistBoost) { // (Aim Sssist) Type
					varAimAssistType[menuProfile] = cycleListOption(varAimAssistType[menuProfile], cycleValueDown, aatDecreasing, aatIncreasing);
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape
					if(varAimAssist[menuProfile] == assistAdsOnly) { // Ads only
						varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire setting allows selection of ads/fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
					} else { // Fire only
						varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
					}
				} else if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationType) { // (Aim Assist) Rotation Assist Type
					if(varRotationAssist[menuProfile] == assistAdsOnly) { // Ads only
						varRotationAdsType[menuProfile] = cycleListOption(varRotationAdsType[menuProfile], cycleValueDown, rasStrafe, rasDiamond);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire setting allows selection of ads/fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
					} else { // Fire only
						varRotationFireType[menuProfile] = cycleListOption(varRotationFireType[menuProfile], cycleValueDown, aimAssistShapeMin, aasDiamond);
					}
				} else if(editMenuIndex == editMenuRotationAssist) { // (Aim Assist) Rotation Assist
					varRotationAssist[menuProfile] = cycleListOption(varRotationAssist[menuProfile], cycleValueDown, assistOff, assistAdsAndFireOrFire);
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationSpeed) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuIdleTargetAssist) { // (Aim Assist) Idle Target Assist
					if(varIdleTargetAssist[menuProfile] == assistOff) {
						varIdleTargetAssist[menuProfile] = assistOn;
					} else {
						varIdleTargetAssist[menuProfile] = assistOff;
					}
				} else if(editMenuIndex == editMenuIdleTargetShape) { // (Aim Assist) Idle Target Assist Shape
					varIdleTargetShape[menuProfile] = cycleListOption(varIdleTargetShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
				} else if(editMenuIndex == editMenuAntidrift) { // (Anti-drift)
					varAntidrift = !varAntidrift;
				} else if(editMenuIndex == editMenuAntiRecoil) { // (Anti-recoil)
					varAntiRecoil[menuProfile] = cycleListOption(varAntiRecoil[menuProfile], cycleValueDown, antiRecoilOff, antiRecoilExpert);
				} else if(editMenuIndex == editMenuAntiRecoilExpert) { // (Anti-recoil) Expert
					if(!(editMenuSelectedColumn == 1 && editMenuSelectedRow == 1)) {
						editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 2);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuControllerButtonLayout) { // (Controller) Button Layout
					varControllerButtonLayout = cycleListOption(varControllerButtonLayout, cycleValueDown, cblDefault, cblBumperPingTactical);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperPing) { // (Controller) Bumper Ping Swapped
					varControllerBumperPing = cycleListOption(varControllerBumperPing, cycleValueDown, cbpDefault, cbpSwapped);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperTriggers) { // (Controller) Bumper/Triggers Flipped
					varControllerBumperTriggers = !varControllerBumperTriggers;
					setBumperTriggers(); // Refresh bumper/triggers setting
				} else if(editMenuIndex == editMenuControllerStickLayout) { // (Controller) Stick Layout
					varControllerStickLayout = cycleListOption(varControllerStickLayout, cycleValueDown, slDefault, slLegacySouthpawNoClickSwap);
					setStickLayout(); // Refresh stick layout
				} else if(editMenuIndex == editMenuControllerAdsStickSwap) { // (Controller) ADS Stick Swap
					varControllerAdsStickSwap = !varControllerAdsStickSwap;
					if(!varControllerAdsStickSwap) { // No longer swapped, reset layout
						setStickLayout(); // Refresh stick layout
					}
				} else if(editMenuIndex == editMenuAkimbo) { // (Options) Akimbo
					varOptionAkimbo[menuProfile] = !varOptionAkimbo[menuProfile];
				} else if(editMenuIndex == editMenuAutoADS) { // (Options) Auto ADS/Fire
					varOptionAutoADSFire[menuProfile] = cycleListOption(varOptionAutoADSFire[menuProfile], cycleValueDown, autoADSFireOff, autoADSFireAutoFire);
				} else if(editMenuIndex == editMenuAutoFocus) { // (Options) Auto Focus
					varOptionAutoFocus[menuProfile] = !varOptionAutoFocus[menuProfile];
				} else if(editMenuIndex == editMenuAutoPing) { // (Options) Auto Ping
					varOptionAutoPing[menuProfile] = !varOptionAutoPing[menuProfile];
				} else if(editMenuIndex == editMenuBackpackSwap) { // (Options) Backpack Swap
					varOptionBackpackSwap = !varOptionBackpackSwap;
				} else if(editMenuIndex == editMenuBunnyHop) { // (Options) Bunny Hop
					varOptionBunnyHop = !varOptionBunnyHop;
				} else if(editMenuIndex == editMenuDropShot) { // (Options) Drop Shot
					varOptionDropShot[menuProfile] = !varOptionDropShot[menuProfile];
				} else if(editMenuIndex == editMenuFastMelee) { // (Options) Fast Melee
					varOptionFastMelee[menuProfile] = cycleListOption(varOptionFastMelee[menuProfile], cycleValueDown, fastMeleeOff, fastMeleeToggle);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFire[menuProfile] = !varOptionRapidFire[menuProfile];
				} else if(editMenuIndex == editMenuQuickScope) { // (Options) Quick Scope
					varOptionQuickScope[menuProfile] = !varOptionQuickScope[menuProfile];
				} else if(editMenuIndex == editMenuTacticalSprint) { // (Options) Tactical Sprint
					varOptionTacticalSprint = !varOptionTacticalSprint;
				} else if(editMenuIndex == editMenuProfileSwitch) { // (Profiles) Profile Buttons
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuUniversalSwitch) { // (Profiles) Universal Profile
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 2);
				} else if(editMenuIndex == editMenuBlockRumble) { // (Settings) Block Rumble
					varBlockRumble = !varBlockRumble;
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuInverted) { // (Settings) Inverted
					varInverted = !varInverted;
				} else if(editMenuIndex == editMenuScreenSaver) { // (Setting) Screen saver
					varScreenSaver = cycleListOption(varScreenSaver, cycleValueDown, screenSaverOff, screenSaverVisualizer);
				} else if(editMenuIndex == editMenuVMSpeed) { // (Settings) VM Speed
					varVMSpeed = cycleEditValue(varVMSpeed, cycleValueDown, 1, vmSpeed4);
				} else if(modMenuIndex == modMenuToggles) { // (Toggles)
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				} else {
					menuActionFailed();
				}
			}
			break;
		}
	}
}

// Cycle an edit menu value by step amount with change limited to a threshold
function cycleEditValue(value, direction, step, threshold) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + step) <= threshold) {
			return (value + step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	} else {
		if((value - step) >= threshold) {
			return (value - step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	}
	
	return value;
}

// Cycle a menu value
function cycleListOption(value, direction, threshold, reset_value) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + 1) <= threshold) {
			return value + 1;
		}
	} else {
		if((value - 1) >= threshold) {
			return value - 1;
		}
	}
	
	return reset_value;
}

// Cycle mod menu value
function cycleModMenu(direction) {
	
	displayUpdate = TRUE; // Enable display update
	
	switch(direction) {
		case modMenuEnter {
			displayDepth++; // Advance to Edit Menu
			displayUpdate = TRUE; // Enable display update
			editMenuIndex = editMenuItems[modMenuIndex][editMenuMin]; // Set new edit menu index
			break;
		} case modMenuExit {
			displayDepth--; // Exit to Home Screen
			//displayUpdate = TRUE; // Enable display update
			combo_run(cboSaveSettings); // Save settings upon exiting mod menu
			break;
		} case modMenuDown {
			modMenuIndex++; // Cycle to next menu
			if(modMenuIndex > modMenuMax) { // Check boundaries
				modMenuIndex = modMenuMin; // Out of bounds, set to minimum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		} case modMenuUp {
			modMenuIndex--; // Cycle to previous menu
			if(modMenuIndex < modMenuMin) { // Check boundaries
				modMenuIndex = modMenuMax; // Out of bounds, set to maximum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		}
	}
}

// Determines what to set the anti-drift value to, if a new value was found
function determineAntidriftValue() {
	if(antiDriftCalibrationStick == antiDriftLeftStick) {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue < varAntidriftLeft[antiDriftUp]) || (varAntidriftLeft[antiDriftUp] == 0)) {
					varAntidriftLeft[antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue > varAntidriftLeft[antiDriftDown]) || (varAntidriftLeft[antiDriftDown] == 0)) {
					varAntidriftLeft[antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue < varAntidriftLeft[antiDriftLeft]) || (varAntidriftLeft[antiDriftLeft] == 0)) {
					varAntidriftLeft[antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue > varAntidriftLeft[antiDriftRight]) || (varAntidriftLeft[antiDriftRight] == 0)) {
					varAntidriftLeft[antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	} else {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue < varAntidriftRight[antiDriftUp]) || (varAntidriftRight[antiDriftUp] == 0)) {
					varAntidriftRight[antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue > varAntidriftRight[antiDriftDown]) || (varAntidriftRight[antiDriftDown] == 0)) {
					varAntidriftRight[antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue < varAntidriftRight[antiDriftLeft]) || (varAntidriftRight[antiDriftLeft] == 0)) {
					varAntidriftRight[antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue > varAntidriftRight[antiDriftRight]) || (varAntidriftRight[antiDriftRight] == 0)) {
					varAntidriftRight[antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	}
}

// Handles a pressed toggle combination sequence
function dispatchToggle(id) {
	// Determine which toggle is triggered and handle it accordingly
	switch(id) {
		case toggleProfile {
			if(currentProfile != 2) {
				switchProfile(!currentProfile); // Switch profiles
			}
			break;	
		} case toggleUniversal {
			switchProfile(iif(currentProfile == 2, 0, 2));
			break;
		} case toggleAkimbo {
			varOptionAkimbo[currentProfile] = !varOptionAkimbo[currentProfile];
			combo_restart(cboToggleAkimbo);
			break;
		} case toggleAutoADS {
			varOptionAutoADSFire[currentProfile] = !varOptionAutoADSFire[currentProfile];
			combo_restart(cboToggleAutoADS);
			break;
		} case toggleAutoFocus {
			varOptionAutoFocus[currentProfile] = !varOptionAutoFocus[currentProfile];
			combo_restart(cboToggleAutoFocus); // Update with Auto Focus alert
			break;
		} case toggleAutoPing {
			varOptionAutoPing[currentProfile] = !varOptionAutoPing[currentProfile];
			combo_restart(cboToggleAutoPing); // Update with Auto Ping alert
			break;
		} case toggleBackpackSwap {
			combo_run(cboOptionBackpackSwap);
			break;
		} case toggleDropShot {
			varOptionDropShot[currentProfile] = !varOptionDropShot[currentProfile];
			combo_restart(cboToggleDropShot);
			break;
		} case toggleFastMelee {
			varOptionFastMelee[currentProfile] = cycleListOption(varOptionFastMelee[currentProfile], cycleValueUp, 2, 0);
			combo_restart(cboToggleFastMelee); // Update with Fast Melee alert
			break;
		} case toggleRapidFire {
			varOptionRapidFire[currentProfile] = !varOptionRapidFire[currentProfile];
			combo_restart(cboToggleRapidFire); // Update with Rapid Fire alert
			break;
		} case toggleTacticalSprint {
			varOptionTacticalSprint = !varOptionTacticalSprint;
			combo_restart(cboToggleTacticalSprint);
			break;
		} case toggleQuickScope {
			varOptionQuickScope[currentProfile] = !varOptionQuickScope[currentProfile];
			combo_restart(cboToggleQuickScope);
			break;
		}
	}
}


// Displays stick values for the Anti-drift Test menu
function displayAntidriftTest(x, y, line) {
	// Build display
	insertCharacter(iif(x == POLAR_LX, ASCII_UPPER_L, ASCII_UPPER_R));
	insertCharacter(ASCII_COLON);
	insertCharacter(ASCII_SPACE);
	insertNumber(get_val(x));
	insertCharacter(ASCII_COMMA);
	insertNumber(get_val(y));
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
}

// Displays the current anti-drift X/Y values for both sticks
function displayAntidriftValues() {
	// Draw a separator line down middle of OLED
	line_oled(OLED_WIDTH >> 1, lineNumber[0] - 4, OLED_WIDTH >> 1, OLED_HEIGHT - 2, 1, OLED_WHITE);
	// Draw each value
	for(j = 0; j < 4; j++) {
		// Left stick
		insertString(antiDriftValues[j]);
		insertNumber(varAntidriftLeft[j]);
		flushBuffer(alignLeft - 2, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
		// Right stick
		insertString(antiDriftValues[j]);
		insertNumber(varAntidriftRight[j]);
		flushBuffer((OLED_WIDTH >> 1) + 3, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws the 'Anti-recoil Expoert' selection menu
function displayAntiRecoilSelection() {
	rect_oled(alignLeft - 2, lineNumber[editMenuSelectedRow] - 2, (OLED_WIDTH >> 1) +( OLED_FONT_SMALL_WIDTH * 2) - 4, OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_BLACK, OLED_WHITE));
	rect_oled(OLED_WIDTH - (OLED_WIDTH >> 1) + (OLED_FONT_SMALL_WIDTH * 2) + 2, lineNumber[editMenuSelectedRow] - 2, (OLED_WIDTH >> 1) - 5 - (OLED_FONT_SMALL_WIDTH * 2), OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_WHITE, OLED_BLACK));
	
	// Loop through each anti-recoil variable and display the strength/timer
	for(j = 0; j < 3; j++) {
	
		// Print header
		insertString(iif(editMenuSelectedPage, antiRecoilExpertMenu[j + 3], antiRecoilExpertMenu[j]));
		// Determine which value to display
		if(j == 0 ) {
			insertNumber(iif(editMenuSelectedPage, varAntiRecoilStartH[menuProfile], varAntiRecoilStart[menuProfile]));
		} else if(j == 1) {
			insertNumber(iif(editMenuSelectedPage, varAntiRecoilMidH[menuProfile], varAntiRecoilMid[menuProfile]));
		} else if(j == 2) {
			insertNumber(iif(editMenuSelectedPage, varAntiRecoilEndH[menuProfile], varAntiRecoilEnd[menuProfile]));
		}
		// Flush buffer
		flushBuffer(alignLeft, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
		
		// Print time values
		if(j == 0) {
			insertNumber(iif(editMenuSelectedPage, varAntiRecoilStartTimeH[menuProfile], varAntiRecoilStartTime[menuProfile]) * (10 + vmSpeedValue[varVMSpeed]));
		} else if(j == 1) {
			insertNumber(iif(editMenuSelectedPage, varAntiRecoilMidTimeH[menuProfile], varAntiRecoilMidTime[menuProfile]) * (10 + vmSpeedValue[varVMSpeed]));
		}
				
		// Append "ms" to times
		if(j != 2) {
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
		}
		
		// Flush buffer for time values
		flushBuffer(OLED_WIDTH - (OLED_WIDTH >> 1) + (OLED_FONT_SMALL_WIDTH * 2) + 4, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws a list of two items and highlights the selected item
function displayDualSelection(type, message1, message2, value1, value2) {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Generate first item
	buildSelectedItemBuffer(type, message1, value1);
	flushSelectedItemBuffer(0, lineNumber[0]);
	// Generate second item
	buildSelectedItemBuffer(type, message2, value2);
	flushSelectedItemBuffer(1, lineNumber[1]);
}

// Display edit menu
function displayEditMenu() {
	// Clears the screen and draw a border to prep edit menu display
 	drawBorder();
 	
 	// Alert for success unless IgnoreAlert is enabled
 	if(!antiDriftCalibrationState && (editMenuIndex != editMenuAntidriftTest)) {
  		menuActionSuccess();
	}
	
	// Display edit menu title and draw a line beneath it for formatting
	printText(alignCenter, alignTop, editMenuNames[editMenuIndex], OLED_FONT_SMALL, OLED_WHITE);
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	
	// See if we should draw a line and display profile name
	if(editMenuItems[modMenuIndex][editMenuShowProfile] && editMenuIndex != editMenuAntiRecoilExpert) {
		line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
		if(editMenuIndex != editMenuTacticalSprint && editMenuIndex != editMenuBunnyHop && editMenuIndex != editMenuBackpackSwap) {
			printText(alignCenter, alignBottom, profileName[menuProfile], OLED_FONT_SMALL, OLED_WHITE); // Display profile name
		} else {
			printText(alignCenter, alignBottom, profileName[3], OLED_FONT_SMALL, OLED_WHITE); // Display "All Profiles"
		}
	}
	
	// See what setting we must display
	switch (editMenuIndex) {
		case editMenuAimAssist { // (Aim Assist)
			printText(alignCenter, alignCenter, assistStatus[varAimAssist[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistBoost { // (Aim Assist) Type
			printText(alignCenter, alignCenter, aimAssistTypeName[varAimAssistType[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistRadius { // (Aim Assist) Radius
			if(varAimAssist[menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, varAimAssistAdsRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], varAimAssistAdsRadius[menuProfile], varAimAssistFireRadius[menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, varAimAssistFireRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistShape { // (Aim Assist) Shape
			if(varAimAssist[menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistShapeName[varAimAssistAdsShape[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistShapeName[varAimAssistAdsShape[menuProfile]], aimAssistShapeName[varAimAssistFireShape[menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistShapeName[varAimAssistFireShape[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistSpeed { // (Aim Assist) Speed
			if(varAimAssist[menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, varAimAssistAdsSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], varAimAssistAdsSpeed[menuProfile], varAimAssistFireSpeed[menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, varAimAssistFireSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationAssist { // (Aim Assist) Rotation Assist
			printText(alignCenter, alignCenter, assistStatus[varRotationAssist[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRotationType { // (Aim Assist) Rotation Assist Type
			if(varRotationAssist[menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistRotationType[varRotationAdsType[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistRotationType[varRotationAdsType[menuProfile]], aimAssistRotationType[varRotationFireType[menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistRotationType[varRotationFireType[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuRotationRadius { // (Aim Assist) Rotation Assist Radius
			if(varRotationAssist[menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, varRotationAdsRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], varRotationAdsRadius[menuProfile], varRotationFireRadius[menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, varRotationFireRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationSpeed { // (Aim Assist) Rotation Assist Speed
			if(varRotationAssist[menuProfile] == assistAdsOnly) {
				if(varRotationAdsType[menuProfile] == rasStrafe) {
					insertNumber(varRotationAdsSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
					flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
				} else {
					printNumber(alignCenter, alignCenter, varRotationAdsSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
				}
			} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
				// Build ADS display
				insertString(aimAssistTypeMsg[0]);
				
				if(varRotationAdsType[menuProfile] == rasStrafe) {
					insertNumber(varRotationAdsSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(varRotationAdsSpeed[menuProfile]);
				}
				
				// Determine if first item is selected
				if(editMenuSelectedRow == 0) {
					rect_oled(alignLeft, lineNumber[0] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_WHITE);
				}
				
				// Build fire display
				insertString(aimAssistTypeMsg[1]);
				
				if(varRotationFireType[menuProfile] == rasStrafe) {
					insertNumber(varRotationFireSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(varRotationFireSpeed[menuProfile]);
				}
				
				// Determine if second item is selected
				if(editMenuSelectedRow == 1) {
					rect_oled(alignLeft, lineNumber[1] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
				}
			} else {
				if(varRotationFireType[menuProfile] == rasStrafe) {
					insertNumber(varRotationFireSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(varRotationFireSpeed[menuProfile]);
				}
				flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuIdleTargetAssist { // (Aim Assist) Idle Target Assist
			printText(alignCenter, alignCenter, assistStatus[varIdleTargetAssist[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetTime { // (Aim Assist) Idle Target Assist Time
			insertNumber(varIdleTargetTime[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetRadius {// (Aim Assist) Idle Target Assist Radius
			printNumber(alignCenter, alignCenter, varIdleTargetRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetShape {// (Aim Assist) Idle Target Assist Shape
			printText(alignCenter, alignCenter, aimAssistShapeName[varIdleTargetShape[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetSpeed { // (Aim Assist) Idle Target Assist Speed
			printNumber(alignCenter, alignCenter, varIdleTargetSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntidrift { // (Anti-drift) Toggle On/Off
			printText(alignCenter, alignCenter, toggleOffOn[varAntidrift], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntidriftCalibration { // (Anti-drift) Calibration
			if(antiDriftCalibrationState) {
				// Calibration mode running
				printText(alignCenter, alignCenter, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				// Calibration mode not running
				printText(alignCenter, lineNumber[0], antiDriftCalibrationStickPrompt[antiDriftCalibrationStick], OLED_FONT_SMALL, OLED_WHITE);
				printText(alignCenter, lineNumber[1], antiDriftCalibrationDirectionPrompt[antiDriftCalibrationDirection], OLED_FONT_SMALL, OLED_WHITE);
				rect_oled(alignLeft - 2, lineNumber[2], OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 4, 1, OLED_WHITE);
				printText(alignCenter, lineNumber[2] + 3, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_BLACK);
			}
			break;
		} case editMenuAntidriftTest { // (Anti-drift) Drift Test
			displayAntidriftTest(POLAR_LX, POLAR_LY, lineNumber[0]);
			displayAntidriftTest(POLAR_RX, POLAR_RY, lineNumber[1]);
			break;
		} case editMenuAntidriftValues { // (Anti-drift) Drift Values
			displayAntidriftValues();
			break;
		} case editMenuAntiRecoil { // (Anti-recoil)
			printText(alignCenter, alignCenter, antiRecoilStatus[varAntiRecoil[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntiRecoilStrength { // (Anti-recoil) Strength
			printNumber(alignCenter, alignCenter, varAntiRecoilStrength[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickStrength { // (Anti-recoil) Kick value [advanced]
			printNumber(alignCenter, alignCenter, varAntiRecoilKickStrength[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickCounter { // (Anti-recoil) Kick duration [advanced]
			insertNumber(varAntiRecoilKickCounter[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilExpert { // (Anti-recoil) Expert
			displayAntiRecoilSelection();
			break;
		} case editMenuControllerButtonLayout { // (Controller) Button Layout
			printText(alignCenter, alignCenter, buttonLayoutName[varControllerButtonLayout], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerBumperPing { // (Controller) Bumper Ping Swap
			printText(alignCenter, alignCenter, swappedStatus[varControllerBumperPing], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerBumperTriggers { // (Controller) Bumper Triggers Flipped
			printText(alignCenter, alignCenter, flippedBumperTriggers[varControllerBumperTriggers], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerStickLayout { // (Controller) Stick Layout
			printText(alignCenter, alignCenter, stickLayoutName[varControllerStickLayout], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerAdsStickSwap { // (Controller) ADS Stick Swap
			printText(alignCenter, alignCenter, swappedStatus[varControllerAdsStickSwap], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAkimbo { // (Options) Akimbo)
			// If enabled, display status & values
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionAkimbo[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			if(varOptionAkimboSpeed[menuProfile]) {
				insertString(fireSpeed[0]);
				insertNumber(varOptionAkimboSpeed[menuProfile]);
			} else {
				insertString(akimboAuto[0]);
			}
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoADS { // (Options) Auto ADS/Fire
			printText(alignCenter, alignCenter, autoADSFireType[varOptionAutoADSFire[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoFocus { // (Options) Auto Focus
			printText(alignCenter, alignCenter, toggleOffOn[varOptionAutoFocus[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoPing {
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionAutoPing[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			if(!varOptionAutoPingInterval[menuProfile]) {
				insertString(autoPing[1]);
			} else {
				insertString(autoPing[0]);
				insertNumber(varOptionAutoPingInterval[menuProfile] + 120);
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
			}
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuBackpackSwap { // (Options) Backpack Swap
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionBackpackSwap], OLED_FONT_SMALL, OLED_WHITE);
			printText(alignCenter, lineNumber[1], backpackSwap[varOptionBackpackSwapType], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuBunnyHop {
			printText(alignCenter, alignCenter, toggleOffOn[varOptionBunnyHop], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDropShot { // (Options) Drop Shot
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionDropShot[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(dropShotAimAdjust[0]);
			insertNumber(varOptionDropShotAimAdjust[menuProfile]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuFastMelee { // (Options) Fast Melee
			printText(alignCenter, alignCenter, fastMeleeType[varOptionFastMelee[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRapidFire { // (Options) Rapid Fire
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionRapidFire[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(fireSpeed[0]);
			insertNumber(varOptionRapidFireSpeed[menuProfile]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuTacticalSprint { // (Options) Tactical Sprint
			printText(alignCenter, alignCenter, toggleOffOn[varOptionTacticalSprint], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuQuickScope { // (Options) Quick Scope
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionQuickScope[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(quickScopeDelay[0]);
			insertNumber(varOptionQuickScopeDelay[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuProfileSwitch { // (Profiles) Profile Switch
			displayDualSelection(displayString, profileToggleMsg[0], profileToggleMsg[1], iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[toggleProfile]], controllerButtonsXBOX[varToggleButton[toggleProfile]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[toggleProfile + 1]], controllerButtonsXBOX[varToggleButton[toggleProfile + 1]])); 
			break;
		} case editMenuUniversalSwitch { // (Profiles) Universal Switch
			displayToggle(toggleUniversal);
			break;
		} case editMenuProfileColors { // (Profiles) Profile colors
			displayProfileColorSelection();
			break;
		} case editMenuBlockRumble { // (Settings) Block Rumble
			printText(alignCenter, alignCenter, toggleOffOn[varBlockRumble], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDeadzone { // (Settings) Deadzone
			displayDualSelection(displayNumber, stickName[deadzoneLeft], stickName[deadzoneRight], varDeadzone[deadzoneLeft], varDeadzone[deadzoneRight]);
			break;
		} case editMenuInverted { // (Settings) Inverted
			printText(alignCenter, alignCenter, toggleOffOn[varInverted], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuScreenSaver { // (Settings) Screen saver
			printText(alignCenter, alignCenter, screenSaver[varScreenSaver], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuVMSpeed { // (Settings) VM speed
			printText(alignCenter, alignCenter, vmSpeed[varVMSpeed], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuToggleAkimbo { // (Toggles) Akimbo
			displayToggle(toggleAkimbo);
			break;
		} case editMenuToggleAutoADS { // (Toggles) Auto ADS/Fire
			displayToggle(toggleAutoADS);
			break;
		} case editMenuToggleAutoFocus { // (Toggles) Auto Focus
			displayToggle(toggleAutoFocus);
			break;
		} case editMenuToggleAutoPing { // (Toggles) Auto Ping
			displayToggle(toggleAutoPing);
			break;
		} case editMenuToggleBackpackSwap { // (Toggles) Backpack Swap
			displayToggle(toggleBackpackSwap);
			break;
		} case editMenuToggleDropShot { // (Toggles) Drop Shot
			displayToggle(toggleDropShot);
			break;
		} case editMenuToggleFastMelee { // (Toggles) Fast Melee
			displayToggle(toggleFastMelee);
			break;
		} case editMenuToggleRapidFire { // (Toggles) Rapid Fire
			displayToggle(toggleRapidFire);
			break;
		} case editMenuToggleTacticalSprint { // (Toggles) Tactical Sprint
			displayToggle(toggleTacticalSprint);
			break;
		} case editMenuToggleQuickScope { // (Toggles) Quick Scope
			displayToggle(toggleQuickScope);
			break;
		}
	}
	
	// Disable display update
	displayUpdate = FALSE;
 }

// Display home screen
function displayHomeScreen() {

 	drawBorder(); // Clears the screen and draws a border
 	
	// Show home screen
	printText(alignCenter, 10, homeScreenMessages[homeScriptName], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 26, homeScreenMessages[homeScriptVersion], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 42, homeScreenMessages[homeScriptAuthor], OLED_FONT_SMALL, OLED_WHITE);
 }
 
 // Display mod menu
 function displayModMenu() {
 	
 	drawBorder(); // Clears the screen and draws a border
  	menuActionSuccess(); // Alert for successful action
	
 	// Display the mod menu
	printText(alignCenter, alignTop, modMenuNames[modMenuItems[modMenuIndex][modMenuPrevious]], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, alignCenter, modMenuNames[modMenuItems[modMenuIndex][modMenuCurrent]], OLED_FONT_MEDIUM, OLED_WHITE);
	printText(alignCenter, alignBottom, modMenuNames[modMenuItems[modMenuIndex][modMenuNext]], OLED_FONT_SMALL, OLED_WHITE);
	
 	// Disable update
 	displayUpdate = FALSE;
 }

// Draws the 'Profile Colors' selection menu
function displayProfileColorSelection() {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] + 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Loop through each profile and display the name/color respectively
	for(i = 0; i < 3; i++) {
		insertString(profileToggleMsg[4 + i]);
		insertString(colorName[varProfileColor[i]]);
		flushBuffer(alignLeft, lineNumber[i] + 2, OLED_FONT_SMALL, iif(editMenuSelectedRow == i, OLED_BLACK, OLED_WHITE));
	}
}

// Display screen saver
function displayScreenSaver() {
	// TODO: is this really necessary will there ever be more screensavers?
	switch(varScreenSaver) {	
		case screenSaverUptime {
			cls_oled(OLED_BLACK); // Clear screen
			printUptime();
			break;
		}
	}
}

// Displays 'Button 1 & 2' messages and the proper controller buttons when editing toggles
function displayToggle(id) {
	displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[id]], controllerButtonsXBOX[varToggleButton[id]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[id + 1]], controllerButtonsXBOX[varToggleButton[id + 1]]));
}

// Clears the screen and draws a border around the OLED
function drawBorder() {
	cls_oled(OLED_BLACK); // Clear screen
	rect_oled(0, 0, 128, 63, 0, OLED_WHITE); // Draw border around OLED
}

// Executes main Aim Assist, Idle Target assist, and radius adjustment
function executeAimAssist() {
	// If not firing (ADS only)
	if(!holdingFire) {
		checkShapeChange(varAimAssistAdsShape[currentProfile]); // Check if shape has changed
		// Retreive ADS values
		aimAssistShape = varAimAssistAdsShape[currentProfile];
		aimAssistRadius = varAimAssistAdsRadius[currentProfile];
		aimAssistSpeed = varAimAssistAdsSpeed[currentProfile];
	} else {
		// If IdleTarget engaged, no need to check for a shape change
		if(!idleTargetEngaged) {
			checkShapeChange(varAimAssistFireShape[currentProfile]); // Check if shape has changed
		}
		// Retreive Fire values
		aimAssistShape = varAimAssistFireShape[currentProfile];
		aimAssistRadius = varAimAssistFireRadius[currentProfile];
		aimAssistSpeed = varAimAssistFireSpeed[currentProfile];
		// Determine Idle Target Assist and any radius/speed adjustments
		getPolarStickValues(); // Get stick values
		executeIdleTargetAssist(); // Execute Idle Target Assist
		executeAimAssistRadiusAdjustment(); // Execute aim assist radius adjustment (aim assist type)
	}
	
	// Determine which shape to draw
	switch(aimAssistShape) {
		case aasCircle {
			// Calculate the coordinates using the mathematical equations for a circle
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;		
		} case aasOval {
			// Calculate the coordinates using the mathematical equations for a oval
			aimAssistX = (aimAssistRadius >> 1) * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;
		} case aasEllipse {
			// Calculate the coordinates using the mathematical equations for an ellipse
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = (aimAssistRadius >> 1) * sin[aimAssistAngle];
			break;
		} case aasLemniscate {
			// Calculate the coordinates using the mathematical equations for a lemniscate
			aimAssistX = aimAssistRadius * lemniscateX[aimAssistAngle];
			aimAssistY = aimAssistRadius * lemniscateY[aimAssistAngle];
			break;
		} case aasRose {
			// Calculate the coordinates using the mathematical equations for a Rose (5 pedal Rose Curve)
			aimAssistX = aimAssistRadius * roseX[aimAssistAngle];
			aimAssistY = aimAssistRadius * roseY[aimAssistAngle];
			break;
		} case aasFlower {
			// Calculate the coordinates using the mathematical equations for a flower shape
			aimAssistX = aimAssistRadius * flowerX[aimAssistAngle];
			aimAssistY = aimAssistRadius * flowerY[aimAssistAngle];
			break;
		} case aasDiamond {
			// Calculate the coordinates for a diamond shape
			aimAssistX = aimAssistRadius * diamondX[aimAssistAngle];
			aimAssistY = aimAssistRadius * diamondY[aimAssistAngle];
			break;
		} case aasOrbit {
			// Calculate the coordinates for a "Orbit" shape
			aimAssistX = aimAssistRadius * orbitX[aimAssistAngle];
			aimAssistY = aimAssistRadius * orbitY[aimAssistAngle];
			break;
		} case aasSpiral {
			// Calculate the coordinates using the mathematical equations for an Archimedes' spiral
			// x = a * t * cos(t)
			// y = a * t * sin(t)
			aimAssistX = (aimAssistRadius * aimAssistAngle * cos[aimAssistAngle]) / 328;
			aimAssistY = (aimAssistRadius * aimAssistAngle * sin[aimAssistAngle]) / 328;
			break;
		}
	}
	
	// Step to next angle
	aimAssistAngle += aimAssistSpeed;
	
	// Check if angle must be corrected
	if(aimAssistAngle >= 360) {
		aimAssistAngle -= 360;
		clearVisualizer(); // See if screen saver needs to be cleared
	}
	
	// Determine how values should be output to stick
	if(holdingADS && !holdingFire) {
		// If only aiming and not firing, gradually reduce output as it approaches 100
		output(stick[aimX], aimAssistX);
		output(stick[aimY], aimAssistY);
	} else {
		// Otherwise, output values as they are
		set_val(stick[aimX], clamp(get_val(stick[aimX]) + aimAssistX, -32768, 32767));
		set_val(stick[aimY], clamp(get_val(stick[aimY]) + aimAssistY, -32768, 32767));
	}
	
	// Check for visualizer screen saver
	if(screenSaverEnabled && (varScreenSaver == screenSaverVisualizer)) {
		// Draw aim assist shape to OLED
		pixel_oled(64 + (((aimAssistX / aimAssistRadius) * 30) / 327), 32 + (((aimAssistY / aimAssistRadius) * 30) / 327), OLED_WHITE);
	}
}

// Adjusts the radius based on % of stick movement
// - adjustment ranges from -10 (reducing) to +10 (expanding)
function executeAimAssistRadiusAdjustment() {
	// Check for adjustment type
	if(varAimAssistType[currentProfile] != aatSteady) {
		// Check for aim assist radius boost
		switch(varAimAssistType[currentProfile]) {
			case aatDecreasing { // Reducing
				// Decrements radius per 10% of aim stick move, limited to 50% of radius value
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				break;	
			} case aatIncreasing { // Expanding
				// Increment radius per 10% aim stick move
				aimAssistRadius += polarValue;
				break;
			}
		}
	}
}

// Executes anti-recoil
function executeAntiRecoil() {
	// Get rumble value
	antiRecoilRumble = min(get_rumble(RUMBLE_A), get_rumble(RUMBLE_B));
	
	// See which type of anti-recoil is being used
	switch(varAntiRecoil[currentProfile]) {
		case antiRecoilBasic {
			antiRecoilY = varAntiRecoilStrength[currentProfile]; // Get polar value
			break;
		} case antiRecoilAdvanced {
			if(antiRecoilRumble) { // TODO: re-evaluate if we should wait for signal to begin kick compensation
				antiRecoilY = iif(antiRecoilCounterY <= (varAntiRecoilKickCounter[currentProfile] * (10 + vmSpeedValue[varVMSpeed])), varAntiRecoilKickStrength[currentProfile], varAntiRecoilStrength[currentProfile]);
			} else {
				antiRecoilCounterY = 0; // No longer firing / never fired
				antiRecoilY = varAntiRecoilKickStrength[currentProfile]; // Just apply basic until weapon is aimAssistFiring
			}
			break;
		} case antiRecoilExpert {
			// Check vertical values
			if(!antiRecoilStateY) {
				if(antiRecoilCounterY <= (varAntiRecoilStartTime[currentProfile] * (10 + vmSpeedValue[varVMSpeed]))) {
					antiRecoilY = varAntiRecoilStart[currentProfile]; 
				} else {
					antiRecoilCounterY = 0; // Reset counter
					antiRecoilStateY++; // Advance to next stage
				}
			} else if(antiRecoilStateY == 1) {
				if(antiRecoilCounterY <= (varAntiRecoilMidTime[currentProfile] * (10 + vmSpeedValue[varVMSpeed]))) {
					antiRecoilY = varAntiRecoilMid[currentProfile]; 
				} else {
					antiRecoilCounterY = 0; // Reset counter
					antiRecoilStateY++; // Advance to next stage
					antiRecoilY = varAntiRecoilEnd[currentProfile]; 
				}
			} else {
				antiRecoilY = varAntiRecoilEnd[currentProfile]; 
			}
			
			// Check horizontal values
			if(!antiRecoilStateX) {
				if(antiRecoilCounterX <= (varAntiRecoilStartTimeH[currentProfile] * (10 + vmSpeedValue[varVMSpeed]))) {
					antiRecoilX = iif(varAntiRecoilStartH[currentProfile] >= 0, polarValues[varAntiRecoilStartH[currentProfile]], inv(polarValues[abs(varAntiRecoilStartH[currentProfile])])); 
				} else {
					antiRecoilCounterX = 0; // Reset counter
					antiRecoilStateX++; // Advance to next stage
				}
			} else if(antiRecoilStateX == 1) {
				if(antiRecoilCounterX <= (varAntiRecoilMidTimeH[currentProfile] * (10 + vmSpeedValue[varVMSpeed]))) {
					antiRecoilX = iif(varAntiRecoilMidH[currentProfile] >= 0, polarValues[varAntiRecoilMidH[currentProfile]], inv(polarValues[abs(varAntiRecoilMidH[currentProfile])]));
				} else {
					antiRecoilCounterX = 0; // Reset counter
					antiRecoilStateX++; // Advance to next stage
				}
			} else {
				antiRecoilX = iif(varAntiRecoilEndH[currentProfile] >= 0, polarValues[varAntiRecoilEndH[currentProfile]], inv(polarValues[abs(varAntiRecoilEndH[currentProfile])]));
			}
			
			// Increase horizontal duration counter
			antiRecoilCounterX += get_rtime(); 
			// Output horizontal value
			output(stick[aimX], antiRecoilX);
			break;
		}
	}
	
	// Increase vertical duration counter
	antiRecoilCounterY += get_rtime();
	// Output vertical value
	output(stick[aimY], polarValues[(antiRecoilY + antiRecoilRumble)] * iif(varInverted, -1, 1));
}

// Executes idle target assist
// - if stick movement is less than 10.24% and timer met,
// 	 set new aim assist values until the stick is moved
function executeIdleTargetAssist() {
	// Check if idle target assist is enabled
	if(varIdleTargetAssist[currentProfile] == assistOn) {
		if(polarValue < 1) { // If stick is not moving
			if(idleTargetTimer >= (varIdleTargetTime[currentProfile] * (10 + vmSpeedValue[varVMSpeed]))) { // See if we have met the timer
				// If this is first time Idle Target Assist is engaged, reset the angle
				if(!idleTargetEngaged) {
					aimAssistAngle = 0; // Reset angle for new shape
				}
				aimAssistShape = varIdleTargetShape[currentProfile]; // Set aim assist shape to idle target shape
				aimAssistRadius = varIdleTargetRadius[currentProfile]; // Set aim assist radius to idle target radius
				aimAssistSpeed = varIdleTargetSpeed[currentProfile]; // Set aim assist speed to idle target speed
				idleTargetEngaged = TRUE;
			} else {
				idleTargetTimer += get_rtime(); // Add time elapsed to counter
				idleTargetEngaged = FALSE;
			}
		} else { // Stick has moved
			idleTargetTimer = 0; // Reset idle target timer if there is movement
			if(idleTargetEngaged) { // If idle target assist was engaged, reset aim assist
				aimAssistAngle = 0;
				idleTargetEngaged = FALSE;
			}
		}
	}
}

// Executes the rotational aim assist (left stick "strafe" or shape)
function executeRotationAssist() {
	
	// Get rotational shape
	rotationType  = iif(holdingFire, varRotationFireType[currentProfile], varRotationAdsType[currentProfile]);
	
	if(rotationType == rasStrafe) {
		rotationRadius = iif(holdingFire, polarValues[varRotationFireRadius[currentProfile]], polarValues[varRotationAdsRadius[currentProfile]]);
		rotationSpeed = iif(holdingFire, varRotationFireSpeed[currentProfile], varRotationAdsSpeed[currentProfile]) * (10 + vmSpeedValue[varVMSpeed]);
		
		// If counter is greater or equal to delay...change direction
		if(rotationCounter == rotationSpeed) {
			rotationCounter = 0; // Set counter to any remainder
			rotationDirection = !rotationDirection; // Change direction
		} else {
			rotationCounter += get_rtime(); // Add # milliseconds since last loop
		}
		
		// Determine which direction to move stick
		output(stick[moveX], iif(rotationDirection, inv(rotationRadius), rotationRadius));
	} else { 
		rotationRadius = iif(holdingFire, varRotationFireRadius[currentProfile], varRotationAdsRadius[currentProfile]);
		rotationSpeed = iif(holdingFire, varRotationFireSpeed[currentProfile], varRotationAdsSpeed[currentProfile]);
	
		// Determine which shape to draw
		switch(rotationType) {
			case rasCircle {
				// Calculate the coordinates using the mathematical equations for a circle
				aimAssistX = rotationRadius * cos[rotationAngle];
				aimAssistY = rotationRadius * sin[rotationAngle];
				break;		
			} case rasOval {
				// Calculate the coordinates using the mathematical equations for a oval
				aimAssistX = (rotationRadius >> 1) * cos[rotationAngle];
				aimAssistY = rotationRadius * sin[rotationAngle];
				break;
			} case rasEllipse {
				// Calculate the coordinates using the mathematical equations for an ellipse
				aimAssistX = rotationRadius * cos[rotationAngle];
				aimAssistY = (rotationRadius >> 1) * sin[rotationAngle];
				break;
			} case rasLemniscate {
				// Calculate the coordinates using the mathematical equations for a lemniscate
				aimAssistX = rotationRadius * lemniscateX[rotationAngle];
				aimAssistY = rotationRadius * lemniscateY[rotationAngle];
				break;
			} case rasRose {
				// Calculate the coordinates using the mathematical equations for a Rose (5 pedal Rose Curve)
				aimAssistX = rotationRadius * roseX[rotationAngle];
				aimAssistY = rotationRadius * roseY[rotationAngle];
				break;
			}case rasDiamond {
				// Calculate the coordinates for a diamond shape
				aimAssistX = rotationRadius * diamondX[rotationAngle];
				aimAssistY = rotationRadius * diamondY[rotationAngle];
				break;
			}
		}
		
		// Step to next angle
		rotationAngle += rotationSpeed;
		
		// Check if angle must be corrected
		if(rotationAngle >= 360) {
			rotationAngle -= 360;
		}
		
		output(stick[moveX], aimAssistX);
		output(stick[moveY], aimAssistY);
	}
}

// Flushes the display buffer
function flushBuffer(x, y, size, color) {
	// Decrement display buffer value for proper arithmetic
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4; // Additional 4 for padding from border
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
		// No alignLeft case is needed because alignLeft is set to the proper left alignment already
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4; // Additional 4 for padding from border
			break;	
		}
		// No alignTop case is needed because alignTop is set to the proper top alignment already
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}

// Flushes the display buffer for a multiple item menu
function flushSelectedItemBuffer(item, line) {
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, iif(editMenuSelectedRow == item, OLED_BLACK, OLED_WHITE));
}

// Format and append the display buffer for displaying the script uptime
function generateUptime(value, character) {
	insertNumber(value);
	insertCharacter(character);
}

// Get stick polar radius based on the aiming stick that is used
// Basically gets "the stick to use" for calculating difference/addition
// for Aim Assist Type setting (increasing/decreasing)
function getPolarStickValues() {
	// Determine which stick radius to use for calculating aim assist radius boost/idle target assist
	switch(varControllerStickLayout) {
		case slDefault {
			polarStick = POLAR_RS;
			break;
		} case slSouthpaw {
			polarStick = POLAR_LS;
			break;
		} case slSouthpawNoClickSwap {
			polarStick = POLAR_LS;
			break;
		} case slLegacy {
			if(abs(get_val(POLAR_RY)) > abs(get_val(POLAR_LX))) {
				polarStick = POLAR_RS;
			} else {
				polarStick = POLAR_LS;	
			}
			break;
		} case slLegacySouthpaw {
			if(abs(get_val(POLAR_LY)) > abs(get_val(POLAR_RX))) {
				polarStick = POLAR_LS;
			} else {
				polarStick = POLAR_RS;	
			}
			break;
		} case slLegacySouthpawNoClickSwap {
			if(abs(get_val(POLAR_LY)) > abs(get_val(POLAR_RX))) {
				polarStick = POLAR_LS;
			} else {
				polarStick = POLAR_RS;	
			}
			break;
		}
	}
	
	// Set value to % the stick is moved (sets of 10)
	polarValue = get_polar(polarStick, POLAR_RADIUS) >> 10;
}

// Alternative for the ternary operator
function iif(expression, truepart, falsepart) {
	// Evaluate if expression is true
	if(expression) {
		return truepart; // Return truepart
	}
	
	// Else, return falsepart
	return falsepart;
}

// Inserts a character into the display buffer
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

// Inserts a number into the display buffer
function insertNumber(int value) {
	// Check if value is negative
	if(value < 0) {
		insertCharacter(ASCII_MINUS); // Insert '-' into the display buffer
		value = abs(value); // Convert value to positive
	}
	
	displayBufferInsertCopyValue = value; // Create a copy of value to perform work on
	displayBufferInsertNumberOfDigits = 0; // Reset number of digits to 0
	
    // Determine the number of digits in the number by
    // dividing it by 10 repeatedly until it becomes 0
    // while not ignoring a value of 0
    do {
        displayBufferInsertCopyValue /= 10;
        displayBufferInsertNumberOfDigits++;
    } while(displayBufferInsertCopyValue)
    
    // Extract each digit of the number and store it in an array
    for(i = 0; i < displayBufferInsertNumberOfDigits; i++) {
        displayBufferInsertDigits[i] = (value % 10) + 48;
        value /= 10;
    }
    
    // Insert the digits in the order that they appear in the number
    for(i = displayBufferInsertNumberOfDigits - 1; i >= 0; i--) {
        insertCharacter(displayBufferInsertDigits[i]);
    }
}

// Inserts a string into the display buffer
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(dint8(s)); // Insert character into display buffer
    	s++; // Move to next character of the string
    } while(dint8(s)) // Check if a next character exists
}

// Menu action allowed
function menuActionSuccess() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionSuccess)) { 
		combo_stop(cboActionSuccess);
	}
	
	combo_run(cboActionSuccess); // Execute alert
}

// Edit menu action not allowed
function menuActionFailed() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionFailed)) { 
		combo_stop(cboActionFailed);
	}
	
	displayUpdate = FALSE;
	combo_run(cboActionFailed); // Execute alert
}

// Output value to stick and gradually reduce it as it approaches maximum movement
function output(stick, value) {
	if(value) {
		set_val(stick, clamp(value * (32767 - abs(get_val(stick))) / 32767 + get_val(stick), -32768, 32767));
	} else {
		set_val(stick, clamp(value * (-32768 + abs(get_val(stick))) / -32768 + get_val(stick), -32768, 32767));
	}
}

// Prints a number to the screen
function printNumber(x, y, number, size, color) {
	insertNumber(number);
	flushBuffer(x, y, size, color);
}

 // Prints text to the screen
 function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}

// Print the uptime to the OLED display
function printUptime() {
	// Check days
	if(uptimeDays) {
		generateUptime(uptimeDays, ASCII_LOWER_D);
	}
	// Check hours
	if(uptimeHours) {
		generateUptime(uptimeHours, ASCII_LOWER_H);
	}
	// Check minutes
	if(uptimeMinutes) {
		generateUptime(uptimeMinutes, ASCII_LOWER_M);
	}
	// Check seconds
	if(uptimeSeconds) {
		generateUptime(uptimeSeconds, ASCII_LOWER_S);
	}
	
	// Print centered to OLED the script uptime
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE); 
}

// Removes any "movement" inside calibrated drift area and applies a deadzone
function removeDriftAndApplyDeadzone() {
	// If anti-drift is not enabled, we use 0 for low/high values.  Deadzone doesn't matter
	if(varAntidrift) {
		correctStickInput(varAntidriftLeft[antiDriftLeft], varAntidriftLeft[antiDriftRight], varDeadzone[deadzoneLeft], stick[moveX]);
		correctStickInput(varAntidriftLeft[antiDriftUp], varAntidriftLeft[antiDriftDown], varDeadzone[deadzoneLeft], stick[moveY]);
		correctStickInput(varAntidriftRight[antiDriftLeft], varAntidriftRight[antiDriftRight], varDeadzone[deadzoneRight], stick[aimX]);
		correctStickInput(varAntidriftRight[antiDriftUp], varAntidriftRight[antiDriftDown], varDeadzone[deadzoneRight], stick[aimY]);
	} else {
		// This is done because it's possible user has values saved
		// but for whatever reason wants anti-drift off
		// Deadzone doesn't matter, if user doesn't want to use script deadzone
		// they can leave it at 0
		correctStickInput(0, 0, varDeadzone[deadzoneLeft], stick[moveX]);
		correctStickInput(0, 0, varDeadzone[deadzoneLeft], stick[moveY]);
		correctStickInput(0, 0, varDeadzone[deadzoneRight], stick[aimX]);
		correctStickInput(0, 0, varDeadzone[deadzoneRight], stick[aimY]);
	}
}

// Resets aim assist-related values
function resetAimAssist() {
	aimAssistAngle = 0; // Reset aim assist shape angle
	idleTargetTimer = 0; // Reset idle target timer
	clearVisualizer(); // Check if Visualizer is running and if so, clear the screen since Aim Assist is disengaged
}

// Swaps tactical button with ping button
function setBumperPing() {
	// Only swap Tactical and Ping if enabled
	if(varControllerBumperPing == cbpSwapped) {
		button[tactical] = button[tactical] ^ button[ping];
		button[ping] = button[ping] ^ button[tactical];
		button[tactical] = button[tactical] ^ button[ping];
	}
}

// Swaps the bumpers and triggers based on the Button Layout used
function setBumperTriggers() {
	if(varControllerBumperTriggers) {
		switch(varControllerButtonLayout) {
			case cblDefault {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblTactical {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblLefty {
				button[lethal] = XB1_LT;
				button[fire] = XB1_LB;
				button[tactical] = XB1_RT;
				button[ads] = XB1_RB;
				break;
			} case cblNomadCharlie {
				button[tactical] = XB1_LT;
				button[lethal] = XB1_LB;
				button[ads] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblNomadCharlieTactical {
				button[tactical] = XB1_LT;
				button[lethal] = XB1_LB;
				button[ads] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblNomadCharlieLefty {
				button[ads] = XB1_LT;
				button[fire] = XB1_LB;
				button[tactical] = XB1_RT;
				button[lethal] = XB1_RB;
				break;
			} case cblBumperJumper {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperJumperTactical {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblOneHandGunslinger {
				button[fire] = XB1_LT;
				button[ads] = XB1_LB;
				button[tactical] = XB1_RT;
				button[lethal] = XB1_RB;
				break;
			} case cblStickAndMove {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBrawler {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[melee] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBeast {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[melee] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperPing {
				button[ping] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperPingTactical {
				button[ping] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			}
		}
	}
}

// Sets button variables based on in-game settings
function setButtonLayout() {
	button[ads] = buttonLayoutMap[varControllerButtonLayout][ads];
	button[tactical] = buttonLayoutMap[varControllerButtonLayout][tactical];
	button[ping] = buttonLayoutMap[varControllerButtonLayout][ping];
	button[focus] = buttonLayoutMap[varControllerButtonLayout][focus];
	button[fire] = buttonLayoutMap[varControllerButtonLayout][fire];
	button[lethal] = buttonLayoutMap[varControllerButtonLayout][lethal];
	button[weapon] = buttonLayoutMap[varControllerButtonLayout][weapon];
	button[action] = buttonLayoutMap[varControllerButtonLayout][action];
	button[jump] = buttonLayoutMap[varControllerButtonLayout][jump];
	button[melee] = buttonLayoutMap[varControllerButtonLayout][melee];
}

// Set controller configuration
function setControllerConfig() {
	setButtonLayout();
	setBumperTriggers();
	setBumperPing();
	setStickLayout();
}

// Sets the LED to the color provided as the parameter
function setLedColor(color) {
	set_hsb(colorValues[color][hue], colorValues[color][saturation], colorValues[color][brightness]);
}

// Sets the LED to a color based on the profile being used
function setProfileLedColor(profile) {
	if(!checkCombos()) { // Do not overlap with running combos that use the LEDs
		set_hsb(colorValues[varProfileColor[profile]][hue], colorValues[varProfileColor[profile]][saturation], colorValues[varProfileColor[profile]][brightness]);
	}
}

// Sets joystick variables based on in-game settings
function setStickLayout() {
	// Determine movement and aiming sticks
	stick[aimX] = stickLayoutMap[varControllerStickLayout][aimX];
	stick[aimY] = stickLayoutMap[varControllerStickLayout][aimY];
	stick[moveX] = stickLayoutMap[varControllerStickLayout][moveX];
	stick[moveY] = stickLayoutMap[varControllerStickLayout][moveY];
	
	// For Southpaw, Left and Right joystick clicks must be swapped
	if((varControllerStickLayout == slSouthpaw) || (varControllerStickLayout == slLegacySouthpaw)) {
		switch(varControllerButtonLayout) {
			case cblDefault {
				button[melee] = XB1_RS;
				button[focus] = XB1_LS;
				break;
			} case cblTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblLefty {
				button[focus] = XB1_LS;
				button[melee] = XB1_RS;
				break;
			} case cblNomadCharlie {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblNomadCharlieTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblNomadCharlieLefty {
				button[focus] = XB1_LS;
				button[melee] = XB1_RS;
				break;
			} case cblBumperJumper {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperJumperTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblOneHandGunslinger {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblStickAndMove {
				button[jump] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBrawler {
				button[lethal] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBeast {
				button[lethal] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperPing {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperPingTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			}
		}
	}
}

// Attempts to bind button_to_set to a toggle combination
function setToggleButton(button_to_use, button_to_set, button_to_compare) {
	// Holding 'View' button will undo a previously set toggle combination button
	if(button_to_set == XB1_VIEW) {
		// Check if a buttin is set
		if(button_to_use) {
			button_to_use = 0; // Reset value
			displayUpdate = TRUE; // Enable display update
		} else {
			combo_run(cboActionFailed); // Cannot map same buttons
		}
	} else if(button_to_set != button_to_use) { // Check if value to set is different than current stored value for toggle
		if(button_to_set == button_to_compare) { // Make sure toggle combination [hold] button #1 does not equal [press] button #2
			combo_run(cboActionFailed); // Cannot map same buttons
		} else {
			button_to_use = button_to_set; // Set toggle button
		}
	}
	
	return button_to_use;
}

// Switches profiles
function switchProfile(profile) {
	
	currentProfile = profile; // Set current profile
	combo_stop_all(); // Stop any combos that may disrupt the notification
	reset_rumble(); // Stop and reset any rumbles
	
	if(!displayDepth) {
		// Display notification only if not in a menu
		combo_run(cboSwitchProfile);
	}
}

// Verifies that a toggle combination is not already set
function verifyToggleCombo(verify_button, index) {
	// Loop through each set of toggle buttons
	for(j = 0; j < sizeof(varToggleButton) / sizeof(varToggleButton[0]); j += 2) {
		if(varToggleButton[j] && varToggleButton[j + 1]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(varToggleButton[j] == varToggleButton[index] && varToggleButton[j + 1] == varToggleButton[index + 1]) {
					combo_run(cboActionFailed);
					return 0;
				}
			}
		}
	}
	
	// Make sure we are not resetting
	if(verify_button != XB1_VIEW) {
		displayUpdate = TRUE; // Enable display update
		combo_run(cboActionSuccess); // Notify user of success setting toggle button
	}
	
	return verify_button; // Return button
}

/**************************************************************/
// User-defined settings
/**************************************************************/
// Load user-defined configuration settings
function loadSettings() {

	reset_spvar();
	
	// Read and check the first bit, if it is set, we know something should have been saved, otherwise we fall back on our default setting
	if(read_spvar(0, 1, 0)) {
		for(i = 0; i < 3; i++) {
			varAimAssist[i]							= read_spvar(assistOff, assistAdsAndFireOrFire, assistOff);
			varAimAssistType[i]						= read_spvar(aatDecreasing, aatIncreasing, aatDecreasing);
			varAimAssistAdsShape[i]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aasCircle);
			varAimAssistAdsRadius[i]				= read_spvar(1, 100, 10);
			varAimAssistAdsSpeed[i]					= read_spvar(1, 100, 10);
			varAimAssistFireShape[i]				= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aasCircle);
			varAimAssistFireRadius[i]				= read_spvar(1, 100, 10);
			varAimAssistFireSpeed[i]				= read_spvar(1, 100, 10);
			varRotationAssist[i]					= read_spvar(assistOff, assistAdsAndFireOrFire, 0);
			varRotationAdsType[i]					= read_spvar(rasStrafe, rasRose, rasStrafe);
			varRotationFireType[i]					= read_spvar(rasStrafe, rasRose, rasStrafe);
			varRotationAdsRadius[i]					= read_spvar(1, 100, 20);
			varRotationAdsSpeed[i]					= read_spvar(1, 100, 5);
			varRotationFireRadius[i]				= read_spvar(1, 100, 30);
			varRotationFireSpeed[i]					= read_spvar(1, 100, 6);
			varIdleTargetAssist[i]					= read_spvar(assistOff, assistOn, assistOff);
			varIdleTargetTime[i]					= read_spvar(0, 100, 50);
			varIdleTargetShape[i]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aasLemniscate);
			varIdleTargetRadius[i]					= read_spvar(1, 100, 8);
			varIdleTargetSpeed[i]					= read_spvar(1, 100, 26);
			varAntiRecoil[i]						= read_spvar(antiRecoilOff, antiRecoilAdvanced, antiRecoilOff);
			varAntiRecoilStrength[i]				= read_spvar(0, 100, 0);
			varAntiRecoilKickStrength[i]			= read_spvar(0, 100, 0);
			varAntiRecoilKickCounter[i]				= read_spvar(0, 100, 0);
			varAntiRecoilStart[i]					= read_spvar(0, 100, 0);
			varAntiRecoilMid[i]						= read_spvar(0, 100, 0);
			varAntiRecoilEnd[i]						= read_spvar(0, 100, 0);
			varAntiRecoilStartH[i]					= read_spvar(0, 100, 0);
			varAntiRecoilMidH[i]					= read_spvar(0, 100, 0);
			varAntiRecoilEndH[i]					= read_spvar(0, 100, 0);
			varAntiRecoilStartTime[i]				= read_spvar(0, 100, 0);
			varAntiRecoilMidTime[i]					= read_spvar(0, 100, 0);
			varAntiRecoilStartTimeH[i]				= read_spvar(0, 100, 0);
			varAntiRecoilMidTimeH[i]				= read_spvar(0, 100, 0);
			varOptionAkimbo[i]						= read_spvar(0, 1, 0);
			varOptionAkimboSpeed[i]					= read_spvar(0, 60, 0);
			varOptionAutoADSFire[i]					= read_spvar(autoADSFireOff, autoADSFireAutoFire, autoADSFireOff);
			varOptionAutoFocus[i]					= read_spvar(0, 1, 0);
			varOptionAutoPing[i]					= read_spvar(0, 1, 0);
			varOptionAutoPingInterval[i]			= read_spvar(0, 960, 0);
			varOptionDropShot[i]					= read_spvar(0, 1, 0);
			varOptionDropShotAimAdjust[i]			= read_spvar(0, 100, 0);
			varOptionFastMelee[i]					= read_spvar(fastMeleeOff, fastMeleeToggle, fastMeleeOff);
			varOptionRapidFire[i]					= read_spvar(0, 1, 0);
			varOptionRapidFireSpeed[i]				= read_spvar(1, 60, 1);
			varOptionQuickScope[i]					= read_spvar(0, 1, 0);
			varOptionQuickScopeDelay[i]				= read_spvar(1, 100, 1);
		}
		varOptionBackpackSwap					= read_spvar(0, 1, 0);
		varOptionBackpackSwapType				= read_spvar(0, 1, 0);
		varOptionBunnyHop						= read_spvar(0, 1, 0);
		varOptionTacticalSprint					= read_spvar(0, 1, 0);
		varAntidrift							= read_spvar(0, 1, 0);
		varAntidriftLeft[antiDriftUp]			= read_spvar(-32768, 32767, 0);
		varAntidriftLeft[antiDriftDown]			= read_spvar(-32768, 32767, 0);
		varAntidriftLeft[antiDriftLeft]			= read_spvar(-32768, 32767, 0);
		varAntidriftLeft[antiDriftRight]		= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftUp]			= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftDown]		= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftLeft]		= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftRight]		= read_spvar(-32768, 32767, 0);
		varControllerButtonLayout				= read_spvar(cblDefault, cblBumperPingTactical, cblDefault);
		varControllerBumperPing					= read_spvar(cbpDefault, cbpSwapped, cbpDefault);
		varControllerBumperTriggers				= read_spvar(cbtDefault, cbtFlipped, cbtDefault);
		varControllerStickLayout				= read_spvar(slDefault, slLegacySouthpawNoClickSwap, slDefault);
		varControllerAdsStickSwap				= read_spvar(cbpDefault, cbpSwapped, cbpDefault);
		
		for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i++) {
			varToggleButton[i] = read_spvar(0, XB1_X, 0);
		}
		
		varProfileColor[0]						= read_spvar(red, pink, blue);
		varProfileColor[1]						= read_spvar(red, pink, purple);
		varProfileColor[2]						= read_spvar(red, pink, gold);
		varBlockRumble							= read_spvar(0, 1, 0);
		varDeadzone[deadzoneLeft]				= read_spvar(0, 30, 0);
		varDeadzone[deadzoneRight]				= read_spvar(0, 30, 0);
		varInverted								= read_spvar(0, 1, 0);
		varScreenSaver							= read_spvar(screenSaverOff, screenSaverVisualizer, screenSaverUptime);
		varVMSpeed								= read_spvar(vmSpeed4, vmSpeed10, vmSpeed10);
	} else {
		// Set default settings
		for(i = 0; i < 3; i++) {
			varAimAssist[i]						= assistOff;
			varAimAssistType[i]					= aatIncreasing;
			varAimAssistAdsShape[i] 			= aasCircle;
			varAimAssistAdsRadius[i]			= 8;
			varAimAssistAdsSpeed[i]				= 18;
			varAimAssistFireShape[i] 			= aasRose;
			varAimAssistFireRadius[i]			= 10;
			varAimAssistFireSpeed[i]			= 18;
			varRotationAssist[i]				= assistOff;
			varRotationAdsType[i]				= rasCircle;
			varRotationFireType[i]				= rasStrafe;
			varRotationAdsRadius[i]				= 40;
			varRotationAdsSpeed[i]				= 100;
			varRotationFireRadius[i]			= 25;
			varRotationFireSpeed[i]				= 9;
			varIdleTargetAssist[i]				= assistOff;
			varIdleTargetTime[i]				= 50;
			varIdleTargetShape[i]				= aasLemniscate;
			varIdleTargetRadius[i]				= 8;
			varIdleTargetSpeed[i]				= 26;
			varAntiRecoil[i]					= antiRecoilOff;
			varAntiRecoilStrength[i]			= 0;
			varAntiRecoilKickStrength[i]		= 0;
			varAntiRecoilKickCounter[i]			= 10;
			varAntiRecoilStart[i]				= 0;
			varAntiRecoilMid[i]					= 0;
			varAntiRecoilEnd[i]					= 0;
			varAntiRecoilStartH[i]				= 0;
			varAntiRecoilMidH[i]				= 0;
			varAntiRecoilEndH[i]				= 0;
			varAntiRecoilStartTime[i]			= 0;
			varAntiRecoilMidTime[i]				= 0;
			varAntiRecoilStartTimeH[i]			= 0;
			varAntiRecoilMidTimeH[i]			= 0;
			varOptionAkimbo[i]					= 0;
			varOptionAkimboSpeed[i]				= 0;
			varOptionAutoADSFire[i]				= autoADSFireOff;
			varOptionAutoFocus[i]				= 0;
			varOptionAutoPing[i]				= 0;
			varOptionAutoPingInterval[i]		= 0;
			varOptionDropShot[i]				= 0;
			varOptionDropShotAimAdjust[i]		= 0;
			varOptionFastMelee[i]				= fastMeleeOff;
			varOptionRapidFire[i]				= 0;
			varOptionRapidFireSpeed[i]			= 1;
			varOptionQuickScope[i]				= 0;
			varOptionQuickScopeDelay[i]			= 1;
		}
		varOptionBackpackSwap					= 0;
		varOptionBackpackSwapType 				= 0;
		varOptionBunnyHop						= 0;
		varOptionTacticalSprint					= 0;
		varAntidrift							= 0;
		varAntidriftLeft[antiDriftUp]			= 0;
		varAntidriftLeft[antiDriftDown]			= 0;
		varAntidriftLeft[antiDriftLeft]			= 0;
		varAntidriftLeft[antiDriftRight]		= 0;
		varAntidriftRight[antiDriftUp]			= 0;
		varAntidriftRight[antiDriftDown]		= 0;
		varAntidriftRight[antiDriftLeft]		= 0;
		varAntidriftRight[antiDriftRight]		= 0;
		varControllerButtonLayout				= cblDefault;
		varControllerBumperPing					= cbpDefault;
		varControllerBumperTriggers				= cbtDefault;
		varControllerStickLayout				= slDefault;
		varControllerAdsStickSwap				= cbpDefault;
		for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i++) {
			varToggleButton[i] = 0;
		}
		varProfileColor[0]						= blue;
		varProfileColor[1]						= purple;
		varProfileColor[2]						= gold;
		varBlockRumble							= 0;
		varDeadzone[deadzoneLeft] 				= 0;
		varDeadzone[deadzoneRight] 				= 0;
		varInverted								= 0;
		varScreenSaver							= screenSaverBlank;
		varVMSpeed								= vmSpeed10;
	}
	
	setControllerConfig(); // Set controller configuration
}

// Save user-defined configuration settings
function saveSettings() {
	// Always reset the spvar state before saving to ensure that we are saving at the same location as we will later read
	reset_spvar();
	
	// Save a constant 1 to denote previously saved data, this range uses 1 bit
	save_spvar(1, 0, 1);
	for(i = 0; i < 3; i++) {
		save_spvar(varAimAssist[i], assistOff, assistAdsAndFireOrFire);
		save_spvar(varAimAssistType[i], aatDecreasing, aatIncreasing);
		save_spvar(varAimAssistAdsShape[i], aimAssistShapeMin, aimAssistShapeMax);
		save_spvar(varAimAssistAdsRadius[i], 1, 100);
		save_spvar(varAimAssistAdsSpeed[i], 1, 100);
		save_spvar(varAimAssistFireShape[i], aimAssistShapeMin, aimAssistShapeMax);
		save_spvar(varAimAssistFireRadius[i], 1, 100);
		save_spvar(varAimAssistFireSpeed[i], 1, 100);
		save_spvar(varRotationAssist[i], assistOff, assistAdsAndFireOrFire);
		save_spvar(varRotationAdsType[i], rasStrafe, rasDiamond);
		save_spvar(varRotationFireType[i], rasStrafe, rasDiamond);
		save_spvar(varRotationAdsRadius[i], 1, 100);
		save_spvar(varRotationAdsSpeed[i], 1, 100);
		save_spvar(varRotationFireRadius[i], 1, 100);
		save_spvar(varRotationFireSpeed[i], 1, 100);
		save_spvar(varIdleTargetAssist[i], assistOff, assistOn);
		save_spvar(varIdleTargetTime[i], 0, 100);
		save_spvar(varIdleTargetShape[i], aimAssistShapeMin, aimAssistShapeMax);
		save_spvar(varIdleTargetRadius[i], 1, 100);
		save_spvar(varIdleTargetSpeed[i], 1, 100);
		save_spvar(varAntiRecoil[i], antiRecoilOff, antiRecoilAdvanced);
		save_spvar(varAntiRecoilStrength[i], 0, 100);
		save_spvar(varAntiRecoilKickStrength[i], 0, 100);
		save_spvar(varAntiRecoilKickCounter[i], 0, 100);
		save_spvar(varAntiRecoilStart[i], 0, 100);
		save_spvar(varAntiRecoilMid[i], 0, 100);
		save_spvar(varAntiRecoilEnd[i], 0, 100);
		save_spvar(varAntiRecoilStartH[i], 0, 100);
		save_spvar(varAntiRecoilMidH[i], 0, 100);
		save_spvar(varAntiRecoilEndH[i], 0, 100);
		save_spvar(varAntiRecoilStartTime[i], 0, 100);
		save_spvar(varAntiRecoilMidTime[i], 0, 100);
		save_spvar(varAntiRecoilStartTimeH[i], 0, 100);
		save_spvar(varAntiRecoilMidTimeH[i], 0, 100);
		save_spvar(varOptionAkimbo[i], 0, 1);
		save_spvar(varOptionAkimboSpeed[i], 0, 60);
		save_spvar(varOptionAutoADSFire[i], autoADSFireOff, autoADSFireAutoFire);
		save_spvar(varOptionAutoFocus[i], 0, 1);
		save_spvar(varOptionAutoPing[i], 0, 1);
		save_spvar(varOptionAutoPingInterval[i], 0, 960);
		save_spvar(varOptionDropShot[i], 0, 1);
		save_spvar(varOptionDropShotAimAdjust[i], 0, 100);
		save_spvar(varOptionFastMelee[i], fastMeleeOff, fastMeleeToggle);
		save_spvar(varOptionRapidFire[i], 0, 1);
		save_spvar(varOptionRapidFireSpeed[i], 1, 60);
		save_spvar(varOptionQuickScope[i], 0, 1);
		save_spvar(varOptionQuickScopeDelay[i], 1, 100);
	}
	save_spvar(varOptionBackpackSwap, 0, 1);
	save_spvar(varOptionBackpackSwapType, 0, 1);
	save_spvar(varOptionBunnyHop, 0, 1);
	save_spvar(varOptionTacticalSprint, 0, 1);
	save_spvar(varAntidrift, 0, 1);
	save_spvar(varAntidriftLeft[antiDriftUp], -32768, 32767);
	save_spvar(varAntidriftLeft[antiDriftDown], -32768, 32767);
	save_spvar(varAntidriftLeft[antiDriftLeft], -32768, 32767);
	save_spvar(varAntidriftLeft[antiDriftRight], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftUp], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftDown], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftLeft], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftRight], -32768, 32767);
	save_spvar(varControllerButtonLayout, cblDefault, cblBumperPingTactical);
	save_spvar(varControllerBumperPing, cbpDefault, cbpSwapped);
	save_spvar(varControllerBumperTriggers, cbtDefault, cbtFlipped);
	save_spvar(varControllerStickLayout, slDefault, slLegacySouthpawNoClickSwap);
	save_spvar(varControllerAdsStickSwap, cbpDefault, cbpSwapped);
	for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i++) {
		save_spvar(varToggleButton[i], 0, XB1_X);
	}
	save_spvar(varProfileColor[0], red, pink);
	save_spvar(varProfileColor[1], red, pink);
	save_spvar(varProfileColor[2], red, pink);
	save_spvar(varBlockRumble, 0, 1);
	save_spvar(varDeadzone[deadzoneLeft], 0, 30);
	save_spvar(varDeadzone[deadzoneRight], 0, 30);
	save_spvar(varInverted, 0, 1);
	save_spvar(varScreenSaver, screenSaverOff, screenSaverVisualizer);
	save_spvar(varVMSpeed, vmSpeed4, vmSpeed10);
	setControllerConfig();
}

function reset_spvar() {

	 // Change this to say where it's safe to Roset storing data
	spvar_current_slot = SPVAR_1; 
	
	// Should always be 0, unless you're using part of the first SPVAR 
	// in which case you should also change the next line to include the 
	// value you are storing in the bits you are using
	
	spvar_current_bit = 0; 
	spvar_current_value = 0;
}

// Function used to count the number of bits used by the given value
function get_bit_count(val) {
	
	// We need to Roset at 0, we use spvar_tmp here as we need to track
	// the bits during our loop below
	spvar_tmp = 0; 
	
	// Loop while val is anything but 0
	while (val) { 
		// Increment the bit count by 1
		spvar_tmp++; 
		
		// Shift the value down 1 bit, once we have no more bits set this
		// will result in 0, unless the value is negative - in which case
		// this will be endless, we do abs here to make it always
		val = abs(val >> 1);
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(val1, val2) {

	// Get the highest bit count required for either min or max
	spvar_tmp = max(get_bit_count(val1), get_bit_count(val2));
	
	// Check if we need to know if the value is negative or not
	if (is_signed2(val1, val2)) {
		// If we need to track if the saved value is negative, we need 1 bit
		// for that specifically - the others are used to store the actual value
		spvar_tmp++;
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(val1, val2) {
	return (val1 < 0) || (val2 < 0);
}

// Function used to generate a bitmask for the sign bit, this will always be
// the highest bit in the range we're requesting it for, to do that - we need
// to Roset with the lowest bit set and move it up the number of steps there
// is between 1 and the bits we need, this needs to be a maximum of 31 but can
// never be negative
function make_sign(bits) { 
	return 1 << clamp(bits - 1, 0, 31);
}

// Function used to generate a full bitmask (essentially all bits set up to
// and including the number of bits given)
function make_full_mask(bits) {	

	// If we're wanting a bitmask for all bits, we can simply return -1
	// (which is all bits set to 1)
	if (bits == 32) { 
		return -1;
	}
	
	// What we do here is basically take a value with all bits except the highest
	// set and shift them down as many times as we need to get a mask that fits
	// the bit count we're looking for
	return 0x7FFFFFFF >> (31 - bits);
}

// Function used to generate a bitmask for just the bits required for the value
// part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) {
	return make_full_mask(bits - 1);
}

// Function used to pack a value that has potential for being negative in a way
// that we use the least number of bits we really need to represent the value
function pack_i(val, bits) {

	// Check if we have a negative value, if so - handle it accordingly
	if (val < 0) { 
		// Get the positive version of the value and keep the bits that are within
		// range of what we're doing and add the sign bit since we have a negative
		// value and return the result
		return (abs(val) & make_sign_mask(bits)) | make_sign(bits);
	}
	
	// Get the bits that are within our range
	return val & make_sign_mask(bits); 
}

// Function used to unpack (restore) a value that has potential for being negative,
// essentially reversing what pack_i does above
function unpack_i(val, bits) {

	// Check if the stored value is supposed to be negative
	if (val & make_sign(bits)) {
		// Retrieve the stored positive value and subtract it from 0 (resulting in
		// the same value except negative), return the result
		return 0 - (val & make_sign_mask(bits));
	}
	
	// Retrieve the stored positive value and return it
	return val & make_sign_mask(bits);
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) {
	return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0);
}

// Function used to save your value in the SPVARs, this is the function you'll be
// calling when saving a value. You need to provide the value to save aswell as
// the range (minimum and maximum value, this is how we determine how many bits
// to use when saving this value)
function save_spvar(val, min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Make sure the value is within our defined range to begin with
	val = clamp(val, min, max); 
	
	// If either min or max is negative, we need to pack this value as a
	// possibly negative value
	if (is_signed2(min, max)) { 
		// Pack as signed value (possibly negative)
		val = pack_i(val, spvar_bits);
	}
	
	// Pack as unsigned value (always positive), this essentially just makes the
	// resulting value not have any extra bits set - it's safe to use after the
	// signed packing since we're not using any bits outside of the unsigned range anyways
	val = val & make_full_mask(spvar_bits); 
	
	// Check if there is not enough bits remaining to save this value as-is. if
	// there aren't enough bits, we save what we can here and store the remaining
	// bits in the next spvar, if this means we're hitting the end, we can make
	// this smaller by handling the case where we use all bits here aswell
	if (spvar_bits >= 32 - spvar_current_bit) { 
		// Add what we can to the current value where there is bits available to use
		spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
		// Save the current SPVAR before advancing to the next one
		set_pvar(spvar_current_slot, spvar_current_value); 
		// Move to the next slot
		spvar_current_slot++; 
		// Update the required bits according to our needs for the next slot, 
		// if we don't do this here, we'll screw up the saved value by moving
		// it too far out of range
		spvar_bits -= (32 - spvar_current_bit);
		// Move the remaining bits down, discarding the bits we've already saved
		val = val >> (32 - spvar_current_bit); 
		// Reset the current bit counter since we're Roseting with a new SPVAR
		spvar_current_bit = 0; 
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
	// Move up the counter of next available bit to where we are currently saving data at
	spvar_current_bit += spvar_bits; 
	
	if (!spvar_current_bit) {
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Save the SPVAR with the current value, this won't write anything to flash unless
	//the value changed - so we can do this for each variable saved to no risk missing anything
	set_pvar(spvar_current_slot, spvar_current_value); 
}

// Function used to read your value from the SPVARs, this is the function you'll be
// calling when reading a value. You need to provide the range (minimum and maximum
// value, this is how we determine how many bits to use when reading the value) aswell
// as a default value if what we read is out of range
function read_spvar(min, max, def) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Read the current SPVAR value from flash and shift them into position,
	// we'll handle split values next
	spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits);
	
	// Check if we are dealing with a split SPVAR value, essentially if the current
	// position means we're using more than 32 bits in the SPVAR, we need to retrieve
	// the missing bits from the next SPVAR and put them back to our current value,
	// we use the same space saving trick here as in the save function
	if (spvar_bits >= 32 - spvar_current_bit) {
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	
	// Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_bit += spvar_bits;
	// Extract all bits included for this value and discard any other bits
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); 
	
	if (spvar_current_bit >= 32) {
		// Move to the next SPVAR slot
		spvar_current_slot++;
		// Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
		spvar_current_bit -= 32;
	}
	
	// Check if the value can be negative and handle it accordingly
	if (is_signed2(min, max)) { 
		// Restore the signed, possibly negative value
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); 
	}
	
	// Check if the value is below our specified min or above our specified max,
	// if so - return the default value instead
	if (spvar_current_value < min || spvar_current_value > max) { 
		// This can be changed to min instead as a reasonable default with the
		// default parameter being removed if you don't need to have a override
		// value for the default when out of range, that will save a bit of code size
		return def; 
	}
	
	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


/**************************************************************/
// Combos
/**************************************************************/
combo cboActionSuccess {
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 80);
	wait(240);
	reset_rumble();
}

combo cboActionFailed {
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	set_rumble(RUMBLE_A, 80);
	wait(240);
	reset_rumble();
}

combo cboAlertRapidFire {
	setProfileLedColor(currentProfile);
	wait(240);
	set_hsb(0, 0, 0); // Off
	wait(240);
}

combo cboAlertScriptPaused {
	set_rgb(255, 30, 0);
	wait(120);
	set_rgb(0, 0, 0);
	wait(120);
}

combo cboCalibrationComplete {
	// Notify user of status
	cls_oled(OLED_BLACK);
	set_rumble(RUMBLE_B, 100);
	setLedColor(iif(antiDriftCalibrationCanSet == 2, yellow, iif(antiDriftCalibrationCanSet, green, red)));
	printText(alignCenter, alignCenter, antiDriftCalibrationResult[antiDriftCalibrationCanSet], OLED_FONT_SMALL, OLED_WHITE);
	wait(1440);
	reset_rumble();
	// Clear calibration state
	antiDriftCalibrationState = !antiDriftCalibrationState; 
	// Enable display update
	displayUpdate = TRUE; 
	// Reset calibration variables
	antiDriftCalibrationCanSet = FALSE;
	antiDriftCalibrationInRange = FALSE;
}

combo cboClearScreen {
	cls_oled(OLED_BLACK);
}


combo cboOptionAkimbo {
	set_val(button[ads], 0);
	set_val(button[fire], 0);
	wait(120 / varOptionAkimboSpeed[currentProfile]);
	set_val(button[ads], 100);
	set_val(button[fire], 100);
	wait(880 / varOptionAkimboSpeed[currentProfile]);	
}


combo cboOptionAutoFocus {
	wait(120);
	set_val(button[focus], 100);
	wait(3000);
	set_val(button[focus], 0);
	wait(600);
}

combo cboOptionAutoPing {
	call(cboOptionAutoPingOnce);
	set_val(button[ping], 0);
	wait(varOptionAutoPingInterval[currentProfile]);
}

combo cboOptionAutoPingOnce {
	set_val(button[ping], 100);
	wait(120);
}

combo cboOptionBackpackSwap {
	set_val(XB1_DOWN, 100);
	wait(120);
	set_val(XB1_DOWN, 0);
	wait(120);
	set_val(XB1_X, 100);
	wait(120);
}

combo cboOptionBunnyHop {
	wait(120);
	set_val(button[jump], 0);
	wait(480);
}

combo cboOptionDropShot {
	set_val(button[action], 100);
	wait(120);
	set_val(button[action], 100);
	output(stick[aimY], polarValues[varOptionDropShotAimAdjust[currentProfile]] * iif(varInverted, 1, -1));
	wait(240);
	output(stick[aimY], polarValues[varOptionDropShotAimAdjust[currentProfile]] * iif(varInverted, 1, -1));
	wait(480);
}

combo cboOptionFastMelee {
	set_val(button[melee], 100);
	wait(120);
	set_val(button[melee], 0);
	wait(120);
}

combo cboOptionRapidFire {
	// Low value (LCM of possible VM speeds) for immediate fire
	wait(120 / varOptionRapidFireSpeed[currentProfile]);
	set_val(button[fire], 0);
	wait(880 / varOptionRapidFireSpeed[currentProfile]);
}

combo cboOptionTacticalSprint {
	set_val(button[focus], 100);
	wait(120);
	set_val(button[focus], 0);
	wait(120);
	set_val(button[focus], 100);
	wait(960);
}

combo cboOptionQuickScope {
	wait(varOptionQuickScopeDelay[currentProfile] * (10 + vmSpeedValue[varVMSpeed]));
	set_val(button[fire], 100);
	wait(120);
	set_val(button[ads], 0);
}

combo cboSaveSettings {
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, settingsSaved[0], OLED_FONT_SMALL, OLED_WHITE);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 100);
	wait(480);
	reset_rumble();
	// Save settings
	saveSettings();
	// Enable display update
	displayUpdate = TRUE;
}

combo cboSwitchProfile {
	cls_oled(OLED_BLACK);
	insertString(profileName[currentProfile]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(1080);
	cls_oled(OLED_BLACK);
	displayUpdate = TRUE;
}

combo cboToggleScope {
	set_val(button[focus], 0);
	wait(80);
	set_val(button[focus], 100);
	wait(120);
}

combo cboToggleAkimbo {
	if(varOptionAkimbo[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[0]);
	insertString(toggleOffOn[varOptionAkimbo[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoADS {
	if(varOptionAutoADSFire[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[1]);
	insertString(toggleOffOn[varOptionAutoADSFire[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoFocus {
	if(varOptionAutoFocus[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[2]);
	insertString(toggleOffOn[varOptionAutoFocus[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoPing {
	if(varOptionAutoPing[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[3]);
	insertString(toggleOffOn[varOptionAutoPing[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleDropShot {
	if(varOptionDropShot[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[4]);
	insertString(toggleOffOn[varOptionDropShot[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleFastMelee {
	if(varOptionFastMelee[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[5]);
	insertString(fastMeleeType[varOptionFastMelee[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleRapidFire {
	if(varOptionRapidFire[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[6]);
	insertString(toggleOffOn[varOptionRapidFire[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleTacticalSprint {
	if(varOptionTacticalSprint) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[7]);
	insertString(toggleOffOn[varOptionTacticalSprint]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleQuickScope {
	if(varOptionQuickScope[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[8]);
	insertString(toggleOffOn[varOptionQuickScope[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleOff {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleOn {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_B, 75);
	wait(120);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

/**************************************************************/
// Tables
/**************************************************************/
//
// Polar stick values (0 - 100)
const int16 polarValues[] = {
    0,
	328, 655, 983, 1311, 1638, 1966, 2294, 2621, 2949, 3277,
    3604, 3932, 4260, 4587, 4915, 5243, 5570, 5898, 6226, 6553,
    6881, 7209, 7536, 7864, 8192, 8519, 8847, 9175, 9502, 9830,
    10158, 10485, 10813, 11141, 11468, 11796, 12124, 12451, 12779, 13107,
    13434, 13762, 14090, 14417, 14745, 15073, 15400, 15728, 16056, 16384,
    16711, 17039, 17367, 17694, 18022, 18350, 18677, 19005, 19333, 19660,
    19988, 20316, 20643, 20971, 21299, 21626, 21954, 22282, 22609, 22937,
    23265, 23592, 23920, 24248, 24575, 24903, 25231, 25558, 25886, 26214,
    26541, 26869, 27197, 27524, 27852, 28180, 28507, 28835, 29163, 29490,
    29818, 30146, 30473, 30801, 31129, 31456, 31784, 32112, 32439, 32767
}

// sin(x)
const int16 sin[] = { 
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328
}

// cos(x)
const int16 cos[] = { 
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328,
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6
}

const int16 lemniscateX[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -29, -32, -35, -38, -41, -44, -47, -50,
	-53, -56, -60, -63, -66, -69, -73, -76, -79, -83, -86, -90, -94, -97, -101, -105, -109, -112,
	-116, -120, -124, -129, -133, -137, -141, -146, -150, -154, -159, -164, -168, -173, -178, -182, -187, -192,
	-197, -202, -207, -212, -217, -222, -227, -232, -237, -242, -247, -252, -257, -262, -266, -271, -276, -280,
	-284, -289, -293, -297, -300, -304, -307, -310, -313, -316, -318, -320, -322, -324, -325, -326, -327, -328,
	-328, -328, -327, -326, -325, -324, -322, -320, -318, -316, -313, -310, -307, -304, -300, -297, -293, -289,
	-284, -280, -276, -271, -266, -262, -257, -252, -247, -242, -237, -232, -227, -222, -217, -212, -207, -202,
	-197, -192, -187, -182, -178, -173, -168, -164, -159, -154, -150, -146, -141, -137, -133, -129, -124, -120,
	-116, -112, -109, -105, -101, -97, -94, -90, -86, -83, -79, -76, -73, -69, -66, -63, -60, -56,
	-53, -50, -47, -44, -41, -38, -35, -32, -29, -26, -23, -20, -17, -14, -11, -9, -6, -3,
	0, 3, 6, 9, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50,
	53, 56, 60, 63, 66, 69, 73, 76, 79, 83, 86, 90, 94, 97, 101, 105, 109, 112,
	116, 120, 124, 129, 133, 137, 141, 146, 150, 154, 159, 164, 168, 173, 178, 182, 187, 192,
	197, 202, 207, 212, 217, 222, 227, 232, 237, 242, 247, 252, 257, 262, 266, 271, 276, 280,
	284, 289, 293, 297, 300, 304, 307, 310, 313, 316, 318, 320, 322, 324, 325, 326, 327, 328,
	328, 328, 327, 326, 325, 324, 322, 320, 318, 316, 313, 310, 307, 304, 300, 297, 293, 289,
	284, 280, 276, 271, 266, 262, 257, 252, 247, 242, 237, 232, 227, 222, 217, 212, 207, 202,
	197, 192, 187, 182, 178, 173, 168, 164, 159, 154, 150, 146, 141, 137, 133, 129, 124, 120,
	116, 112, 109, 105, 101, 97, 94, 90, 86, 83, 79, 76, 73, 69, 66, 63, 60, 56,
	53, 50, 47, 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int8 lemniscateY[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3,
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int16 roseX[] = {
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29
}

const int16 roseY[] = {
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0,
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0
}

const int16 diamondX[] = {
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328,
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0
}

const int16 diamondY[] = {
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0,
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328
}

const int16 flowerX[] = {
	-1, -19, -39, -60, -82, -105, -128, -150, -172, -192, -211, -228, -244, -256, -267, -275, -281, -285,
	-287, -287, -286, -284, -281, -278, -275, -272, -269, -268, -268, -268, -271, -274, -279, -284, -291, -298,
	-304, -311, -317, -322, -326, -328, -327, -324, -318, -309, -297, -282, -264, -244, -221, -195, -169, -140,
	-112, -83, -54, -27, -2, 21, 42, 59, 73, 82, 88, 89, 87, 80, 70, 56, 39, 20,
	-2, -25, -49, -74, -98, -122, -145, -166, -185, -202, -217, -228, -237, -244, -247, -249, -248, -245,
	-240, -234, -227, -220, -212, -204, -196, -188, -182, -176, -170, -166, -162, -159, -157, -155, -154, -152,
	-150, -148, -146, -143, -139, -134, -128, -122, -114, -106, -97, -87, -77, -67, -57, -47, -38, -29,
	-21, -15, -9, -4, 0, 2, 4, 4, 4, 3, 2, 0, -2, -3, -4, -4, -4, -2,
	0, 4, 9, 15, 21, 29, 38, 47, 57, 67, 77, 87, 97, 106, 114, 122, 128, 134,
	139, 143, 146, 148, 150, 152, 154, 155, 157, 159, 162, 166, 170, 176, 182, 188, 196, 204,
	212, 220, 227, 234, 240, 245, 248, 249, 247, 244, 237, 228, 217, 202, 185, 166, 145, 122,
	98, 74, 49, 25, 2, -20, -39, -56, -70, -80, -87, -89, -88, -82, -73, -59, -42, -21,
	2, 27, 54, 83, 112, 140, 169, 195, 221, 244, 264, 282, 297, 309, 318, 324, 327, 328,
	326, 322, 317, 311, 304, 298, 291, 284, 279, 274, 271, 268, 268, 268, 269, 272, 275, 278,
	281, 284, 286, 287, 287, 285, 281, 275, 267, 256, 244, 228, 211, 192, 172, 150, 128, 105,
	82, 60, 39, 19, 1, -15, -28, -39, -47, -53, -55, -55, -53, -48, -41, -32, -22, -11,
	1, 13, 25, 37, 48, 57, 66, 73, 79, 83, 86, 87, 87, 85, 82, 79, 74, 68,
	63, 57, 50, 44, 38, 32, 26, 20, 15, 10, 5, 0, -5, -10, -15, -20, -26, -32,
	-38, -44, -50, -57, -63, -68, -74, -79, -82, -85, -87, -87, -86, -83, -79, -73, -66, -57,
	-48, -37, -25, -13, -1, 11, 22, 32, 41, 48, 53, 55, 55, 53, 47, 39, 28, 15
}

const int16 flowerY[] = {
	1, 20, 39, 58, 77, 94, 111, 126, 139, 150, 159, 166, 171, 173, 173, 172, 169, 165,
	159, 153, 146, 139, 131, 124, 117, 110, 103, 98, 92, 87, 83, 79, 75, 71, 67, 63,
	59, 55, 50, 45, 40, 34, 29, 23, 17, 11, 5, 0, -5, -9, -12, -14, -15, -15,
	-14, -12, -9, -5, 0, 5, 10, 15, 19, 24, 27, 29, 30, 29, 27, 23, 17, 9,
	-1, -12, -25, -39, -55, -71, -87, -104, -120, -136, -152, -166, -179, -190, -200, -209, -215, -220,
	-224, -226, -227, -227, -227, -226, -225, -224, -224, -225, -226, -228, -232, -236, -242, -248, -256, -263,
	-271, -279, -286, -293, -298, -301, -302, -301, -297, -291, -281, -268, -253, -235, -213, -190, -165, -138,
	-110, -82, -54, -27, -2, 22, 43, 61, 75, 86, 92, 94, 92, 86, 75, 61, 43, 22,
	-2, -27, -54, -82, -110, -138, -165, -190, -213, -235, -253, -268, -281, -291, -297, -301, -302, -301,
	-298, -293, -286, -279, -271, -263, -256, -248, -242, -236, -232, -228, -226, -225, -224, -224, -225, -226,
	-227, -227, -227, -226, -224, -220, -215, -209, -200, -190, -179, -166, -152, -136, -120, -104, -87, -71,
	-55, -39, -25, -12, -1, 9, 17, 23, 27, 29, 30, 29, 27, 24, 19, 15, 10, 5,
	0, -5, -9, -12, -14, -15, -15, -14, -12, -9, -5, 0, 5, 11, 17, 23, 29, 34,
	40, 45, 50, 55, 59, 63, 67, 71, 75, 79, 83, 87, 92, 98, 103, 110, 117, 124,
	131, 139, 146, 153, 159, 165, 169, 172, 173, 173, 171, 166, 159, 150, 139, 126, 111, 94,
	77, 58, 39, 20, 1, -16, -32, -47, -58, -67, -73, -76, -75, -71, -63, -52, -37, -19,
	2, 24, 49, 75, 102, 129, 156, 182, 206, 229, 250, 268, 284, 297, 308, 315, 320, 322,
	322, 321, 317, 313, 308, 302, 297, 292, 288, 285, 283, 282, 283, 285, 288, 292, 297, 302,
	308, 313, 317, 321, 322, 322, 320, 315, 308, 297, 284, 268, 250, 229, 206, 182, 156, 129,
	102, 75, 49, 24, 2, -19, -37, -52, -63, -71, -75, -76, -73, -67, -58, -47, -32, -16
}

const int16 orbitX[] = {
    0, -17, -34, -51, -68, -85, -101, -117, -133, -149, -164, -178, -193, -206, -219, -232, -244, -255,
    -265, -275, -284, -292, -299, -306, -312, -317, -321, -324, -326, -327, -328, -327, -326, -324, -321, -317,
    -312, -306, -299, -292, -284, -275, -265, -255, -244, -232, -219, -206, -193, -178, -164, -149, -133, -117,
    -101, -85, -68, -51, -34, -17, 0, 17, 34, 51, 68, 85, 101, 117, 133, 149, 164, 178,
    193, 206, 219, 232, 244, 255, 265, 275, 284, 292, 299, 306, 312, 317, 321, 324, 326, 327,
    328, 327, 326, 324, 321, 317, 312, 306, 299, 292, 284, 275, 265, 255, 244, 232, 219, 206,
    193, 178, 164, 149, 133, 117, 101, 85, 68, 51, 34, 17, 0, -17, -34, -51, -68, -85,
    -101, -117, -133, -149, -164, -178, -193, -206, -219, -232, -244, -255, -265, -275, -284, -292, -299, -306,
    -312, -317, -321, -324, -326, -327, -328, -327, -326, -324, -321, -317, -312, -306, -299, -292, -284, -275,
    -265, -255, -244, -232, -219, -206, -193, -178, -164, -149, -133, -117, -101, -85, -68, -51, -34, -17,
    0, 17, 34, 51, 68, 85, 101, 117, 133, 149, 164, 178, 193, 206, 219, 232, 244, 255,
    265, 275, 284, 292, 299, 306, 312, 317, 321, 324, 326, 327, 328, 327, 326, 324, 321, 317,
    312, 306, 299, 292, 284, 275, 265, 255, 244, 232, 219, 206, 193, 178, 164, 149, 133, 117,
    101, 85, 68, 51, 34, 17, 0, -17, -34, -51, -68, -85, -101, -117, -133, -149, -164, -178,
    -193, -206, -219, -232, -244, -255, -265, -275, -284, -292, -299, -306, -312, -317, -321, -324, -326, -327,
    -328, -327, -326, -324, -321, -317, -312, -306, -299, -292, -284, -275, -265, -255, -244, -232, -219, -206,
    -193, -178, -164, -149, -133, -117, -101, -85, -68, -51, -34, -17, 0, 17, 34, 51, 68, 85,
    101, 117, 133, 149, 164, 178, 193, 206, 219, 232, 244, 255, 265, 275, 284, 292, 299, 306,
    312, 317, 321, 324, 326, 327, 328, 327, 326, 324, 321, 317, 312, 306, 299, 292, 284, 275,
    265, 255, 244, 232, 219, 206, 193, 178, 164, 149, 133, 117, 101, 85, 68, 51, 34, 17
}

const int16 orbitY[] = {
    0, -11, -23, -34, -46, -57, -68, -79, -90, -101, -112, -123, -133, -144, -154, -164, -174, -183,
    -193, -202, -211, -219, -228, -236, -244, -251, -258, -265, -272, -278, -284, -289, -295, -299, -304, -308,
    -312, -315, -318, -321, -323, -324, -326, -327, -327, -328, -327, -327, -326, -324, -323, -321, -318, -315,
    -312, -308, -304, -299, -295, -289, -284, -278, -272, -265, -258, -251, -244, -236, -228, -219, -211, -202,
    -193, -183, -174, -164, -154, -144, -133, -123, -112, -101, -90, -79, -68, -57, -46, -34, -23, -11,
    0, 11, 23, 34, 46, 57, 68, 79, 90, 101, 112, 123, 133, 144, 154, 164, 174, 183,
    193, 202, 211, 219, 228, 236, 244, 251, 258, 265, 272, 278, 284, 289, 295, 299, 304, 308,
    312, 315, 318, 321, 323, 324, 326, 327, 327, 328, 327, 327, 326, 324, 323, 321, 318, 315,
    312, 308, 304, 299, 295, 289, 284, 278, 272, 265, 258, 251, 244, 236, 228, 219, 211, 202,
    193, 183, 174, 164, 154, 144, 133, 123, 112, 101, 90, 79, 68, 57, 46, 34, 23, 11,
    0, -11, -23, -34, -46, -57, -68, -79, -90, -101, -112, -123, -133, -144, -154, -164, -174, -183,
    -193, -202, -211, -219, -228, -236, -244, -251, -258, -265, -272, -278, -284, -289, -295, -299, -304, -308,
    -312, -315, -318, -321, -323, -324, -326, -327, -327, -328, -327, -327, -326, -324, -323, -321, -318, -315,
    -312, -308, -304, -299, -295, -289, -284, -278, -272, -265, -258, -251, -244, -236, -228, -219, -211, -202,
    -193, -183, -174, -164, -154, -144, -133, -123, -112, -101, -90, -79, -68, -57, -46, -34, -23, -11,
    0, 11, 23, 34, 46, 57, 68, 79, 90, 101, 112, 123, 133, 144, 154, 164, 174, 183,
    193, 202, 211, 219, 228, 236, 244, 251, 258, 265, 272, 278, 284, 289, 295, 299, 304, 308,
    312, 315, 318, 321, 323, 324, 326, 327, 327, 328, 327, 327, 326, 324, 323, 321, 318, 315,
    312, 308, 304, 299, 295, 289, 284, 278, 272, 265, 258, 251, 244, 236, 228, 219, 211, 202,
    193, 183, 174, 164, 154, 144, 133, 123, 112, 101, 90, 79, 68, 57, 46, 34, 23, 11
} 