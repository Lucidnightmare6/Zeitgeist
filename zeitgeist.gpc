/***
*
*
*	Author:		SwedeMafia
*	Script:		Zeitgeist
*	Version:	1.03
*
*
***************************************************************/

/**************************************************************/
//	Variables
/**************************************************************/
// (Aim Assist)
int aimAssistAngle;
int aimAssistShapeMin, aimAssistShapeMax;
int aimAssistX, aimAssistY;
int aimAssistRadius, aimAssistShape, aimAssistSpeed;

// (Aim Assist) Aim Assist Type
int polarRadius, polarStick, polarValue;

// (Aim Assist) Idle Target Assist
int idleTargetEngaged, idleTargetTimer;

// (Aim Assist) Rotation Assist
int rotationCounter, rotationDelay, rotationDirection, rotationRadius;
int rotationAssistX, rotationAssistY;

// (Anti-drift)
int antiDriftStickValue, antiDriftNewValue;
int antiDriftLowValue, antiDriftHighValue;
int antiDriftCompensateValue;
int antiDriftCalibrationLow, antiDriftCalibrationHigh;
int antiDriftCalibrationValue, antiDriftCalibrationRangeValue;
int antiDriftCalibrationState, antiDriftCalibrationInRange, antiDriftCalibrationCanSet;
int antiDriftCalibrationPolarStick, antiDriftCalibrationStick, antiDriftCalibrationDirection;

// (Anti-recoil)
int antiRecoilY;
int antiRecoilKickCounter;
int antiRecoilQuickEdit;

// Assist/option activation flags
int assistFlags;

// (Controller) Button and Stick Layout
int button[10];
int stick[4];

// (Controller) Current ADS & Fire button values
int holdingADS, holdingFire;

// Display buffer
int displayBuffer, displayBufferInsertCopyValue, displayBufferInsertNumberOfDigits;
int displayBufferInsertDigits[5];

// Edit menu variables
int editMenu, editMenuIndex, editMenuSelectedItem, editMenuUpdate;

// Home screen display variables
int homeHide, homeUpdate;

// Loop iterators
int i, j;

// Memory and storage variables
int spvar_current_bit, spvar_current_slot, spvar_current_value, spvar_tmp, spvar_bits;

// Mod menu variables
int modMenu, modMenuIndex, modMenuMin, modMenuMax, modMenuUpdate;

// Profiles
int currentProfile, menuProfile;

// (Screen saver)
int screenSaverEnabled, screenSaverCounter;

// (Screen saver) Script uptime
int uptimeCounter, uptimeDays, uptimeHours, uptimeMinutes, uptimeSeconds;

// Script paused
int scriptPaused;


/**************************************************************/
//	User-defined configuration variables
/**************************************************************/
// (Aim Assist)
int varAimAssist[3];
int varAimAssistType[3];
int varAimAssistAdsShape[3], varAimAssistFireShape[3];
int varAimAssistAdsRadius[3], varAimAssistFireRadius[3];
int varAimAssistAdsSpeed[3], varAimAssistFireSpeed[3];

// (Aim Assist) Idle Target Assist
int varIdleTargetAssist[3];
int varIdleTargetTime[3], varIdleTargetShape[3], varIdleTargetRadius[3], varIdleTargetSpeed[3];

// (Aim Assist) Rotation Assist
int varRotationAssist[3];
int varRotationAdsRadius[3], varRotationFireRadius[3];
int varRotationAdsSpeed[3], varRotationFireSpeed[3];

// (Anti-drift)
int varAntidrift;
int varAntidriftLeft[4], varAntidriftRight[4];

// (Anti-recoil)
int varAntiRecoil[3];
int varAntiRecoilStrength[3];
int varAntiRecoilKickStrength[3], varantiRecoilKickCounter[3];

// (Controller)
int varControllerButtonLayout, varControllerStickLayout, varControllerBumperPing, varControllerBumperTriggers, varControllerAdsStickSwap;

// (Options)
int varOptionAutoFocus[3];
int varOptionFastMelee[3];
int varOptionRapidFire[3], varOptionRapidFireSpeed[3];

// (Profiles)
int varProfileColor[3];

// (Settings)
int varBlockRumble;
int varDeadzone[2];
int varInverted;
int varScreenSaver;
int varVMSpeed;

// (Toggles)
int varToggleButton[10];


/**************************************************************/
//	Enumerations
/**************************************************************/
// (Aim Assist) Aim Assist Type IDs
enum { aimAssistTypeDecreasing, aimAssistTypeSteady, aimAssistTypeIncreasing }

// (Aim Assist) Shape IDs
enum {
	aaShapeCircle, aaShapeOval, aaShapeEllipse, aaShapeLemniscate,
	aaShapeRose, aaShapeFlower, aaShapeOrbit, aaShapeSpiral
}

// (Aim Assist) Aim/Rotation/Idle Target Assist status IDs
enum {
	assistOff,
	assistAdsOnly, assistFireOnly, assistAdsAndFire,
	assistAdsOrFire, assistAdsAndFireOrFire,
	assistOn
}

// (Anti-drift) Calibration direction
enum { antiDriftUp, antiDriftDown, antiDriftLeft, antiDriftRight }
// (Anti-drift) Calibratoin stick
enum { antiDriftLeftStick, antiDriftRightStick }
// (Anti-recoil) Status IDs
enum { antiRecoilOff, antiRecoilBasic, antiRecoilAdvanced }
// (Controller) Bumper/Triggers Flipped IDs
enum { cbtDefault, cbtFlipped }
// (Controller) Bumper Ping Swap IDs
enum { cbpDefault, cbpSwapped }
// (Controller) Button IDs
enum { ads, tactical, ping, focus, fire, lethal, weapon, action, jump, melee }

// (Controller) Button Layout IDs
enum {
	cblDefault, cblTactical, cblLefty,
	cblNomadCharlie, cblNomadCharlieTactical, cblNomadCharlieLefty,
	cblBumperJumper, cblBumperJumperTactical, cblOneHandGunslinger,
	cblStickAndMove, cblBrawler, cblBeast, cblBumperPing,
	cblBumperPingTactical
}

// (Controller) Stick layout IDs
enum { moveY, moveX, aimY, aimX }
// (Controller) Stick layout map IDs
enum { slDefault, slSouthpaw, slLegacy, slLegacySouthpaw, slSouthpawNoClickSwap, slLegacySouthpawNoClickSwap }
// (Display) Formatting IDs
enum { displayString, displayNumber }

// (Display) Text formatting & alignment IDs
enum {
	alignCenter = -2, alignRight, alignLeft = 5,
	alignBottom = -1, alignTop = 5
}

// (Display) Home screen message IDs
enum { homeScriptName, homeScriptVersion, homeScriptAuthor }
// (Display) LED color IDs
enum { red, orange, gold, white, yellow, green, teal, blue, purple, pink }
// (Display) LED (HSB) IDs
enum { hue, saturation, brightness }
// (Menu) Cycle value IDs
enum { cycleValueUp, cycleValueDown }

// (Menu) Edit menu navigation & event IDs
enum {
	editMenuMin, editMenuMax, editMenuShowProfile,
	editMenuLeft, editMenuRight, editMenuUp, editMenuDown,
	editMenuExit,
	editMenuEnter, editMenuAction, editMenuBumperL, editMenuBumperR
}

// (Menu) Mod navigation
enum {
	modMenuPrevious, modMenuCurrent, modMenuNext,
	modMenuDown, modMenuUp,
	modMenuExit, modMenuEnter
}

// (Settings) Deadzone IDs
enum { deadzoneLeft, deadzoneRight }
// (Settings) Screen saver IDs
enum { screenSaverOff, screenSaverBlank, screenSaverUptime, screenSaverVisualizer }
// (Settings) VM speed IDs
enum { vmSpeed4, vmSpeed6, vmSpeed8, vmSpeed10 }

// (Toggle) Array IDs
enum {
	toggleProfile = 0,
	toggleUniversal = 2,
	toggleAutoFocus = 4,
	toggleFastMelee = 6,
	toggleRapidFire = 8
}

/**************************************************************/
//	Constants (strings)
/**************************************************************/
// (Aim Assist) Aim Assist Type
const string aimAssistTypeName[] = { "Decreasing", "Steady", "Increasing" }
// (Aim Assist) Aim/Rotation/Idle Target Assist status
const string assistStatus[] = { "Off", "ADS Only", "Fire only", "ADS & Fire", "ADS or Fire", "ADS & Fire / Fire",  "On" }
// (Aim Assist) Shapes
const string aimAssistShapeName[] = { "Circle", "Oval", "Ellipse", "Lemniscate", "Rose", "Flower", "Orbit", "Spiral" }
// (Aim Assist) Type prompt
const string aimAssistTypeMsg[] = { "ADS: ", "Fire: " }
// (Anti-drift) Calibration direction
const string antiDriftCalibrationDirectionPrompt[] = { "Direction: Up", "Direction: Down", "Direction: Left", "Direction: Right" }
// (Anti-drift) Calibration result
const string antiDriftCalibrationResult[] = { "Failed", "Success", "Cancelled", "Reset Value" }
// (Anti-drift) Calibration state
const string antiDriftCalibrationStateMsg[] = { "Press A/Cross", "Waiting" }
// (Anti-drift) Calibration stick
const string antiDriftCalibrationStickPrompt[] = { "Joystick: Left", "Joystick: Right" }
// (Anti-drift) Values display
const string antiDriftValues[] = { "U: ", "D: ", "L: ", "R: " }
// (Anti-recoil) Anti-recoil Type
const string antiRecoilStatus[] = { "Off", "Basic", "Advanced" }
// (Controller) Bumper/triggers Flipped status
const string flippedBumperTriggers[] = { "Default", "Flipped" }
// (Controller) Bumper Ping & ADS Stick Swap status
const string swappedStatus[] = { "Default", "Swapped" }

// (Controller) Button Layout names
const string buttonLayoutName[] = {
	"Default", "Tactical", "Lefty",
	"N0M4D/Charlie", "N0M4D/Charlie Tact", "N0M4D/Charlie L3F7",
	"Bumper Jumper", "Bumper Jumper Tact", "OneHand Gunslinger",
	"Stick and Move", "Brawler", "Beast", "Bumper Ping",
	"Bumper Ping Tac"
}

// (Controller) Button names [PlayStation]
const string controllerButtonsPS4[] = {
	"not set", "", "",
	"R1", "R2", "", "L1", "L2",
	"", "", "", "", "",
	"Up", "Down", "Left", "Right",
	"Triangle", "Circle", "Cross", "Square"
}

// (Controller) Button names [XBOX]
const string controllerButtonsXBOX[] = {
	"not set", "", "",
	"RB", "RT", "", "LB", "LT",
	"", "", "", "", "",
	"Up", "Down", "Left", "Right",
	"Y", "B", "A", "X"
}

// (Controller) Stick Layout names
const string stickLayoutName[] = { "Default", "Southpaw", "Legacy", "Legacy Southpaw", "Southpaw NCS", "Legacy SP NCS" }
// (Display) Home screen messages
const string homeScreenMessages[] = { "Zeitgeist", "Version 1.03", "Swedemafia" }
// (Display) LED color names
const string colorName[] = { "Red", "Orange", "Gold", "White", "Yellow", "Green", "Teal", "Blue", "Purple", "Pink" }
// (Display) On/off Toggle
const string toggleOffOn[] = { "Off", "On" }
// (Display) Script paused notification
const string scriptPausedMsg = "Paused";
// (Options) Rapid Fire Speed
const string rapidFireSpeed = "Shots/Second: "

// (Profiles) Profile toggle/color prompts
const string profileToggleMsg[] = {
	"Resync: ", "Switch: ", // Profile Switch
	"Button 1: ", "Button 2: ", // Universal Switch
	"Primary:   ", "Secondary: ", "Universal: " // Profile Colors
}

// (Profiles) Profile names
const string profileName[] = { "Primary", "Secondary", "Universal" }
// (Settings) Deadzone prompt
const string stickName[] = { "Left: ", "Right: " }
// (Settings) Screen saver names
const string screenSaver[] = { "Off", "Blank", "Uptime", "Visualizer" }
// (Settings) VM speed display
const string vmSpeed[] = { "4ms", "6ms", "8ms", "Default" }
// (Settings) Settings saved notification
const string settingsSaved = "Settings Saved";

// (Toggles) Toggle combo messages
const string toggleMessages[] = {
	"Auto Focus: Off", "Auto Focus: On",
	"Fast Melee: Off", "Fast Melee: On",
	"Rapid Fire: Off", "Rapid Fire: On"
}

/**************************************************************/
//	Constants (integers)
/**************************************************************/
// (Controller) Available toggle buttons
const int8 controllerButtons[] = {
	XB1_VIEW,
	XB1_RB, XB1_RT, XB1_LB, XB1_LT,
	XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT,
	XB1_Y, XB1_B, XB1_A, XB1_X
}

// (Controller) Button Layout map
const int8 buttonLayoutMap[][] = {
	// ADS	  Tact	  Ping	  Focus	  Fire	  Lethal  Switch Action Jump	Melee
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Default
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_A, XB1_B }, // Tactical
	{ XB1_RT, XB1_RB, XB1_UP, XB1_RS, XB1_LT, XB1_LB, XB1_Y, XB1_B, XB1_A, XB1_LS }, // Lefty
	{ XB1_RB, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_LT, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Nomad/Charlie
	{ XB1_RB, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_LT, XB1_Y, XB1_RS, XB1_A, XB1_B }, // Nomad/Charlie Tac
	{ XB1_LB, XB1_RB, XB1_UP, XB1_RS, XB1_LT, XB1_RT, XB1_Y, XB1_B, XB1_A, XB1_LS }, // Nomad/Charlie Left
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_LB, XB1_RS }, // Bumper Jumper
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_LB, XB1_B }, // Bumper Jumper Tact
	{ XB1_LT, XB1_RB, XB1_UP, XB1_LS, XB1_LB, XB1_RT, XB1_Y, XB1_B, XB1_A, XB1_RS }, // One-hand Gunslinger
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_RS, XB1_A }, // Stick and Move
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RS, XB1_Y, XB1_B, XB1_A, XB1_RB }, // Brawler
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RS, XB1_Y, XB1_B, XB1_LB, XB1_RB }, // Beast
	{ XB1_LT, XB1_RB, XB1_LB, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Bumper Ping
	{ XB1_LT, XB1_RB, XB1_LB, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_A, XB1_B }  // Bumper Ping Tactical
}

// (Controller) Stick Layout map
const int8 stickLayoutMap[][] = {
	// Move   	Strafe  	Look    Rotate    
	{ POLAR_LY, POLAR_LX, POLAR_RY, POLAR_RX }, // Default
	{ POLAR_RY, POLAR_RX, POLAR_LY, POLAR_LX }, // Southpaw
	{ POLAR_LY, POLAR_RX, POLAR_RY, POLAR_LX }, // Legacy
	{ POLAR_RY, POLAR_LX, POLAR_LY, POLAR_RX }, // Legacy Southpaw
	{ POLAR_RY, POLAR_RX, POLAR_LY, POLAR_LX }, // Southpaw No Click Swap
	{ POLAR_RY, POLAR_LX, POLAR_LY, POLAR_RX }  // Legacy Southpaw No Click Swap
}

// (Display) HSB color values
const int16 colorValues[][] = {
	{ 0, 100, 75 }, // Red
	{ 10, 100, 75 }, // Orange
	{ 17, 100, 100 }, // Gold
	{ 20, 50, 100 }, // White
	{ 30, 100, 100 }, // Yellow
	{ 120, 100, 75 }, // Green
	{ 135, 100, 75 }, // Teal
	{ 200, 100, 50 }, // Blue
	{ 300, 100, 50 }, // Purple
	{ 359, 50, 75 } // Pink
}

// (Display) Line numbers for OLED_FONT_SMALL
const int8 lineNumber[] = { 22, 34, 46 }
// (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
// (Display) Font width
const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }
// (Setings) VM Speed
const int8 vmSpeedValue[] = { -6, -4, -2, 0 }

/**************************************************************/
//	Menus
/**************************************************************/
// (Menu) Edit menu names
const string editMenuNames[] = {
	"Aim Assist", "Aim Assist Type", "Aim Assist Shape", "Aim Assist Radius", "Aim Assist Speed", // Aim assist
		"Rotation Assist", "Rotation Radius", "Rotation Interval", // Rotation Assist
		"Idle Target Assist", "Idle Target Time", "Idle Target Shape", "Idle Target Radius", "Idle Target Speed", // Idle target assist
	"Anti-drift", "Calibration", "Drift Test", "Drift Values", // Antidrift
	"Anti-recoil", "Strength", "Kick Strength", "Kick Duration", // Antirecoil
	"Button Layout", "Bumper Ping", "Bumper/Triggers", "Stick Layout", "ADS Stick Swap", // Controller
	"Auto Focus", "Fast Melee", "Rapid Fire", // Options
	"Profile Buttons", "Universal Profile", "Profile Colors", // Profiles
	"Block Rumble", "Deadzone", "Inverted", "Screen Saver", "VM Speed", // Settings
	"Auto Focus", "Fast Melee", "Rapid Fire" // Toggles
}

// (Menu) Edit menu IDs
enum {
	editMenuAimAssist, editMenuAimAssistBoost, editMenuAimAssistShape, editMenuAimAssistRadius, editMenuAimAssistSpeed, // Aim assist
		editMenuRotationAssist, editMenuRotationRadius, editMenuRotationInterval, // Rotation Assist
		editMenuIdleTargetAssist, editMenuIdleTargetTime, editMenuIdleTargetShape, editMenuIdleTargetRadius, editMenuIdleTargetSpeed, // Idle target assist
	editMenuAntidrift, editMenuAntidriftCalibration, editMenuAntidriftTest, editMenuAntidriftValues, // Anti-drift
	editMenuAntiRecoil, editMenuAntiRecoilStrength, editMenuAntiRecoilKickStrength, editMenuantiRecoilKickCounter, // Anti-recoil
	editMenuControllerButtonLayout, editMenuControllerBumperPing, editMenuControllerBumperTriggers, editMenuControllerStickLayout, editMenuControllerAdsStickSwap, 
	editMenuAutoFocus, editMenuFastMelee, editMenuRapidFire, // Options
	editMenuProfileSwitch, editMenuUniversalSwitch, editMenuProfileColors, // Profiles
	editMenuBlockRumble, editMenuDeadzone, editMenuInverted, editMenuScreenSaver, editMenuVMSpeed, // Settings
	editMenuToggleAutoFocus, editMenuToggleFastMelee, editMenuToggleRapidFire // Toggles
}

// (Display) Edit menu items
const int8 editMenuItems[][] = {
	// Minimum			Maximum				Show Profile
	{ editMenuAimAssist, editMenuIdleTargetSpeed, TRUE }, // Aim assist
	{ editMenuAntidrift, editMenuAntidriftValues, FALSE }, // Anti-drift
	{ editMenuAntiRecoil, editMenuantiRecoilKickCounter, TRUE }, // Anti-recoil
	{ editMenuControllerButtonLayout, editMenuControllerAdsStickSwap, FALSE }, // Controller
	{ editMenuAutoFocus, editMenuRapidFire, TRUE }, // Options
	{ editMenuProfileSwitch, editMenuProfileColors, FALSE }, // Profiles
	{ editMenuBlockRumble, editMenuVMSpeed, FALSE }, // Settings
	{ editMenuToggleAutoFocus, editMenuToggleRapidFire, FALSE } // Toggles
}

// (Menu) Mod menu names
const string modMenuNames[] = {
	"Aim Assist", "Anti-drift", "Anti-recoil", "Controller",
	"Options", "Profiles", "Settings", "Toggles"
}

// (Menu) Mod menu IDs
enum {
	modMenuAimAssist, modMenuAntidrift, modMenuAntiRecoil, modMenuController,
	modMenuOptions, modMenuProfiles, modMenuSettings, modMenuToggles
}

// (Display) Mod menu items
const int8 modMenuItems[][] = {
	// Previous			Current			Next
	{ modMenuToggles, modMenuAimAssist, modMenuAntidrift },
	{ modMenuAimAssist, modMenuAntidrift, modMenuAntiRecoil },
	{ modMenuAntidrift, modMenuAntiRecoil, modMenuController },
	{ modMenuAntiRecoil, modMenuController, modMenuOptions },
	{ modMenuController, modMenuOptions, modMenuProfiles },
	{ modMenuOptions, modMenuProfiles, modMenuSettings },
	{ modMenuProfiles, modMenuSettings, modMenuToggles },
	{ modMenuSettings, modMenuToggles, modMenuAimAssist }
}


/**************************************************************/
//	Begin script
/**************************************************************/
init {
	// Initialize menu min/max
	aimAssistShapeMin = aaShapeCircle;
	aimAssistShapeMax = aaShapeSpiral;
	modMenuMin = modMenuAimAssist;
	modMenuMax = modMenuToggles;
	
	homeUpdate = 1; // Display home screen on startup
	displayBuffer = 1; // Initialize display buffer
	loadSettings(); // Load user-defined settings
}

main {
	if(!homeHide) { // If home screen is visible
		if(!varOptionRapidFire[currentProfile] && !checkCombos()) {
			setProfileLedColor(currentProfile); // Set LED color to notify user of current profile
		}
		if(homeUpdate) { // See if we need to redraw homescreen
			homeUpdate = !homeUpdate; // Disable home screen update
			displayHomeScreen(); // Show home screen
			vm_tctrl(vmSpeedValue[varVMSpeed]); // Set VM speed [TODO: MOVE ELSEWHERE]
		}
	} else {
		if(!scriptPaused) { // If not in pause mode, set LED color
			if(!combo_running(cboCalibrationComplete) && !checkCombos()) { // Do not mess with LED if cboCalibrationComplete is running
				if(editMenu && (editMenuIndex == editMenuProfileColors)) {
					setProfileLedColor(editMenuSelectedItem); // Set LED to color of profile color being edited
				} else if(editMenu && antiDriftCalibrationState && !antiDriftCalibrationInRange) { // While during anti-drift calibration mode
					setLedColor(orange);
				} else if(editMenu && antiDriftCalibrationState && antiDriftCalibrationInRange) { // In target range for stick movement
					setLedColor(green);
				} else if(editMenu) {
					setProfileLedColor(menuProfile); // Set LED to profile being edited (in edit menu)
				} else {
					if(!checkCombos()) {
						setProfileLedColor(currentProfile); // Set LED to current profile (not in menus)
					}
				}
			}
		}
	}
	
	calculateUptime(); // Calculate uptime
	
	// Only remove if calibration is NOT running
	if(!antiDriftCalibrationState) {
		removeDriftAndApplyDeadzone(); // Remove stick drift and apply deadzone
	}
	
	// User can only access menus if script is not scriptPaused
	if(antiDriftCalibrationState) {
		if(antiDriftCalibrationStick == antiDriftLeftStick) {
			if(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown) {
				antiDriftCalibrationPolarStick = POLAR_LY;
				checkCalibrationRange();
			} else {
				antiDriftCalibrationPolarStick = POLAR_LX;
				checkCalibrationRange();
			}
		} else {
			if(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown) {
				antiDriftCalibrationPolarStick = POLAR_RY;
				checkCalibrationRange();
			} else {
				antiDriftCalibrationPolarStick = POLAR_RX;
				checkCalibrationRange();
			}
		}
	}
	
	if(!scriptPaused) {
		 // If screen saver is enabled, see if we have been idle long enough
		 if(varScreenSaver && !homeHide && !modMenu && !editMenu && !screenSaverEnabled && !checkCombos()) { 
			screenSaverCounter += get_rtime(); // Increase counter by value of VM speed
			// See if we have been idle long enough
			if(screenSaverCounter >= 2000) { 
				screenSaverEnabled = !screenSaverEnabled; // Enable screen saver
				screenSaverCounter = 0;
				cls_oled(OLED_BLACK); // Do this here because there is no need to reset to black every single time in displayScreenSaver()
			}
		} else if(screenSaverEnabled) {
			displayScreenSaver(); // Screen saver is enabled, display it
		}
		
		// If user is at home screen or screen saver is enabled, check for request to enter mod menu
		if(!homeHide || screenSaverEnabled && !antiDriftCalibrationState) { 
			// See if user is entering mod menu
			if(get_val(button[ads]) && event_press(XB1_MENU) && !antiRecoilQuickEdit && !checkCombos() && !combo_running(cboSwitchProfile)) { 
				homeHide = !homeHide; // Hide home screen
				modMenu = !modMenu; // Display mod menu
				modMenuUpdate = !modMenuUpdate; // Enable mod menu update
				menuProfile = currentProfile; // Set profile in menu to current profile
				screenSaverCounter = 0; // Reset screen saver timer
				// See if screen saver is currently enabled
				if(screenSaverEnabled) {
					screenSaverEnabled = !screenSaverEnabled; // Disable screen saver
					homeUpdate = !homeUpdate; // Disable home display update
				}
			} else if(get_val(button[ads]) && event_press(XB1_VIEW) && !antiRecoilQuickEdit && !checkCombos() && !combo_running(cboSwitchProfile)) {
				homeHide = !homeHide; // Hide home screen
				editMenu = !editMenu; // Enable edit menu
				modMenuIndex = modMenuAntiRecoil; // Set edit menu to anti-recoil mod menu
				antiRecoilQuickEdit = !antiRecoilQuickEdit; // Enable recoil quick edit
				menuProfile = currentProfile; // Set profile in menu to current profile
				screenSaverCounter = 0; // Reset screen saver timer
				
				// Set menu indexes
				if(varAntiRecoil[menuProfile] == antiRecoilOff) {
					editMenuIndex = editMenuAntiRecoil;
				} else {
					editMenuIndex = editMenuAntiRecoilStrength;
				}
				
				displayEditMenu(); // Display anti-recoil edit menu
				
				// See if screen saver is currently enabled
				if(screenSaverEnabled) {
					screenSaverEnabled = !screenSaverEnabled; // Disable screen saver
					homeUpdate = !homeUpdate; // Disable home display update
				}
			}
		} else if (modMenu && !editMenu) { // Mod menu
			checkModMenuEvent(); // Check for mod menu event
		} else if (!modMenu && editMenu) { // Edit menu
			checkEditMenuEvent(); // Check for edit menu event
		}
		
		// Check if user wants to pause the script (and not in menus) then execute mods
		if(!checkPause() && !modMenu && !editMenu) {
			// Get current stick position values
			holdingADS = get_val(button[ads]);
			holdingFire = get_val(button[fire]);
			checkAdsStickSwap(); // Perform check for 'ADS Stick Swap' setting
			checkAssist(); // Execute any enabled assists (Aim Assist [+etc.], Rotation Assist, Anti-Recoil)
			checkOptions(); // Execute any running options
			
			// Run alert if Rapid Fire is enabled
			if(varOptionRapidFire[currentProfile] && !checkCombos()) {
				combo_run(cboToggleAlert);
			}
			
			// Check for "hair triggers"
			if(get_val(button[ads])) {
				set_val(button[ads], 100);
			}
			if(get_val(button[fire])) {
				set_val(button[fire], 100);
			}
			
		}
		checkToggles(); // Check for toggles
		blockActionButtons(); // Block any action buttons
		blockMenuButtons(); // Block any buttons pressed while in menu
	} else {
		checkUnpause();
	}
	
	checkBlockRumble(); // Always check for block rumble whether in menus or not
}


/**************************************************************/
//	Functions
/**************************************************************/
// Block output to controller from menu actions
function blockActionButtons() {
	// Loop through each toggle combination and block if being used
	for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i += 2) {
		if(varToggleButton[i] && varToggleButton[i + 1]) {
			if(get_ival(varToggleButton[i])) {
				set_val(varToggleButton[i + 1], 0);
			}
		}
	}
	// Block quick edit recoil and entering the menu buttons
	if(get_val(button[ads])) {
		set_val(XB1_MENU, 0);
		set_val(XB1_VIEW, 0);
	}
}

// Block output to controller from menu actions
function blockMenuButtons() {
	// Block all buttons while in a menu
	if(modMenu || editMenu || antiRecoilQuickEdit) {
		block_all_inputs();
	}
}

// Prepares the display buffer for a multiple item menu
function buildSelectedItemBuffer(type, message, value) {
	// Build display
	insertString(message);
	
	// Determine data type being used
	if(type == displayString) {
		insertString(value);
	} else {
		insertNumber(value);
	}
}

// Calculate uptime values
function calculateUptime() {
	uptimeCounter += get_rtime();
	if(uptimeCounter >= 1000) {
		uptimeSeconds++;
		uptimeCounter -= 1000;
		if(uptimeSeconds >= 60) {
			uptimeMinutes++;
			uptimeSeconds = 0;
			if(uptimeMinutes >= 60) {
				uptimeHours++;
				uptimeMinutes = 0;
				if(uptimeHours >= 24) {
					uptimeDays++;
					uptimeHours = 0;
				}
			}
		}
	}
}

// Checks the stick when in calibration mode to make sure the
// user has moved the stick to the appropriate range prior to
// releasing the stick and setting the new value
function checkCalibrationRange() {
	// Determine target range
	if((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) {
		antiDriftCalibrationLow = -11468; // 35
		antiDriftCalibrationHigh = -8191 // 25
	} else {
		antiDriftCalibrationLow = 8191; // 25
		antiDriftCalibrationHigh = 11468; // 35
	}
	
	// Get stick value
	antiDriftCalibrationRangeValue = get_val(antiDriftCalibrationPolarStick);
	
	// See if stick is moved within boundaries
	if((antiDriftCalibrationRangeValue >= antiDriftCalibrationLow) && (antiDriftCalibrationRangeValue <= antiDriftCalibrationHigh)) {
		// Notify user it is in range and allow calibration to proceed
		antiDriftCalibrationInRange = TRUE;
		antiDriftCalibrationCanSet = TRUE;
	} else if(((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) && antiDriftCalibrationRangeValue < antiDriftCalibrationLow) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else if(((antiDriftCalibrationDirection == antiDriftRight) || (antiDriftCalibrationDirection == antiDriftDown)) && antiDriftCalibrationRangeValue > antiDriftCalibrationHigh) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else {
		// Release zone not met
		antiDriftCalibrationInRange = FALSE;
	} 
}

// Checks if a status change combo is running (i.e. action failed/success)
function checkCombos() {
	if(combo_running(cboActionFailed)) {
		return TRUE;
	} else if(combo_running(cboActionSuccess)) {
		return TRUE;
	} else if(combo_running(cboSaveSettings)) {
		return TRUE;
	} else if(combo_running(cboToggleOn) || combo_running(cboToggleOff)) {
		return TRUE;
	}
	return FALSE;
}

// Checks for activation based on ADS and Fire flags
function checkActivation(activation) {
	// Check activation flags
	if(activation) {
		//	ADS Only / Fire Only / ADS & Fire				ADS or Fire										(ADS & Fire OR Fire)
		return ((activation == assistFlags) || ((activation == assistAdsOrFire) && assistFlags) || ((activation == assistAdsAndFireOrFire) && (assistFlags & 2)));
	}
	
	return 0;
}

// Controller ADS stick swap
function checkAdsStickSwap() {
	// Check if ADS stick swap is enabled
	if(varControllerAdsStickSwap == cbpSwapped) {
		stick[aimX] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][moveX], stickLayoutMap[varControllerStickLayout][aimX]);
		stick[aimY] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][moveY], stickLayoutMap[varControllerStickLayout][aimY]);
		stick[moveX] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][aimX], stickLayoutMap[varControllerStickLayout][moveX]);
		stick[moveY] = iif(holdingADS, stickLayoutMap[varControllerStickLayout][aimY], stickLayoutMap[varControllerStickLayout][moveY]);
	}
	// else, do nothing
}

// Determine which Assist mods must be executed
// - Aim Assist (+etc.), Rotation Assist, Anti-recoil
function checkAssist() {
	
	// Set flags
	assistFlags = (holdingADS > 0) | ((holdingFire > 0) * 2);
	
	// Check Aim Assist
	if(checkActivation(varAimAssist[currentProfile])) {
		executeAimAssist();
	} else {
		resetAimAssist(); // Correct aim assist
	}
	
	// Check Rotation Assist
	if(checkActivation(varRotationAssist[currentProfile])) {
		executeRotationAssist();
	} else {
		rotationCounter = 0; // Reset rotation counter
	}
	
	// Check Anti-recoil
	if(varAntiRecoil[currentProfile]) {
		if(holdingADS && holdingFire) {
			executeAntiRecoil();
		} else {
			antiRecoilKickCounter = 0; // Reset anti-recoil kick counter
		}
	}
	
	assistFlags = 0; // Reset assist (aiming/firing) flags
}

// Checks for rumble block state
function checkBlockRumble() {
	if(varBlockRumble) {
		block_rumble();
	}
}

// Check for edit menu event
function checkEditMenuEvent() {
	// See if edit menu needs to update to the display
	if(editMenuUpdate) {
		displayEditMenu(); // Display edit menu
		editMenuUpdate = !editMenuUpdate; // Disable edit menu update
	}
	
	// See if we are setting toggle combination buttons
	switch(editMenuIndex) {
		case editMenuProfileSwitch {
			createToggle(toggleProfile);
			break;
		} case editMenuUniversalSwitch {
			createToggle(toggleUniversal);
			break;
		} case editMenuToggleAutoFocus {
			createToggle(toggleAutoFocus);
			break;
		} case editMenuToggleFastMelee {
			createToggle(toggleFastMelee);
			break;
		} case editMenuToggleRapidFire {
			createToggle(toggleRapidFire);
			break;
		}
	}
	
	// Check for events (only responsive to presses under 1000ms)
	if(checkEvent(XB1_LEFT)) { // Request edit menu cycle left
		cycleEditMenu(editMenuLeft);
	} else if(checkEvent(XB1_RIGHT)) { // Request edit menu cycle right
		cycleEditMenu(editMenuRight);
	} else if(checkEvent(XB1_UP)) { // Request edit menu cycle up
		cycleEditMenu(editMenuUp);
	} else if(checkEvent(XB1_DOWN)) { // Request edit menu cycle down
		cycleEditMenu(editMenuDown);
	} else if(checkEvent(XB1_LB)) { // Used for anti-drift calibration mode
		cycleEditMenu(editMenuBumperL);
	} else if(checkEvent(XB1_RB)) { // Used for anti-drift calibration mode
		cycleEditMenu(editMenuBumperR);
	} else if(checkEvent(XB1_A)) { // Used for anti-drift calibration mode
		cycleEditMenu(editMenuEnter);
	} else if(checkEvent(XB1_B)) { // Exit edit menu to mod menu
		cycleEditMenu(editMenuExit);
	} else if(checkEvent(XB1_VIEW)) {
		cycleEditMenu(editMenuAction);
	}
	
	if(editMenuIndex == editMenuAntidriftTest) {
		editMenuUpdate = !editMenuUpdate; // Constantly updating
	}
}

// Determine if an event is being called
function checkEvent(button) {
	return (event_release(button) && (get_ptime(button) < 1000));
}

// Check for mod menu event
function checkModMenuEvent() {
	// See if mod menu needs to update to the display
	if(modMenuUpdate) { 
		displayModMenu(); // Display mod menu
		modMenuUpdate = !modMenuUpdate; // Disable mod menu update
	}
	
	// Check for events
	if(event_release(XB1_DOWN)) { // Request mod menu cycle downwards
		cycleModMenu(modMenuDown);
	} else if(event_release(XB1_UP)) {// Request mod menu cycle upwards
		cycleModMenu(modMenuUp); 
	} else if(event_release(XB1_A)) { // Request enter mod menu
		cycleModMenu(modMenuEnter);
	} else if(event_release(XB1_B)) { // Exit mod menu to home screen
		cycleModMenu(modMenuExit);
	}
}

// Checks for running options and executes them if enabled
function checkOptions() {
	// Auto Focus
	if(varOptionAutoFocus[currentProfile]) {
		// If aiming, execute combo
		if(combo_running(cboAutoFocus) && !combo_running(cboToggleScope) && get_val(button[ads]) && get_ival(button[focus]) && get_ptime(button[focus]) <= 120) {
			combo_stop(cboAutoFocus);
			combo_run(cboToggleScope);
		} else if(get_val(button[ads]) && get_ival(button[fire])) {
			// Do not want to restart the combo in middle of holding button[focus] or it may just result in a toggle
			if(!(combo_step_time_left(cboAutoFocus) >= 2800 && combo_step_time_left(cboAutoFocus) <= 2900)) {
				combo_restart(cboAutoFocus);
			}
		} else if(get_val(button[ads])) {
			// If combo not running, execute it
			if(!combo_running(cboAutoFocus) && !combo_running(cboToggleScope)) {
				combo_run(cboAutoFocus);
			}
		} else {
			// If not aiming and combo running, stop it
			if(combo_running(cboAutoFocus)) {
				combo_stop(cboAutoFocus);	
			}
		}
	}
	
	// Fast Melee
	if(varOptionFastMelee[currentProfile] && get_val(button[melee])) {
		// Only run combo if it is not already running
		if(!combo_running(cboFastMelee)) {
			combo_run(cboFastMelee);
		}
	} else if(combo_running(cboFastMelee)) { // Stop combo if it doesn't meet conditions
		combo_stop(cboFastMelee);
	}
	
	// Rapid Fire
	if(varOptionRapidFire[currentProfile] && get_val(button[fire])) {
		// Only run combo if it is not already running
		if(!combo_running(cboRapidFire)) {
			combo_run(cboRapidFire);		
		}
	} else if(combo_running(cboRapidFire)) { // Stop combo if doesn't conditions
		combo_stop(cboRapidFire);
	}
}

// Checks if user is attempting to pause the script (i.e. when using a vehicle)
function checkPause() {
	if(get_val(button[fire]) && event_release(XB1_RIGHT) && get_brtime(XB1_RIGHT) <= 300) {
		scriptPaused = !scriptPaused; // Enable vehicle mode
		screenSaverCounter = 0; // Reset screen saver timer
		
		// Display Vehicle Mode message
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, scriptPausedMsg[0], OLED_FONT_SMALL, OLED_WHITE);
		
		// If screen saver enabled, disable it
		if(screenSaverEnabled) {
			screenSaverEnabled = !screenSaverEnabled;
		}
	}
	
	// Block button output
	if(get_val(button[fire])) {
		set_val(XB1_RIGHT, 0);
	}
	
	return scriptPaused;
}

// Checks if the aim assist shape to use is different from
// the last shape and resets aim assist values if needed 
function checkShapeChange(shape) {
	if(shape != aimAssistShape) {
		resetAimAssist();
	}
}

// Checks for toggle combination buttons to be pressed
function checkToggles() {
	// Only check if user is NOT in a menu
	if(!modMenu && !editMenu) {
		// Loop through all toggle combinations
		for(i = 0; i < sizeof(varToggleButton) / sizeof(varToggleButton[0]); i += 2) {
			// Only process if a toggle is set
			if(varToggleButton[i] && varToggleButton[i + 1]) {
				// See if toggle is requested
				if(get_val(varToggleButton[i]) && event_release(varToggleButton[i + 1])) {
					dispatchToggle(i);
					return;
				}
			}
		}
		
		// Switch profile button pressed
		if(varToggleButton[toggleProfile + 1] && (currentProfile != 2) && event_release(varToggleButton[toggleProfile + 1])) {
			switchProfile(!currentProfile);
			return;
		}
	}
	
	// Y/Triangle pressed in a edit menu that supports settings per profile
	if(editMenu && editMenuItems[modMenuIndex][editMenuShowProfile] && event_release(XB1_Y)) {
		menuProfile = iif(menuProfile == 2, 0, menuProfile++);
		editMenuUpdate = 2; // Enable edit menu update (no alert)
	}
}

// Check if user is requesting to unpause script (end vehicle mode)
function checkUnpause() {
	if(event_press(XB1_X)) {
		scriptPaused = !scriptPaused; // Disable vehicle mode
		homeUpdate = !homeUpdate; // Enable home screen update
		
		// Disable vehicle mode notification
		if(combo_running(cboscriptPaused)) {
			combo_stop(cboscriptPaused);
		}
	} else {
		combo_run(cboscriptPaused); // Enable vehicle mode notification
	}
}

// Called to check if OLED should be cleared after an action while using Visualizer screen saver
function clearVisualizer() {
	// Check for visualizer screen saver
	if(screenSaverEnabled && varScreenSaver == screenSaverVisualizer) {
		combo_run(cboClearScreen); // Runs faster in a combo
	}
}

// Correct stick input based on drift low/high values including deadzone and compensate for "lost" values
function correctStickInput(low, high, deadzone, stick) {
	// Calculate the boundaries
	antiDriftLowValue = low - polarValues[deadzone];
	antiDriftHighValue = high + polarValues[deadzone];
	antiDriftStickValue = get_val(stick); // Get stick value
	
	// In the drift zone, so set stick to no movement
	if((antiDriftStickValue >= antiDriftLowValue) && (antiDriftStickValue <= antiDriftHighValue)) {
		set_val(stick, 0);
		
	// If user has moved stick under the lower boundary (left/up)
	} else if(antiDriftStickValue < antiDriftLowValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftLowValue) - ((antiDriftStickValue / 327) * antiDriftLowValue) / 100, -32768, 32767));
		
	// If user has moved stick over the upper boundary (right/down)
	} else if(antiDriftStickValue > antiDriftHighValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftHighValue) + ((antiDriftStickValue / 327) * antiDriftHighValue) / 100, -32768, 32767));
		
	// Just incase stick_value isn't in driftzone and doesn't meet other conditions
	// (i.e. calculations equate to low/high value)
	// At that point we still do not want to make any adjustment because we're not outside of the drift+deadzone
	} else {
		set_val(stick, 0);
	}
}

// Creates a toggle combination
function createToggle(toggle) {
	// Loop through each controllerButtons and see what is being held down for 1 second
	for(i = 0; i < 13; i++) {	
		if(get_val(controllerButtons[i]) && (get_ptime(controllerButtons[i]) >= 1000)) {
			if(!editMenuSelectedItem) {
				// Setting HOLD
				varToggleButton[toggle] = setToggleButton(varToggleButton[toggle], controllerButtons[i], varToggleButton[toggle + 1]);
				varToggleButton[toggle] = verifyToggleCombo(varToggleButton[toggle], toggle);
			} else {
				// Setting PRESS
				varToggleButton[toggle + 1] = setToggleButton(varToggleButton[toggle + 1], controllerButtons[i], varToggleButton[toggle]);
				varToggleButton[toggle + 1] = verifyToggleCombo(varToggleButton[toggle + 1], toggle);
			}
		}
	}
}

// Cycles the edit menu
function cycleEditMenu(direction) {
	// Enable edit menu display update
	editMenuUpdate = !editMenuUpdate;
	
	// Determine action from user and handle accordingly
	switch(direction) {
		case editMenuBumperL { // Used for anti-drift calibration
			if((editMenuIndex == editMenuAntidriftCalibration) && (antiDriftCalibrationStick != antiDriftLeftStick) && !antiDriftCalibrationState) {
				antiDriftCalibrationStick = antiDriftLeftStick;
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuBumperR { // Used for anti-drift calibration
			if((editMenuIndex == editMenuAntidriftCalibration) && (antiDriftCalibrationStick != antiDriftRightStick) && !antiDriftCalibrationState) {
				antiDriftCalibrationStick = antiDriftRightStick;
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuAction { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) {
				if(antiDriftCalibrationStick == antiDriftLeftStick) {
					varAntidriftLeft[antiDriftCalibrationDirection] = 0;
				} else {
					varAntidriftRight[antiDriftCalibrationDirection] = 0;
				}
				antiDriftCalibrationCanSet = 3;
				combo_run(cboCalibrationComplete); // Alert user of status
				antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuEnter { // Used for anti-drift calibration
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				// Only set if range was met
				if(antiDriftCalibrationCanSet) {
					determineAntidriftValue(); // Determine the value to set
				}
				combo_run(cboCalibrationComplete); // Alert user of status
			} else if(editMenuIndex == editMenuAntidriftCalibration) {
				antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
			} else {
				menuActionFailed();
			}
			break;
		} case editMenuExit { // When user presses B/Circle
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				antiDriftCalibrationCanSet = 2; // Flag for cancelled
				combo_run(cboCalibrationComplete);
			} else {
				editMenu = !editMenu; // Disable edit menu
				editMenuUpdate = !editMenuUpdate; // Disable edit menu display update
				editMenuSelectedItem = 0; // Reset selected item index
				
				// Check if we are in anti-recoil quick edit
				if(antiRecoilQuickEdit) {
					homeHide = !homeHide; // Enable home screen
					homeUpdate = !homeUpdate; // Enable home display update
					antiRecoilQuickEdit = !antiRecoilQuickEdit; // Disable anti-recoil quick edit
					combo_run(cboSaveSettings); // Save settings
				} else {
					modMenu = !modMenu; // Enable mod menu
					modMenuUpdate = !modMenuUpdate; // Enable mod menu update
				}
			}
			editMenuIndex = 0; // Reset index
			break;
		} case editMenuLeft { // When user presses Dpad-Left
			if(get_val(button[ads])) { // When user is holding ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 1, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 1, 1);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape
					if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
						} else {
							varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
						}
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 1, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 1, 1);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 1, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 1, 1);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuRotationInterval) { // (Aim Assist) Rotation Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 1, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 1, 1);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 1, 1);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 1, 1);
					}
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftLeft) {
						antiDriftCalibrationDirection = antiDriftLeft;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick Value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuantiRecoilKickCounter) {  // (Anti-recoil) Kick Duration [advanced]
					varantiRecoilKickCounter[menuProfile] = cycleEditValue(varantiRecoilKickCounter[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueDown, 1, 1);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile colors
					varProfileColor[editMenuSelectedItem] = cycleListOption(varProfileColor[editMenuSelectedItem], cycleValueDown, red, pink);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedItem] = cycleEditValue(varDeadzone[editMenuSelectedItem], cycleValueDown, 1, 0);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				editMenuSelectedItem = 0; // Reset selected item index
				if((editMenuIndex == editMenuAimAssist) && (varIdleTargetAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if ITA is off
				} else if((editMenuIndex == editMenuIdleTargetAssist) && (varRotationAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if RA is off
				} else if((editMenuIndex == editMenuRotationAssist) && (varAimAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if RA is off
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilOff)) {
					menuActionFailed(); // Anti-recoil must be enabled to see rest of options
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilBasic)) {
					editMenuIndex = editMenuAntiRecoilStrength; // Basic Anti-Recoil can only access Strength menu
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilAdvanced)) {
					editMenuIndex = editMenuantiRecoilKickCounter; // Advanced Anti-Recoil can access kick counter/duration menu
				} else if(editMenuIndex == editMenuAntidrift && !varAntidrift) {
					menuActionFailed(); // Anti-drift must be enabled to see rest of options
				} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
					menuActionFailed(); // Cannot leave calibration menu if calibration is running
				} else {
					editMenuIndex = cycleListOption(editMenuIndex, cycleValueDown, editMenuItems[modMenuIndex][editMenuMin], editMenuItems[modMenuIndex][editMenuMax]);
				}
			}
			break;
		} case editMenuRight { // When user presses DPad-Right
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 1, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 1, 100);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape
					if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
						} else {
							varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
						}
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 1, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 1, 100);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 1, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 1, 100);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuRotationInterval) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 1, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 1, 100);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 1, 100);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 1, 100);
					}
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftRight) {
						antiDriftCalibrationDirection = antiDriftRight;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuantiRecoilKickCounter) {  // (Anti-recoil) Kick duration [advanced]
					varantiRecoilKickCounter[menuProfile] = cycleEditValue(varantiRecoilKickCounter[menuProfile], cycleValueUp, 1, 100);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueUp, 1, 60);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile colors
					varProfileColor[editMenuSelectedItem] = cycleListOption(varProfileColor[editMenuSelectedItem], cycleValueUp, pink, red);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedItem] = cycleEditValue(varDeadzone[editMenuSelectedItem], cycleValueUp, 1, 30); 	
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				editMenuSelectedItem = 0; // Reset selected item index
				if((editMenuIndex == editMenuAimAssist) && (varAimAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if AA is off
				} else if((editMenuIndex == editMenuRotationAssist) && (varRotationAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if RA is off
				} else if((editMenuIndex == editMenuIdleTargetAssist) && (varIdleTargetAssist[menuProfile] == assistOff)) {
					editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if ITA is off
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilOff)) {
					menuActionFailed(); // Anti-recoil must be enabled to see rest of options 
				} else if((editMenuIndex == editMenuAntiRecoil) && (varAntiRecoil[menuProfile] == antiRecoilBasic)) {
					editMenuIndex = editMenuAntiRecoilStrength; // Basic Anti-recoil can only access Strength option
				} else if((editMenuIndex == editMenuAntiRecoilStrength) && (varAntiRecoil[menuProfile] == antiRecoilBasic)) {
					editMenuIndex = editMenuAntiRecoil; // Basic Anti-recoil can only access Strength option and main toggle
				} else if((editMenuIndex == editMenuAntiRecoilStrength) && (varAntiRecoil[menuProfile] == antiRecoilAdvanced)) {
					editMenuIndex = editMenuAntiRecoilKickStrength; // Advanced Anti-Recoil can access kick duration/strength
				} else if(editMenuIndex == editMenuAntidrift && !varAntidrift) {
					menuActionFailed(); // Anti-drift must be enabled to see rest of options
				} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
					menuActionFailed(); // Cannot leave calibration menu if calibration is running
				} else {
					editMenuIndex = cycleListOption(editMenuIndex, cycleValueUp, editMenuItems[modMenuIndex][editMenuMax], editMenuItems[modMenuIndex][editMenuMin]);
				}
			}
			break;
		} case editMenuUp { // When user presses DPad-Up
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 10, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueUp, 10, 100);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueUp, 10, 100);
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 10, 100);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueUp, 10, 100);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueUp, 10, 100);
					} 
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 10, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueUp, 10, 100);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueUp, 10, 100);
					}
				} else if(editMenuIndex == editMenuRotationInterval) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 10, 100);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueUp, 10, 100);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 10, 100);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueUp, 10, 100)
					}
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftUp) {
						antiDriftCalibrationDirection = antiDriftUp;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuantiRecoilKickCounter) {  // (Anti-recoil) Kick duration [advanced]
					varantiRecoilKickCounter[menuProfile] = cycleEditValue(varantiRecoilKickCounter[menuProfile], cycleValueUp, 10, 100);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueUp, 10, 60);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedItem] = cycleEditValue(varDeadzone[editMenuSelectedItem], cycleValueUp, 10, 30);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAimAssist) { // (Aim assist)
					varAimAssist[menuProfile] = cycleListOption(varAimAssist[menuProfile], cycleValueUp, assistAdsAndFireOrFire, assistOff);
				} else if(editMenuIndex == editMenuAimAssistBoost) { // (Aim Assist) Type
					varAimAssistType[menuProfile] = cycleListOption(varAimAssistType[menuProfile], cycleValueUp, aimAssistTypeIncreasing, aimAssistTypeDecreasing);
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape selection
					if(varAimAssist[menuProfile] == assistAdsOnly) { // Ads only
						varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire setting allows selection of ads/fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
					} else { // Fire only
						varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
					}
				} else if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Only available on Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Only available on Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationAssist) { // (Aim Assist) Rotation Assist
					varRotationAssist[menuProfile] = cycleListOption(varRotationAssist[menuProfile], cycleValueUp, assistAdsAndFireOrFire, assistOff);
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Radius selection
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationInterval) { // (Aim Assist) Rotation speed selection
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuIdleTargetAssist) { // (Aim Assist) Idle Target Assist
					if(varIdleTargetAssist[menuProfile] == assistOff) {
						varIdleTargetAssist[menuProfile] = assistOn;
					} else {
						varIdleTargetAssist[menuProfile] = assistOff;
					}
				} else if(editMenuIndex == editMenuIdleTargetShape) { // (Aim Assist) Idle Target Assist Shape
					varIdleTargetShape[menuProfile] = cycleListOption(varIdleTargetShape[menuProfile], cycleValueUp, aimAssistShapeMax, aimAssistShapeMin);
				} else if(editMenuIndex == editMenuAntidrift) { // (Anti-drift)
					varAntidrift = !varAntidrift;
				} else if(editMenuIndex == editMenuAntiRecoil) { // (Anti-recoil)
					varAntiRecoil[menuProfile] = cycleListOption(varAntiRecoil[menuProfile], cycleValueUp, antiRecoilAdvanced, antiRecoilOff);
				} else if(editMenuIndex == editMenuControllerButtonLayout) { // (Controller) Button Layout
					varControllerButtonLayout = cycleListOption(varControllerButtonLayout, cycleValueUp, cblBumperPingTactical, cblDefault);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperPing) { // (Controller) Bumper Ping Swapped
					varControllerBumperPing = cycleListOption(varControllerBumperPing, cycleValueUp, cbpSwapped, cbpDefault);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperTriggers) { // (Controller) Bumper/Triggers Flipped
					varControllerBumperTriggers = !varControllerBumperTriggers;
					setBumperTriggers(); // Refresh bumper/triggers setting
				} else if(editMenuIndex == editMenuControllerStickLayout) { // (Controller) Stick Layout
					varControllerStickLayout = cycleListOption(varControllerStickLayout, cycleValueUp, slLegacySouthpawNoClickSwap, slDefault);
					setStickLayout(); // Refresh stick layout
				} else if(editMenuIndex == editMenuControllerAdsStickSwap) { // (Controller) ADS Stick Swap
					varControllerAdsStickSwap = !varControllerAdsStickSwap;
					if(!varControllerAdsStickSwap) { // No longer swapped, reset layout
						setStickLayout(); // Refresh stick layout
					}
				} else if(editMenuIndex == editMenuAutoFocus) { // (Options) Auto Focus
					varOptionAutoFocus[menuProfile] = !varOptionAutoFocus[menuProfile];
				} else if(editMenuIndex == editMenuFastMelee) { // (Options) Fast Melee
					varOptionFastMelee[menuProfile] = !varOptionFastMelee[menuProfile];
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFire[menuProfile] = !varOptionRapidFire[menuProfile];
				} else if(editMenuIndex == editMenuProfileSwitch) { // (Profiles) Profile Buttons
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuUniversalSwitch) { // (Profiles) Universal Profile
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuBlockRumble) { // (Settings) Block Rumble
					varBlockRumble = !varBlockRumble;
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuInverted) { // (Settings) Inverted
					varInverted = !varInverted;
				} else if(editMenuIndex == editMenuScreenSaver) { // (Settings) Screen Saver
					varScreenSaver = cycleListOption(varScreenSaver, cycleValueUp, screenSaverVisualizer, screenSaverOff);
				} else if(editMenuIndex == editMenuVMSpeed) { // (Settings) VM Speed
					varVMSpeed = cycleEditValue(varVMSpeed, cycleValueUp, 1, vmSpeed10);
				} else if(editMenuIndex == editMenuToggleAutoFocus) { // (Toggles) Auto Focus
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuToggleFastMelee) { // (Toggles) Fast Melee
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else if(editMenuIndex == editMenuToggleRapidFire) { // (Toggles) Rapid Fire
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueDown, 1, 0);
				} else {
					menuActionFailed();
				}
			}
			break;
		} case editMenuDown { // When user presses DPad-Down
			if(get_val(button[ads])) { // When user holds ADS
				if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 10, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsRadius[menuProfile] = cycleEditValue(varAimAssistAdsRadius[menuProfile], cycleValueDown, 10, 1);
						} else {
							varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varAimAssistFireRadius[menuProfile] = cycleEditValue(varAimAssistFireRadius[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed
					if(varAimAssist[menuProfile] == assistAdsOnly) {
						varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 10, 1);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varAimAssistAdsSpeed[menuProfile] = cycleEditValue(varAimAssistAdsSpeed[menuProfile], cycleValueDown, 10, 1);
						} else {
							varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varAimAssistFireSpeed[menuProfile] = cycleEditValue(varAimAssistFireSpeed[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 10, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsRadius[menuProfile] = cycleEditValue(varRotationAdsRadius[menuProfile], cycleValueDown, 10, 1);
						} else {
							varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varRotationFireRadius[menuProfile] = cycleEditValue(varRotationFireRadius[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuRotationInterval) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOnly) {
						varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 10, 1);
					} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
						if(!editMenuSelectedItem) {
							varRotationAdsSpeed[menuProfile] = cycleEditValue(varRotationAdsSpeed[menuProfile], cycleValueDown, 10, 1);
						} else {
							varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 10, 1);
						}
					} else {
						varRotationFireSpeed[menuProfile] = cycleEditValue(varRotationFireSpeed[menuProfile], cycleValueDown, 10, 1);
					}
				} else if(editMenuIndex == editMenuIdleTargetTime) { // (Aim Assist) Idle Target Assist Time
					varIdleTargetTime[menuProfile] = cycleEditValue(varIdleTargetTime[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuIdleTargetRadius) { // (Aim Assist) Idle Target Assist Radius
					varIdleTargetRadius[menuProfile] = cycleEditValue(varIdleTargetRadius[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuIdleTargetSpeed) { // (Aim Assist) Idle Target Assist Speed
					varIdleTargetSpeed[menuProfile] = cycleEditValue(varIdleTargetSpeed[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) { // (Anti-drift) Set direction
					if(antiDriftCalibrationDirection != antiDriftDown) {
						antiDriftCalibrationDirection = antiDriftDown;
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAntiRecoilStrength) {  // (Anti-recoil) Strength
					varAntiRecoilStrength[menuProfile] = cycleEditValue(varAntiRecoilStrength[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuAntiRecoilKickStrength) {  // (Anti-recoil) Kick value [advanced]
					varAntiRecoilKickStrength[menuProfile] = cycleEditValue(varAntiRecoilKickStrength[menuProfile], cycleValueDown, 10, 0);
				} else if(editMenuIndex == editMenuantiRecoilKickCounter) {  // (Anti-recoil) Kick duration [advanced]
					varantiRecoilKickCounter[menuProfile] = cycleEditValue(varantiRecoilKickCounter[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFireSpeed[menuProfile] = cycleEditValue(varOptionRapidFireSpeed[menuProfile], cycleValueDown, 10, 1);
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					varDeadzone[editMenuSelectedItem] = cycleEditValue(varDeadzone[editMenuSelectedItem], cycleValueDown, 10, 0);
				} else {
					menuActionFailed();
				}
			} else { // Cycle options
				if(editMenuIndex == editMenuAimAssist) { // (Aim Assist)
					varAimAssist[menuProfile] = cycleListOption(varAimAssist[menuProfile], cycleValueDown, assistOff, assistAdsAndFireOrFire);
				} else if(editMenuIndex == editMenuAimAssistBoost) { // (Aim Sssist) Type
					varAimAssistType[menuProfile] = cycleListOption(varAimAssistType[menuProfile], cycleValueDown, aimAssistTypeDecreasing, aimAssistTypeIncreasing);
				} else if(editMenuIndex == editMenuAimAssistShape) { // (Aim Assist) Shape
					if(varAimAssist[menuProfile] == assistAdsOnly) { // Ads only
						varAimAssistAdsShape[menuProfile] = cycleListOption(varAimAssistAdsShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
					} else if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire setting allows selection of ads/fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
					} else { // Fire only
						varAimAssistFireShape[menuProfile] = cycleListOption(varAimAssistFireShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
					}
				} else if(editMenuIndex == editMenuAimAssistRadius) { // (Aim Assist) Radius selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuAimAssistSpeed) { // (Aim Assist) Speed selection
					if(varAimAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationAssist) { // (Aim Assist) Rotation Assist
					varRotationAssist[menuProfile] = cycleListOption(varRotationAssist[menuProfile], cycleValueDown, assistOff, assistAdsAndFireOrFire);
				} else if(editMenuIndex == editMenuRotationRadius) { // (Aim Assist) Rotation Assist Radius
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuRotationInterval) { // (Aim Assist) Rotation Assist Speed
					if(varRotationAssist[menuProfile] == assistAdsOrFire) { // Ads or fire
						editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
					} else {
						menuActionFailed();
					}
				} else if(editMenuIndex == editMenuIdleTargetAssist) { // (Aim Assist) Idle Target Assist
					if(varIdleTargetAssist[menuProfile] == assistOff) {
						varIdleTargetAssist[menuProfile] = assistOn;
					} else {
						varIdleTargetAssist[menuProfile] = assistOff;
					}
				} else if(editMenuIndex == editMenuIdleTargetShape) { // (Aim Assist) Idle Target Assist Shape
					varIdleTargetShape[menuProfile] = cycleListOption(varIdleTargetShape[menuProfile], cycleValueDown, aimAssistShapeMin, aimAssistShapeMax);
				} else if(editMenuIndex == editMenuAntidrift) { // (Anti-drift)
					varAntidrift = !varAntidrift;
				} else if(editMenuIndex == editMenuAntiRecoil) { // (Anti-recoil)
					varAntiRecoil[menuProfile] = cycleListOption(varAntiRecoil[menuProfile], cycleValueDown, antiRecoilOff, antiRecoilAdvanced);
				} else if(editMenuIndex == editMenuControllerButtonLayout) { // (Controller) Button Layout
					varControllerButtonLayout = cycleListOption(varControllerButtonLayout, cycleValueDown, cblDefault, cblBumperPingTactical);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperPing) { // (Controller) Bumper Ping Swapped
					varControllerBumperPing = cycleListOption(varControllerBumperPing, cycleValueDown, cbpDefault, cbpSwapped);
					setButtonLayout(); // Refresh button layout
				} else if(editMenuIndex == editMenuControllerBumperTriggers) { // (Controller) Bumper/Triggers Flipped
					varControllerBumperTriggers = !varControllerBumperTriggers;
					setBumperTriggers(); // Refresh bumper/triggers setting
				} else if(editMenuIndex == editMenuControllerStickLayout) { // (Controller) Stick Layout
					varControllerStickLayout = cycleListOption(varControllerStickLayout, cycleValueDown, slDefault, slLegacySouthpawNoClickSwap);
					setStickLayout(); // Refresh stick layout
				} else if(editMenuIndex == editMenuControllerAdsStickSwap) { // (Controller) ADS Stick Swap
					varControllerAdsStickSwap = !varControllerAdsStickSwap;
					if(!varControllerAdsStickSwap) { // No longer swapped, reset layout
						setStickLayout(); // Refresh stick layout
					}
				} else if(editMenuIndex == editMenuAutoFocus) { // (Options) Auto Focus
					varOptionAutoFocus[menuProfile] = !varOptionAutoFocus[menuProfile];
				} else if(editMenuIndex == editMenuFastMelee) { // (Options) Fast Melee
					varOptionFastMelee[menuProfile] = !varOptionFastMelee[menuProfile];
				} else if(editMenuIndex == editMenuRapidFire) { // (Options) Rapid Fire
					varOptionRapidFire[menuProfile] = !varOptionRapidFire[menuProfile];
				} else if(editMenuIndex == editMenuProfileSwitch) { // (Profiles) Profile Buttons
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuUniversalSwitch) { // (Profiles) Universal Profile
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuProfileColors) { // (Profiles) Profile Colors
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 2);
				} else if(editMenuIndex == editMenuBlockRumble) { // (Settings) Block Rumble
					varBlockRumble = !varBlockRumble;
				} else if(editMenuIndex == editMenuDeadzone) { // (Settings) Deadzone
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuInverted) { // (Settings) Inverted
					varInverted = !varInverted;
				} else if(editMenuIndex == editMenuScreenSaver) { // (Setting) Screen saver
					varScreenSaver = cycleListOption(varScreenSaver, cycleValueDown, screenSaverOff, screenSaverVisualizer);
				} else if(editMenuIndex == editMenuVMSpeed) { // (Settings) VM Speed
					varVMSpeed = cycleEditValue(varVMSpeed, cycleValueDown, 1, vmSpeed4);
				} else if(editMenuIndex == editMenuToggleAutoFocus) { // (Toggles) Auto Focus
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuToggleFastMelee) { // (Toggles) Fast Melee
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
				} else if(editMenuIndex == editMenuToggleRapidFire) { // (Toggles) Rapid Fire
					editMenuSelectedItem = cycleEditValue(editMenuSelectedItem, cycleValueUp, 1, 1);
				} else {
					menuActionFailed();
				}
			}
			break;
		}
	}
}

// Cycle an edit menu value by step amount with change limited to a threshold
function cycleEditValue(value, direction, step, threshold) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + step) <= threshold) {
			return (value + step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	} else {
		if((value - step) >= threshold) {
			return (value - step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	}
	
	return value;
}

// Cycle a menu value
function cycleListOption(value, direction, threshold, reset_value) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + 1) <= threshold) {
			return value + 1;
		}
	} else {
		if((value - 1) >= threshold) {
			return value - 1;
		}
	}
	
	return reset_value;
}

// Cycle mod menu value
function cycleModMenu(direction) {
	
	modMenuUpdate = !modMenuUpdate; // Update mod menu
	
	switch(direction) {
		case modMenuEnter {
			modMenu = !modMenu; // Disable mod menu
			editMenu = !editMenu; // Enable edit menu
			modMenuUpdate = !modMenuUpdate; // Disable mod menu update
			editMenuUpdate = !editMenuUpdate; // Enable edit menu update
			editMenuIndex = editMenuItems[modMenuIndex][editMenuMin]; // Set new edit menu index
			break;
		} case modMenuExit {
			homeHide = !homeHide; // Enable home screen
			modMenu = !modMenu; // Disable mod menu
			modMenuUpdate = !modMenuUpdate; // Disable mod menu update
			combo_run(cboSaveSettings); // Save settings upon exiting mod menu
			break;
		} case modMenuDown {
			modMenuIndex++; // Cycle to next menu
			if(modMenuIndex > modMenuMax) { // Check boundaries
				modMenuIndex = modMenuMin; // Out of bounds, set to minimum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		} case modMenuUp {
			modMenuIndex--; // Cycle to previous menu
			if(modMenuIndex < modMenuMin) { // Check boundaries
				modMenuIndex = modMenuMax; // Out of bounds, set to maximum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		}
	}
}

// Determines what to set the anti-drift value to, if a new value was found
function determineAntidriftValue() {
	if(antiDriftCalibrationStick == antiDriftLeftStick) {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue < varAntidriftLeft[antiDriftUp]) || (varAntidriftLeft[antiDriftUp] == 0)) {
					varAntidriftLeft[antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue > varAntidriftLeft[antiDriftDown]) || (varAntidriftLeft[antiDriftDown] == 0)) {
					varAntidriftLeft[antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue < varAntidriftLeft[antiDriftLeft]) || (varAntidriftLeft[antiDriftLeft] == 0)) {
					varAntidriftLeft[antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue > varAntidriftLeft[antiDriftRight]) || (varAntidriftLeft[antiDriftRight] == 0)) {
					varAntidriftLeft[antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	} else {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue < varAntidriftRight[antiDriftUp]) || (varAntidriftRight[antiDriftUp] == 0)) {
					varAntidriftRight[antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue > varAntidriftRight[antiDriftDown]) || (varAntidriftRight[antiDriftDown] == 0)) {
					varAntidriftRight[antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue < varAntidriftRight[antiDriftLeft]) || (varAntidriftRight[antiDriftLeft] == 0)) {
					varAntidriftRight[antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue > varAntidriftRight[antiDriftRight]) || (varAntidriftRight[antiDriftRight] == 0)) {
					varAntidriftRight[antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	}
}

// Handles a pressed toggle combination sequence
function dispatchToggle(id) {
	// Determine which toggle is triggered and handle it accordingly
	switch(id) {
		case toggleProfile {
			if(currentProfile != 2) {
				switchProfile(!currentProfile); // Switch profiles
			}
			break;	
		} case toggleUniversal {
			switchProfile(iif(currentProfile == 2, 0, 2));
			break;
		} case toggleAutoFocus {
			varOptionAutoFocus[currentProfile] = !varOptionAutoFocus[currentProfile];
			// Disable combo if it is running
			if(combo_running(cboToggleAutoFocus)) {
				combo_stop(cboToggleAutoFocus);
			}
			// Run combo to alert user
			combo_run(cboToggleAutoFocus);
			break;
		} case toggleFastMelee {
			varOptionFastMelee[currentProfile] = !varOptionFastMelee[currentProfile];
			// Disable combo if it is running
			if(combo_running(cboToggleFastMelee)) {
				combo_stop(cboToggleFastMelee);
			}
			// Run combo to alert user
			combo_run(cboToggleFastMelee);
			break;
		} case toggleRapidFire {
			varOptionRapidFire[currentProfile] = !varOptionRapidFire[currentProfile];
			// Disable combo if it is running
			if(combo_running(cboToggleRapidFire)) {
				combo_stop(cboToggleRapidFire);
			}
			// Run combo to alert user
			combo_run(cboToggleRapidFire);
			break;
		}
	}
}


// Displays stick values for the Anti-drift Test menu
function displayAntidriftTest(x, y, line) {
	// Build display
	insertCharacter(iif(x == POLAR_LX, ASCII_UPPER_L, ASCII_UPPER_R));
	insertCharacter(ASCII_COLON);
	insertCharacter(ASCII_SPACE);
	insertNumber(get_val(x));
	insertCharacter(ASCII_COMMA);
	insertNumber(get_val(y));
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
}

// Displays the current anti-drift X/Y values for both sticks
function displayAntidriftValues() {
	// Draw a separator line down middle of OLED
	line_oled(OLED_WIDTH >> 1, lineNumber[0] - 4, OLED_WIDTH >> 1, OLED_HEIGHT - 2, 1, OLED_WHITE);
	// Draw each value
	for(j = 0; j < 4; j++) {
		// Left stick
		insertString(antiDriftValues[j]);
		insertNumber(varAntidriftLeft[j]);
		flushBuffer(alignLeft - 2, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
		// Right stick
		insertString(antiDriftValues[j]);
		insertNumber(varAntidriftRight[j]);
		flushBuffer((OLED_WIDTH >> 1) + 3, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws a list of two items and highlights the selected item
function displayDualSelection(type, message1, message2, value1, value2) {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedItem] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Generate first item
	buildSelectedItemBuffer(type, message1, value1);
	flushSelectedItemBuffer(0, lineNumber[0]);
	// Generate second item
	buildSelectedItemBuffer(type, message2, value2);
	flushSelectedItemBuffer(1, lineNumber[1]);
}

// Display edit menu
function displayEditMenu() {
	// Clears the screen and draw a border to prep edit menu display
 	drawBorder();
 	
 	// Will be 2 if user is setting toggle buttons
 	if(editMenuUpdate != 2 && !antiDriftCalibrationState && editMenuIndex != editMenuAntidriftTest) { 
  		menuActionSuccess();
	}
	
	// Display edit menu title and draw a line beneath it for formatting
	printText(alignCenter, alignTop, editMenuNames[editMenuIndex], OLED_FONT_SMALL, OLED_WHITE);
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	
	// See if we should draw a line and display profile name
	if(editMenuItems[modMenuIndex][editMenuShowProfile]) {
		line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
		printText(alignCenter, alignBottom, profileName[menuProfile], OLED_FONT_SMALL, OLED_WHITE); // Display profile name
	}
	
	// See what setting we must display
	switch (editMenuIndex) {
		case editMenuAimAssist { // (Aim Assist)
			printText(alignCenter, alignCenter, assistStatus[varAimAssist[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistBoost { // (Aim Assist) Type
			printText(alignCenter, alignCenter, aimAssistTypeName[varAimAssistType[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistRadius { // (Aim Assist) Radius
			if(varAimAssist[menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, varAimAssistAdsRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], varAimAssistAdsRadius[menuProfile], varAimAssistFireRadius[menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, varAimAssistFireRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistShape { // (Aim Assist) Shape
			if(varAimAssist[menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistShapeName[varAimAssistAdsShape[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistShapeName[varAimAssistAdsShape[menuProfile]], aimAssistShapeName[varAimAssistFireShape[menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistShapeName[varAimAssistFireShape[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistSpeed { // (Aim Assist) Speed
			if(varAimAssist[menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, varAimAssistAdsSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varAimAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], varAimAssistAdsSpeed[menuProfile], varAimAssistFireSpeed[menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, varAimAssistFireSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationAssist { // (Aim Assist) Rotation Assist
			printText(alignCenter, alignCenter, assistStatus[varRotationAssist[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRotationRadius { // (Aim Assist) Rotation Assist Radius
			if(varRotationAssist[menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, varRotationAdsRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], varRotationAdsRadius[menuProfile], varRotationFireRadius[menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, varRotationFireRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationInterval { // (Aim Assist) Rotation Assist Speed
			if(varRotationAssist[menuProfile] == assistAdsOnly) {
				insertNumber(varRotationAdsSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
				flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(varRotationAssist[menuProfile] == assistAdsOrFire) {
				// Build ADS display
				insertString(aimAssistTypeMsg[0]);
				insertNumber(varRotationAdsSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
				
				// Determine if first item is selected
				if(editMenuSelectedItem == 0) {
					rect_oled(alignLeft, lineNumber[0] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_WHITE);
				}
				
				// Build fire display
				insertString(aimAssistTypeMsg[1]);
				insertNumber(varRotationFireSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
				
				// Determine if second item is selected
				if(editMenuSelectedItem == 1) {
					rect_oled(alignLeft, lineNumber[1] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
				}
			} else {
				insertNumber(varRotationFireSpeed[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
				flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuIdleTargetAssist { // (Aim Assist) Idle Target Assist
			printText(alignCenter, alignCenter, assistStatus[varIdleTargetAssist[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetTime { // (Aim Assist) Idle Target Assist Time
			insertNumber(varIdleTargetTime[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetRadius {// (Aim Assist) Idle Target Assist Radius
			printNumber(alignCenter, alignCenter, varIdleTargetRadius[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetShape {// (Aim Assist) Idle Target Assist Shape
			printText(alignCenter, alignCenter, aimAssistShapeName[varIdleTargetShape[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetSpeed { // (Aim Assist) Idle Target Assist Speed
			printNumber(alignCenter, alignCenter, varIdleTargetSpeed[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntidrift { // (Anti-drift) Toggle On/Off
			printText(alignCenter, alignCenter, toggleOffOn[varAntidrift], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntidriftCalibration { // (Anti-drift) Calibration
			if(antiDriftCalibrationState) {
				// Calibration mode running
				printText(alignCenter, alignCenter, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				// Calibration mode not running
				printText(alignCenter, lineNumber[0], antiDriftCalibrationStickPrompt[antiDriftCalibrationStick], OLED_FONT_SMALL, OLED_WHITE);
				printText(alignCenter, lineNumber[1], antiDriftCalibrationDirectionPrompt[antiDriftCalibrationDirection], OLED_FONT_SMALL, OLED_WHITE);
				rect_oled(alignLeft - 2, lineNumber[2], OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 4, 1, OLED_WHITE);
				printText(alignCenter, lineNumber[2] + 3, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_BLACK);
			}
			break;
		} case editMenuAntidriftTest { // (Anti-drift) Drift Test
			displayAntidriftTest(POLAR_LX, POLAR_LY, lineNumber[0]);
			displayAntidriftTest(POLAR_RX, POLAR_RY, lineNumber[1]);
			break;
		} case editMenuAntidriftValues { // (Anti-drift) Drift Values
			displayAntidriftValues();
			break;
		} case editMenuAntiRecoil { // (Anti-recoil)
			printText(alignCenter, alignCenter, antiRecoilStatus[varAntiRecoil[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntiRecoilStrength { // (Anti-recoil) Strength
			printNumber(alignCenter, alignCenter, varAntiRecoilStrength[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickStrength { // (Anti-recoil) Kick value [advanced]
			printNumber(alignCenter, alignCenter, varAntiRecoilKickStrength[menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuantiRecoilKickCounter { // (Anti-recoil) Kick duration [advanced]
			insertNumber(varantiRecoilKickCounter[menuProfile] * (10 + vmSpeedValue[varVMSpeed]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuControllerButtonLayout { // (Controller) Button Layout
			printText(alignCenter, alignCenter, buttonLayoutName[varControllerButtonLayout], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerBumperPing { // (Controller) Bumper Ping Swap
			printText(alignCenter, alignCenter, swappedStatus[varControllerBumperPing], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerBumperTriggers { // (Controller) Bumper Triggers Flipped
			printText(alignCenter, alignCenter, flippedBumperTriggers[varControllerBumperTriggers], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerStickLayout { // (Controller) Stick Layout
			printText(alignCenter, alignCenter, stickLayoutName[varControllerStickLayout], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerAdsStickSwap { // (Controller) ADS Stick Swap
			printText(alignCenter, alignCenter, swappedStatus[varControllerAdsStickSwap], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoFocus { // (Options) Auto Focus
			printText(alignCenter, alignCenter, toggleOffOn[varOptionAutoFocus[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuFastMelee { // (Options) Fast Melee
			printText(alignCenter, alignCenter, toggleOffOn[varOptionFastMelee[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRapidFire { // (Options) Rapid Fire
			printText(alignCenter, lineNumber[0], toggleOffOn[varOptionRapidFire[menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(rapidFireSpeed[0]);
			insertNumber(varOptionRapidFireSpeed[menuProfile]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuProfileSwitch { // (Profiles) Profile Switch
			displayDualSelection(displayString, profileToggleMsg[0], profileToggleMsg[1], iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[toggleProfile]], controllerButtonsXBOX[varToggleButton[toggleProfile]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[toggleProfile + 1]], controllerButtonsXBOX[varToggleButton[toggleProfile + 1]])); 
			break;
		} case editMenuUniversalSwitch { // (Profiles) Universal Switch
			displayToggle(toggleUniversal);
			break;
		} case editMenuProfileColors { // (Profiles) Profile colors
			displayProfileColorSelection();
			break;
		} case editMenuBlockRumble { // (Settings) Block Rumble
			printText(alignCenter, alignCenter, toggleOffOn[varBlockRumble], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDeadzone { // (Settings) Deadzone
			displayDualSelection(displayNumber, stickName[deadzoneLeft], stickName[deadzoneRight], varDeadzone[deadzoneLeft], varDeadzone[deadzoneRight]);
			break;
		} case editMenuInverted { // (Settings) Inverted
			printText(alignCenter, alignCenter, toggleOffOn[varInverted], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuScreenSaver { // (Settings) Screen saver
			printText(alignCenter, alignCenter, screenSaver[varScreenSaver], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuVMSpeed { // (Settings) VM speed
			printText(alignCenter, alignCenter, vmSpeed[varVMSpeed], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuToggleAutoFocus { // (Toggles) Auto Focus
			displayToggle(toggleAutoFocus);
			break;
		} case editMenuToggleFastMelee { // (Toggles) Fast Melee
			displayToggle(toggleFastMelee);
			break;
		} case editMenuToggleRapidFire { // (Toggles) Rapid Fire
			displayToggle(toggleRapidFire);
			break;
		}
	}
 }

// Display home screen
function displayHomeScreen() {

 	drawBorder(); // Clears the screen and draws a border
 	
	// Show home screen
	printText(alignCenter, 10, homeScreenMessages[homeScriptName], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 26, homeScreenMessages[homeScriptVersion], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 42, homeScreenMessages[homeScriptAuthor], OLED_FONT_SMALL, OLED_WHITE);
 }
 
 // Display mod menu
 function displayModMenu() {
 
 	drawBorder(); // Clears the screen and draws a border
  	menuActionSuccess(); // Alert for successful action
	
 	// Display the mod menu
	printText(alignCenter, alignTop, modMenuNames[modMenuItems[modMenuIndex][modMenuPrevious]], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, alignCenter, modMenuNames[modMenuItems[modMenuIndex][modMenuCurrent]], OLED_FONT_MEDIUM, OLED_WHITE);
	printText(alignCenter, alignBottom, modMenuNames[modMenuItems[modMenuIndex][modMenuNext]], OLED_FONT_SMALL, OLED_WHITE);
 }

// Draws the 'Profile Colors' selection menu
function displayProfileColorSelection() {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedItem] + 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Loop through each profile and display the name/color respectively
	for(i = 0; i < 3; i++) {
		insertString(profileToggleMsg[4 + i]);
		insertString(colorName[varProfileColor[i]]);
		flushBuffer(alignLeft, lineNumber[i] + 2, OLED_FONT_SMALL, iif(editMenuSelectedItem == i, OLED_BLACK, OLED_WHITE));
	}
}

// Display screen saver
function displayScreenSaver() {
	// TODO: is this really necessary will there ever be more screensavers?
	switch(varScreenSaver) {	
		case screenSaverUptime {
			cls_oled(OLED_BLACK); // Clear screen
			printUptime();
			break;
		}
	}
}

// Displays 'Button 1 & 2' messages and the proper controller buttons when editing toggles
function displayToggle(id) {
	displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[id]], controllerButtonsXBOX[varToggleButton[id]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[varToggleButton[id + 1]], controllerButtonsXBOX[varToggleButton[id + 1]]));
}

// Clears the screen and draws a border around the OLED
function drawBorder() {
	cls_oled(OLED_BLACK); // Clear screen
	rect_oled(0, 0, 128, 63, 0, OLED_WHITE); // Draw border around OLED
}

// Executes main Aim Assist, Idle Target assist, and radius adjustment
function executeAimAssist() {
	// If not firing (ADS only)
	if(!holdingFire) {
		checkShapeChange(varAimAssistAdsShape[currentProfile]); // Check if shape has changed
		// Retreive ADS values
		aimAssistShape = varAimAssistAdsShape[currentProfile];
		aimAssistRadius = varAimAssistAdsRadius[currentProfile];
		aimAssistSpeed = varAimAssistAdsSpeed[currentProfile];
	} else {
		// If IdleTarget engaged, no need to check for a shape change
		if(!idleTargetEngaged) {
			checkShapeChange(varAimAssistFireShape[currentProfile]); // Check if shape has changed
		}
		// Retreive Fire values
		aimAssistShape = varAimAssistFireShape[currentProfile];
		aimAssistRadius = varAimAssistFireRadius[currentProfile];
		aimAssistSpeed = varAimAssistFireSpeed[currentProfile];
		// Determine Idle Target Assist and any radius/speed adjustments
		getPolarStickValues(); // Get stick values
		executeIdleTargetAssist(); // Execute Idle Target Assist
		executeAimAssistRadiusAdjustment(); // Execute aim assist radius adjustment (aim assist type)
	}
	
	// Determine which shape to draw
	switch(aimAssistShape) {
		case aaShapeCircle {
			// Calculate the coordinates using the mathematical equations for a circle
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;		
		} case aaShapeOval {
			// Calculate the coordinates using the mathematical equations for a oval
			aimAssistX = (aimAssistRadius >> 1) * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;
		} case aaShapeEllipse {
			// Calculate the coordinates using the mathematical equations for an ellipse
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = (aimAssistRadius >> 1) * sin[aimAssistAngle];
			break;
		} case aaShapeLemniscate {
			// Calculate the coordinates using the mathematical equations for a lemniscate
			aimAssistX = aimAssistRadius * lemniscateX[aimAssistAngle];
			aimAssistY = aimAssistRadius * lemniscateY[aimAssistAngle];
			break;
		} case aaShapeRose {
			// Calculate the coordinates using the mathematical equations for a Rose (5 pedal Rose Curve)
			aimAssistX = aimAssistRadius * roseX[aimAssistAngle];
			aimAssistY = aimAssistRadius * roseY[aimAssistAngle];
			break;
		} case aaShapeFlower {
			// Calculate the coordinates using the mathematical equations for a flower shape
			aimAssistX = aimAssistRadius * flowerX[aimAssistAngle];
			aimAssistY = aimAssistRadius * flowerY[aimAssistAngle];
			break;
		} case aaShapeOrbit {
			// Calculate the coordinates for a "Orbit"
			aimAssistX = aimAssistRadius * orbitX[aimAssistAngle];
			aimAssistY = aimAssistRadius * orbitY[aimAssistAngle];
			break;
		} case aaShapeSpiral {
			// Calculate the coordinates using the mathematical equations for an Archimedes' spiral
			// x = a * t * cos(t)
			// y = a * t * sin(t)
			aimAssistX = (aimAssistRadius * aimAssistAngle * cos[aimAssistAngle]) / 328;
			aimAssistY = (aimAssistRadius * aimAssistAngle * sin[aimAssistAngle]) / 328;
			break;
		}
	}
	
	// Step to next angle
	aimAssistAngle += aimAssistSpeed;
	
	// Check if angle must be corrected
	if(aimAssistAngle >= 360) {
		aimAssistAngle %= 360;
		clearVisualizer(); // See if screen saver needs to be cleared
	}
	
	// Determine how values should be output to stick
	if(holdingADS && !holdingFire) {
		// If only aiming and not firing, gradually reduce output as it approaches 100
		output(stick[aimX], aimAssistX);
		output(stick[aimY], aimAssistY);
	} else {
		// Otherwise, output values as they are
		set_val(stick[aimX], clamp(get_val(stick[aimX]) + aimAssistX, -32768, 32767));
		set_val(stick[aimY], clamp(get_val(stick[aimY]) + aimAssistY, -32768, 32767));
	}
	
	// Check for visualizer screen saver
	if(screenSaverEnabled && (varScreenSaver == screenSaverVisualizer)) {
		// Draw aim assist shape to OLED
		pixel_oled(64 + (((aimAssistX / aimAssistRadius) * 30) / 327), 32 + (((aimAssistY / aimAssistRadius) * 30) / 327), OLED_WHITE);
	}
}

// Adjusts the radius based on % of stick movement
// - adjustment ranges from -10 (reducing) to +10 (expanding)
function executeAimAssistRadiusAdjustment() {
	// Check for adjustment type
	if(varAimAssistType[currentProfile] != aimAssistTypeSteady) {
		// Check for aim assist radius boost
		switch(varAimAssistType[currentProfile]) {
			case aimAssistTypeDecreasing { // Reducing
				// Decrements radius per 10% of aim stick move, limited to 50% of radius value
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				break;	
			} case aimAssistTypeIncreasing { // Expanding
				// Increment radius per 10% aim stick move
				aimAssistRadius += polarValue;
				break;
			}
		}
	}
}

// Executes anti-recoil
function executeAntiRecoil() {
	// See which type of anti-recoil is being used
	if(varAntiRecoil[currentProfile] == antiRecoilBasic) {
		antiRecoilY = polarValues[varAntiRecoilStrength[currentProfile]]; // Get polar value
	} else {
		if(get_rumble(RUMBLE_A) || get_rumble(RUMBLE_B)) { // TODO: is this even necessary?
			antiRecoilKickCounter += get_rtime(); // Increase kick duration counter
			antiRecoilY = iif(antiRecoilKickCounter <= (varantiRecoilKickCounter[currentProfile] * (10 + vmSpeedValue[varVMSpeed])), polarValues[varAntiRecoilKickStrength[currentProfile]], polarValues[varAntiRecoilStrength[currentProfile]]);
		} else {
			antiRecoilKickCounter = 0; // No longer firing / never fired
			antiRecoilY = polarValues[varAntiRecoilKickStrength[currentProfile]]; // Just apply basic until weapon is aimAssistFiring
		}
	}
	
	//set_val(stick[aimY], clamp(get_val(stick[aimY]) + (antiRecoilY * iif(varInverted, -1, 1)), -32768, 32767));
	output(stick[aimY], antiRecoilY * iif(varInverted, -1, 1));
}

// Executes idle target assist
// - if stick movement is less than 10.24% and timer met,
// 	 set new aim assist values until the stick is moved
function executeIdleTargetAssist() {
	// Check if idle target assist is enabled
	if(varIdleTargetAssist[currentProfile] == assistOn) {
		if(polarValue < 1) { // If stick is not moving
			if(idleTargetTimer >= (varIdleTargetTime[currentProfile] * (10 + vmSpeedValue[varVMSpeed]))) { // See if we have met the timer
				// If this is first time Idle Target Assist is engaged, reset the angle
				if(!idleTargetEngaged) {
					aimAssistAngle = 0; // Reset angle for new shape
				}
				aimAssistShape = varIdleTargetShape[currentProfile]; // Set aim assist shape to idle target shape
				aimAssistRadius = varIdleTargetRadius[currentProfile]; // Set aim assist radius to idle target radius
				aimAssistSpeed = varIdleTargetSpeed[currentProfile]; // Set aim assist speed to idle target speed
				idleTargetEngaged = TRUE;
			} else {
				idleTargetTimer += get_rtime(); // Add time elapsed to counter
				idleTargetEngaged = FALSE;
			}
		} else { // Stick has moved
			idleTargetTimer = 0; // Reset idle target timer if there is movement
			if(idleTargetEngaged) { // If idle target assist was engaged, reset aim assist
				aimAssistAngle = 0;
				idleTargetEngaged = FALSE;
			}
		}
	}
}

// Executes the rotational aim assist (left stick "strafe")
function executeRotationAssist() {
	// Get Rotation Assist values
	rotationRadius = iif(holdingFire, polarValues[varRotationFireRadius[currentProfile]], polarValues[varRotationAdsRadius[currentProfile]]);
	rotationDelay = iif(holdingFire, varRotationFireSpeed[currentProfile], varRotationAdsSpeed[currentProfile]);
	rotationDelay *= (10 + vmSpeedValue[varVMSpeed]); // Find delay in milliseconds
	
	// If counter is greater or equal to delay...change direction
	if(rotationCounter >= rotationDelay) {
		rotationCounter %= rotationDelay; // Set counter to any remainder
		rotationDirection = !rotationDirection; // Change direction
	} else {
		rotationCounter += get_rtime(); // Add # milliseconds since last loop
	}
	
	// Determine which direction to move stick
	output(stick[moveX], iif(rotationDirection, inv(rotationRadius), rotationRadius));
}

// Flushes the display buffer
function flushBuffer(x, y, size, color) {
	// Decrement display buffer value for proper arithmetic
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4; // Additional 4 for padding from border
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
		// No alignLeft case is needed because alignLeft is set to the proper left alignment already
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4; // Additional 4 for padding from border
			break;	
		}
		// No alignTop case is needed because alignTop is set to the proper top alignment already
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}

// Flushes the display buffer for a multiple item menu
function flushSelectedItemBuffer(item, line) {
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, iif(editMenuSelectedItem == item, OLED_BLACK, OLED_WHITE));
}

// Format and append the display buffer for displaying the script uptime
function generateUptime(value, character) {
	insertNumber(value);
	insertCharacter(character);
}

// Get stick polar radius based on the aiming stick that is used
// Basically gets "the stick to use" for calculating difference/addition
// for Aim Assist Type setting (increasing/decreasing)
function getPolarStickValues() {
	// Determine which stick radius to use for calculating aim assist radius boost/idle target assist
	switch(varControllerStickLayout) {
		case slDefault {
			polarStick = POLAR_RS;
			break;
		} case slSouthpaw {
		} case slSouthpawNoClickSwap {
			polarStick = POLAR_LS;
			break;
		} case slLegacy {
			if(abs(get_val(POLAR_RY)) > abs(get_val(POLAR_LX))) {
				polarStick = POLAR_RS;
			} else {
				polarStick = POLAR_LS;	
			}
			break;
		} case slLegacySouthpaw {
		} case slLegacySouthpawNoClickSwap {
			if(abs(get_val(POLAR_LY)) > abs(get_val(POLAR_RX))) {
				polarStick = POLAR_LS;
			} else {
				polarStick = POLAR_RS;	
			}
			break;
		}
	}
	
	// Set value to % the stick is moved (sets of 10)
	polarValue = get_polar(polarStick, POLAR_RADIUS) >> 10;
}

// Alternative for the ternary operator
function iif(expression, truepart, falsepart) {
	// Evaluate if expression is true
	if(expression) {
		return truepart; // Return truepart
	}
	
	// Else, return falsepart
	return falsepart;
}

// Inserts a character into the display buffer
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

// Inserts a number into the display buffer
function insertNumber(int value) {
	// Check if value is negative
	if(value < 0) {
		insertCharacter(ASCII_MINUS); // Insert '-' into the display buffer
		value = abs(value); // Convert value to positive
	}
	
	displayBufferInsertCopyValue = value; // Create a copy of value to perform work on
	displayBufferInsertNumberOfDigits = 0; // Reset number of digits to 0
	
    // Determine the number of digits in the number by
    // dividing it by 10 repeatedly until it becomes 0
    // while not ignoring a value of 0
    do {
        displayBufferInsertCopyValue /= 10;
        displayBufferInsertNumberOfDigits++;
    } while(displayBufferInsertCopyValue)
    
    // Extract each digit of the number and store it in an array
    for(i = 0; i < displayBufferInsertNumberOfDigits; i++) {
        displayBufferInsertDigits[i] = (value % 10) + 48;
        value /= 10;
    }
    
    // Insert the digits in the order that they appear in the number
    for(i = displayBufferInsertNumberOfDigits - 1; i >= 0; i--) {
        insertCharacter(displayBufferInsertDigits[i]);
    }
}

// Inserts a string into the display buffer
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(dint8(s)); // Insert character into display buffer
    	s++; // Move to next character of the string
    } while(dint8(s)) // Check if a next character exists
}

// Menu action allowed
function menuActionSuccess() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionSuccess)) { 
		combo_stop(cboActionSuccess);
	}
	
	combo_run(cboActionSuccess); // Execute alert
}

// Edit menu action not allowed
function menuActionFailed() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionFailed)) { 
		combo_stop(cboActionFailed);
	}
	
	editMenuUpdate = !editMenuUpdate; // Disable edit menu display update
	combo_run(cboActionFailed); // Execute alert
}

// Output value to stick and gradually reduce it as it approaches maximum movement
function output(stick, value) {
	if(value) {
		set_val(stick, clamp(value * (32767 - abs(get_val(stick))) / 32767 + get_val(stick), -32768, 32767));
	} else {
		set_val(stick, clamp(value * (-32768 + abs(get_val(stick))) / -32768 + get_val(stick), -32768, 32767));
	}
}

// Prints a number to the screen
function printNumber(x, y, number, size, color) {
	insertNumber(number);
	flushBuffer(x, y, size, color);
}

 // Prints text to the screen
 function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}

// Print the uptime to the OLED display
function printUptime() {
	// Check days
	if(uptimeDays) {
		generateUptime(uptimeDays, ASCII_LOWER_D);
	}
	// Check hours
	if(uptimeHours) {
		generateUptime(uptimeHours, ASCII_LOWER_H);
	}
	// Check minutes
	if(uptimeMinutes) {
		generateUptime(uptimeMinutes, ASCII_LOWER_M);
	}
	// Check seconds
	if(uptimeSeconds) {
		generateUptime(uptimeSeconds, ASCII_LOWER_S);
	}
	
	// Print centered to OLED the script uptime
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE); 
}

// Removes any "movement" inside calibrated drift area and applies a deadzone
function removeDriftAndApplyDeadzone() {
	// If anti-drift is not enabled, we use 0 for low/high values.  Deadzone doesn't matter
	if(varAntidrift) {
		correctStickInput(varAntidriftLeft[antiDriftLeft], varAntidriftLeft[antiDriftRight], varDeadzone[deadzoneLeft], stick[moveX]);
		correctStickInput(varAntidriftLeft[antiDriftUp], varAntidriftLeft[antiDriftDown], varDeadzone[deadzoneLeft], stick[moveY]);
		correctStickInput(varAntidriftRight[antiDriftLeft], varAntidriftRight[antiDriftRight], varDeadzone[deadzoneRight], stick[aimX]);
		correctStickInput(varAntidriftRight[antiDriftUp], varAntidriftRight[antiDriftDown], varDeadzone[deadzoneRight], stick[aimY]);
	} else {
		// This is done because it's possible user has values saved
		// but for whatever reason wants anti-drift off
		// Deadzone doesn't matter, if user doesn't want to use script deadzone
		// they can leave it at 0
		correctStickInput(0, 0, varDeadzone[deadzoneLeft], stick[moveX]);
		correctStickInput(0, 0, varDeadzone[deadzoneLeft], stick[moveY]);
		correctStickInput(0, 0, varDeadzone[deadzoneRight], stick[aimX]);
		correctStickInput(0, 0, varDeadzone[deadzoneRight], stick[aimY]);
	}
}

// Resets aim assist-related values
function resetAimAssist() {
	aimAssistAngle = 0; // Reset aim assist shape angle
	idleTargetTimer = 0; // Reset idle target timer
	clearVisualizer(); // Check if Visualizer is running and if so, clear the screen since Aim Assist is disengaged
}

// Swaps tactical button with ping button
function setBumperPing() {
	// Only swap Tactical and Ping if enabled
	if(varControllerBumperPing == cbpSwapped) {
		button[tactical] = button[tactical] ^ button[ping];
		button[ping] = button[ping] ^ button[tactical];
		button[tactical] = button[tactical] ^ button[ping];
	}
}

// Swaps the bumpers and triggers based on the Button Layout used
function setBumperTriggers() {
	if(varControllerBumperTriggers) {
		switch(varControllerButtonLayout) {
			case cblDefault {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblTactical {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblLefty {
				button[lethal] = XB1_LT;
				button[fire] = XB1_LB;
				button[tactical] = XB1_RT;
				button[ads] = XB1_RB;
				break;
			} case cblNomadCharlie {
				button[tactical] = XB1_LT;
				button[lethal] = XB1_LB;
				button[ads] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblNomadCharlieTactical {
				button[tactical] = XB1_LT;
				button[lethal] = XB1_LB;
				button[ads] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblNomadCharlieLefty {
				button[ads] = XB1_LT;
				button[fire] = XB1_LB;
				button[tactical] = XB1_RT;
				button[lethal] = XB1_RB;
				break;
			} case cblBumperJumper {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperJumperTactical {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblOneHandGunslinger {
				button[fire] = XB1_LT;
				button[ads] = XB1_LB;
				button[tactical] = XB1_RT;
				button[lethal] = XB1_RB;
				break;
			} case cblStickAndMove {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBrawler {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[melee] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBeast {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[melee] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperPing {
				button[ping] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperPingTactical {
				button[ping] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			}
		}
	}
}

// Sets button variables based on in-game settings
function setButtonLayout() {
	button[ads] = buttonLayoutMap[varControllerButtonLayout][ads];
	button[tactical] = buttonLayoutMap[varControllerButtonLayout][tactical];
	button[ping] = buttonLayoutMap[varControllerButtonLayout][ping];
	button[focus] = buttonLayoutMap[varControllerButtonLayout][focus];
	button[fire] = buttonLayoutMap[varControllerButtonLayout][fire];
	button[lethal] = buttonLayoutMap[varControllerButtonLayout][lethal];
	button[weapon] = buttonLayoutMap[varControllerButtonLayout][weapon];
	button[action] = buttonLayoutMap[varControllerButtonLayout][action];
	button[jump] = buttonLayoutMap[varControllerButtonLayout][jump];
	button[melee] = buttonLayoutMap[varControllerButtonLayout][melee];
}

// Set controller configuration
function setControllerConfig() {
	setButtonLayout();
	setBumperTriggers();
	setBumperPing();
	setStickLayout();
}

// Sets the LED to the color provided as the parameter
function setLedColor(color) {
	set_hsb(colorValues[color][hue], colorValues[color][saturation], colorValues[color][brightness]);
}

// Sets the LED to a color based on the profile being used
function setProfileLedColor(profile) {
	if(!checkCombos()) { // Do not overlap with running combos that use the LEDs
		set_hsb(colorValues[varProfileColor[profile]][hue], colorValues[varProfileColor[profile]][saturation], colorValues[varProfileColor[profile]][brightness]);
	}
}

// Sets joystick variables based on in-game settings
function setStickLayout() {
	// Determine movement and aiming sticks
	stick[aimX] = stickLayoutMap[varControllerStickLayout][aimX];
	stick[aimY] = stickLayoutMap[varControllerStickLayout][aimY];
	stick[moveX] = stickLayoutMap[varControllerStickLayout][moveX];
	stick[moveY] = stickLayoutMap[varControllerStickLayout][moveY];
	
	// For Southpaw, Left and Right joystick clicks must be swapped
	if((varControllerStickLayout == slSouthpaw) || (varControllerStickLayout == slLegacySouthpaw)) {
		switch(varControllerButtonLayout) {
			case cblDefault {
				button[melee] = XB1_RS;
				button[focus] = XB1_LS;
				break;
			} case cblTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblLefty {
				button[focus] = XB1_LS;
				button[melee] = XB1_RS;
				break;
			} case cblNomadCharlie {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblNomadCharlieTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblNomadCharlieLefty {
				button[focus] = XB1_LS;
				button[melee] = XB1_RS;
				break;
			} case cblBumperJumper {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperJumperTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblOneHandGunslinger {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblStickAndMove {
				button[jump] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBrawler {
				button[lethal] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBeast {
				button[lethal] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperPing {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperPingTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			}
		}
	}
}

// Attempts to bind button_to_set to a toggle combination
function setToggleButton(button_to_use, button_to_set, button_to_compare) {
	// Holding 'View' button will undo a previously set toggle combination button
	if(button_to_set == XB1_VIEW) {
		// Check if a buttin is set
		if(button_to_use) {
			button_to_use = 0; // Reset value
			editMenuUpdate = !editMenuUpdate; // Enable edit menu update
		}
	} else if(button_to_set != button_to_use) { // Check if value to set is different than current stored value for toggle
		if(button_to_set == button_to_compare) { // Make sure toggle combination [hold] button #1 does not equal [press] button #2
			combo_run(cboActionFailed); // Cannot map same buttons
		} else {
			button_to_use = button_to_set; // Set toggle button
		}
	}
	
	return button_to_use;
}

// Switches profiles
function switchProfile(profile) {
	// Check if last profile switch is still executing
	if(combo_running(cboSwitchProfile)) { // Check if last profile switch is still executing
		combo_stop(cboSwitchProfile); // Cancel it
	}
	
	// Check if an active toggle alert (i.e. Rapid Fire) is enabled
	if(combo_running(cboToggleAlert)) {
		combo_stop(cboToggleAlert);
	}
	
	// If screen saver is enabled, disable it
	if(screenSaverEnabled) {
		screenSaverEnabled = !screenSaverEnabled; // Disable screen saver
		screenSaverCounter = 0; // Reset counter
	}
	
	currentProfile = profile; // Set new profile
	combo_run(cboSwitchProfile); // Display notification
}

// Verifies that a toggle combination is not already set
function verifyToggleCombo(verify_button, index) {
	
	// Loop through each set of toggle buttons
	for(j = 0; j < sizeof(varToggleButton) / sizeof(varToggleButton[0]); j += 2) {
		if(varToggleButton[j] && varToggleButton[j + 1]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(varToggleButton[j] == varToggleButton[index] && varToggleButton[j + 1] == varToggleButton[index + 1]) {
					combo_run(cboActionFailed);
					return 0;
				}
			}
		}
	}
	
	editMenuUpdate = !editMenuUpdate; // Enable edit menu update
	combo_run(cboActionSuccess); // Notify user of success setting toggle button
	return verify_button; // Return button
}

/**************************************************************/
// User-defined settings
/**************************************************************/
// Load user-defined configuration settings
function loadSettings() {

	reset_spvar();
	
	// Read and check the first bit, if it is set, we know something should have been saved, otherwise we fall back on our default setting
	if(read_spvar(0, 1, 0)) {
		varAimAssist[0]							= read_spvar(assistOff, assistAdsAndFireOrFire, assistOff);
		varAimAssist[1]							= read_spvar(assistOff, assistAdsAndFireOrFire, assistOff);
		varAimAssist[2]							= read_spvar(assistOff, assistAdsAndFireOrFire, assistOff);
		varAimAssistType[0]						= read_spvar(aimAssistTypeDecreasing, aimAssistTypeIncreasing, aimAssistTypeDecreasing);
		varAimAssistType[1]						= read_spvar(aimAssistTypeDecreasing, aimAssistTypeIncreasing, aimAssistTypeDecreasing);
		varAimAssistType[2]						= read_spvar(aimAssistTypeDecreasing, aimAssistTypeIncreasing, aimAssistTypeDecreasing);
		varAimAssistAdsShape[0]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varAimAssistAdsShape[1]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varAimAssistAdsShape[2]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varAimAssistAdsRadius[0]				= read_spvar(1, 100, 10);
		varAimAssistAdsRadius[1]				= read_spvar(1, 100, 10);
		varAimAssistAdsRadius[2]				= read_spvar(1, 100, 10);
		varAimAssistAdsSpeed[0]					= read_spvar(1, 100, 10);
		varAimAssistAdsSpeed[1]					= read_spvar(1, 100, 10);
		varAimAssistAdsSpeed[2]					= read_spvar(1, 100, 10);
		varAimAssistFireShape[0]				= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varAimAssistFireShape[1]				= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varAimAssistFireShape[2]				= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varAimAssistFireRadius[0]				= read_spvar(1, 100, 10);
		varAimAssistFireRadius[1]				= read_spvar(1, 100, 10);
		varAimAssistFireRadius[2]				= read_spvar(1, 100, 10);
		varAimAssistFireSpeed[0]				= read_spvar(1, 100, 10);
		varAimAssistFireSpeed[1]				= read_spvar(1, 100, 10);
		varAimAssistFireSpeed[2]				= read_spvar(1, 100, 10);
		varRotationAssist[0]					= read_spvar(assistOff, assistAdsAndFireOrFire, 0);
		varRotationAssist[1]					= read_spvar(assistOff, assistAdsAndFireOrFire, 0);
		varRotationAssist[2]					= read_spvar(assistOff, assistAdsAndFireOrFire, 0);
		varRotationAdsRadius[0]					= read_spvar(1, 100, 20);
		varRotationAdsRadius[1]					= read_spvar(1, 100, 20);
		varRotationAdsRadius[2]					= read_spvar(1, 100, 20);
		varRotationAdsSpeed[0]					= read_spvar(1, 100, 2);
		varRotationAdsSpeed[1]					= read_spvar(1, 100, 2);
		varRotationAdsSpeed[2]					= read_spvar(1, 100, 2);
		varRotationFireRadius[0]				= read_spvar(1, 100, 20);
		varRotationFireRadius[1]				= read_spvar(1, 100, 20);
		varRotationFireRadius[2]				= read_spvar(1, 100, 20);
		varRotationFireSpeed[0]					= read_spvar(1, 100, 3);
		varRotationFireSpeed[1]					= read_spvar(1, 100, 3);
		varRotationFireSpeed[2]					= read_spvar(1, 100, 3);
		varIdleTargetAssist[0]					= read_spvar(assistOff, assistOn, assistOff);
		varIdleTargetAssist[1]					= read_spvar(assistOff, assistOn, assistOff);
		varIdleTargetAssist[2]					= read_spvar(assistOff, assistOn, assistOff);
		varIdleTargetTime[0]					= read_spvar(0, 100, 50);
		varIdleTargetTime[1]					= read_spvar(0, 100, 50);
		varIdleTargetTime[2]					= read_spvar(0, 100, 50);
		varIdleTargetShape[0]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varIdleTargetShape[1]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varIdleTargetShape[2]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax, aaShapeCircle);
		varIdleTargetRadius[0]					= read_spvar(1, 100, 8);
		varIdleTargetRadius[1]					= read_spvar(1, 100, 8);
		varIdleTargetRadius[2]					= read_spvar(1, 100, 8);
		varIdleTargetSpeed[0]					= read_spvar(1, 100, 8);
		varIdleTargetSpeed[1]					= read_spvar(1, 100, 8);
		varIdleTargetSpeed[2]					= read_spvar(1, 100, 8);
		varAntidrift							= read_spvar(0, 1, 0);
		varAntidriftLeft[antiDriftUp]			= read_spvar(-32768, 32767, 0);
		varAntidriftLeft[antiDriftDown]			= read_spvar(-32768, 32767, 0);
		varAntidriftLeft[antiDriftLeft]			= read_spvar(-32768, 32767, 0);
		varAntidriftLeft[antiDriftRight]		= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftUp]			= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftDown]		= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftLeft]		= read_spvar(-32768, 32767, 0);
		varAntidriftRight[antiDriftRight]		= read_spvar(-32768, 32767, 0);
		varAntiRecoil[0]						= read_spvar(antiRecoilOff, antiRecoilAdvanced, antiRecoilOff);
		varAntiRecoil[1]						= read_spvar(antiRecoilOff, antiRecoilAdvanced, antiRecoilOff);
		varAntiRecoil[2]						= read_spvar(antiRecoilOff, antiRecoilAdvanced, antiRecoilOff);
		varAntiRecoilStrength[0]				= read_spvar(0, 100, 0);
		varAntiRecoilStrength[1]				= read_spvar(0, 100, 0);
		varAntiRecoilStrength[2]				= read_spvar(0, 100, 0);
		varAntiRecoilKickStrength[0]			= read_spvar(0, 100, 0);
		varAntiRecoilKickStrength[1]			= read_spvar(0, 100, 0);
		varAntiRecoilKickStrength[2]			= read_spvar(0, 100, 0);
		varantiRecoilKickCounter[0]				= read_spvar(0, 100, 10);
		varantiRecoilKickCounter[1]				= read_spvar(0, 100, 10);
		varantiRecoilKickCounter[2]				= read_spvar(0, 100, 10);
		varControllerButtonLayout				= read_spvar(cblDefault, cblBumperPingTactical, cblDefault);
		varControllerBumperPing					= read_spvar(cbpDefault, cbpSwapped, cbpDefault);
		varControllerBumperTriggers				= read_spvar(cbtDefault, cbtFlipped, cbtDefault);
		varControllerStickLayout				= read_spvar(slDefault, slLegacySouthpawNoClickSwap, slDefault);
		varControllerAdsStickSwap				= read_spvar(cbpDefault, cbpSwapped, cbpDefault);
		varOptionAutoFocus[0]					= read_spvar(0, 1, 0);
		varOptionAutoFocus[1]					= read_spvar(0, 1, 0);
		varOptionAutoFocus[2]					= read_spvar(0, 1, 0);
		varOptionFastMelee[0]					= read_spvar(0, 1, 0);
		varOptionFastMelee[1]					= read_spvar(0, 1, 0);
		varOptionFastMelee[2]					= read_spvar(0, 1, 0);
		varOptionRapidFire[0]					= read_spvar(0, 1, 0);
		varOptionRapidFire[1]					= read_spvar(0, 1, 0);
		varOptionRapidFire[2]					= read_spvar(0, 1, 0);
		varOptionRapidFireSpeed[0]				= read_spvar(1, 60, 1);
		varOptionRapidFireSpeed[1]				= read_spvar(1, 60, 1);
		varOptionRapidFireSpeed[2]				= read_spvar(1, 60, 1);
		varToggleButton[toggleProfile]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleProfile + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleUniversal]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleUniversal + 1]	= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleAutoFocus]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleAutoFocus + 1]	= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleFastMelee]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleFastMelee + 1]	= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleRapidFire]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varToggleButton[toggleRapidFire + 1]	= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		varProfileColor[0]						= read_spvar(red, pink, blue);
		varProfileColor[1]						= read_spvar(red, pink, purple);
		varProfileColor[2]						= read_spvar(red, pink, gold);
		varBlockRumble							= read_spvar(0, 1, 0);
		varDeadzone[deadzoneLeft]				= read_spvar(0, 30, 0);
		varDeadzone[deadzoneRight]				= read_spvar(0, 30, 0);
		varInverted								= read_spvar(0, 1, 0);
		varScreenSaver							= read_spvar(screenSaverOff, screenSaverVisualizer, screenSaverUptime);
		varVMSpeed								= read_spvar(vmSpeed4, vmSpeed10, vmSpeed10);
	} else {
		// Set default settings
		varAimAssist[0] 						= assistOff;
		varAimAssist[1] 						= assistOff;
		varAimAssist[2] 						= assistOff;
		varAimAssistType[0]						= aimAssistTypeDecreasing;
		varAimAssistType[1]						= aimAssistTypeDecreasing;
		varAimAssistType[2]						= aimAssistTypeDecreasing;
		varAimAssistAdsShape[0] 				= aaShapeCircle;
		varAimAssistAdsShape[1] 				= aaShapeCircle;
		varAimAssistAdsShape[2] 				= aaShapeCircle;
		varAimAssistAdsRadius[0]				= 10;
		varAimAssistAdsRadius[1]				= 10;
		varAimAssistAdsRadius[2]				= 10;
		varAimAssistAdsSpeed[0]					= 15;
		varAimAssistAdsSpeed[1]					= 15;
		varAimAssistAdsSpeed[2]					= 15;
		varAimAssistFireShape[0] 				= aaShapeCircle;
		varAimAssistFireShape[1] 				= aaShapeCircle;
		varAimAssistFireShape[2] 				= aaShapeCircle;
		varAimAssistFireRadius[0]				= 10;
		varAimAssistFireRadius[1]				= 10;
		varAimAssistFireRadius[2]				= 10;
		varAimAssistFireSpeed[0]				= 15;
		varAimAssistFireSpeed[1]				= 15;
		varAimAssistFireSpeed[2]				= 15;
		varRotationAssist[0] 					= assistOff;
		varRotationAssist[1] 					= assistOff;
		varRotationAssist[2] 					= assistOff;
		varRotationAdsRadius[0] 				= 20;
		varRotationAdsRadius[1] 				= 20;
		varRotationAdsRadius[2] 				= 20;
		varRotationAdsSpeed[0]					= 2;
		varRotationAdsSpeed[1]					= 2;
		varRotationAdsSpeed[2]					= 2;
		varRotationFireRadius[0] 				= 30;
		varRotationFireRadius[1] 				= 30;
		varRotationFireRadius[2] 				= 30;
		varRotationFireSpeed[0]					= 3;
		varRotationFireSpeed[1]					= 3;
		varRotationFireSpeed[2]					= 3;
		varIdleTargetAssist[0]					= assistOff;
		varIdleTargetAssist[1]					= assistOff;
		varIdleTargetAssist[2]					= assistOff;
		varIdleTargetTime[0]					= 50;
		varIdleTargetTime[1]					= 50;
		varIdleTargetTime[2]					= 50;
		varIdleTargetShape[0]					= aaShapeCircle;
		varIdleTargetShape[1]					= aaShapeCircle;
		varIdleTargetShape[2]					= aaShapeCircle;
		varIdleTargetRadius[0]					= 8;
		varIdleTargetRadius[1]					= 8;
		varIdleTargetRadius[2]					= 8;
		varIdleTargetSpeed[0]					= 8;
		varIdleTargetSpeed[1]					= 8;
		varIdleTargetSpeed[2]					= 8;
		// Anti-drift
		varAntidrift							= 0;
		varAntidriftLeft[antiDriftUp]			= 0;
		varAntidriftLeft[antiDriftDown]			= 0;
		varAntidriftLeft[antiDriftLeft]			= 0;
		varAntidriftLeft[antiDriftRight]		= 0;
		varAntidriftRight[antiDriftUp]			= 0;
		varAntidriftRight[antiDriftDown]		= 0;
		varAntidriftRight[antiDriftLeft]		= 0;
		varAntidriftRight[antiDriftRight]		= 0;
		// Anti-recoil
		varAntiRecoil[0]						= antiRecoilOff;
		varAntiRecoil[1]						= antiRecoilOff;
		varAntiRecoil[2]						= antiRecoilOff;
		varAntiRecoilStrength[0]				= 0;
		varAntiRecoilStrength[1]				= 0;
		varAntiRecoilStrength[2]				= 0;
		varAntiRecoilKickStrength[0]			= 0;
		varAntiRecoilKickStrength[1]			= 0;
		varAntiRecoilKickStrength[2]			= 0;
		varantiRecoilKickCounter[0]				= 10;
		varantiRecoilKickCounter[1]				= 10;
		varantiRecoilKickCounter[2]				= 10;
		// Controller
		varControllerButtonLayout				= cblDefault;
		varControllerBumperPing					= cbpDefault;
		varControllerBumperTriggers				= cbtDefault;
		varControllerStickLayout				= slDefault;
		varControllerAdsStickSwap				= cbpDefault;
		// Options
		varOptionAutoFocus[0]					= 0;
		varOptionAutoFocus[1]					= 0;
		varOptionAutoFocus[2]					= 0;
		varOptionFastMelee[0]					= 0;
		varOptionFastMelee[1]					= 0;
		varOptionFastMelee[2]					= 0;
		varOptionRapidFire[0]					= 0;
		varOptionRapidFire[1]					= 0;
		varOptionRapidFire[2]					= 0;
		varOptionRapidFireSpeed[0]				= 1;
		varOptionRapidFireSpeed[1]				= 1;
		varOptionRapidFireSpeed[2]				= 1;
		// Toggles
		varToggleButton[toggleProfile]			= 0;
		varToggleButton[toggleProfile + 1]		= 0;
		varToggleButton[toggleUniversal]		= 0;
		varToggleButton[toggleUniversal + 1]	= 0;
		varToggleButton[toggleAutoFocus]		= 0;
		varToggleButton[toggleAutoFocus + 1]	= 0;
		varToggleButton[toggleFastMelee]		= 0;
		varToggleButton[toggleFastMelee + 1]	= 0;
		varToggleButton[toggleRapidFire]		= 0;
		varToggleButton[toggleRapidFire + 1]	= 0;
		// Profiles
		varProfileColor[0]						= blue;
		varProfileColor[1]						= purple;
		varProfileColor[2]						= gold;
		// Settings
		varBlockRumble							= 0;
		varDeadzone[deadzoneLeft] 				= 0;
		varDeadzone[deadzoneRight] 				= 0;
		varInverted								= 0;
		varScreenSaver							= screenSaverBlank;
		varVMSpeed								= vmSpeed10;
	}
	
	setControllerConfig(); // Set controller configuration
}

// Save user-defined configuration settings
function saveSettings() {
	// Always reset the spvar state before saving to ensure that we are saving at the same location as we will later read
	reset_spvar();
	
	// Save a constant 1 to denote previously saved data, this range uses 1 bit
	save_spvar(1, 0, 1);
	save_spvar(varAimAssist[0], assistOff, assistAdsAndFireOrFire);
	save_spvar(varAimAssist[1], assistOff, assistAdsAndFireOrFire);
	save_spvar(varAimAssist[2], assistOff, assistAdsAndFireOrFire);
	save_spvar(varAimAssistType[0], aimAssistTypeDecreasing, aimAssistTypeIncreasing);
	save_spvar(varAimAssistType[1], aimAssistTypeDecreasing, aimAssistTypeIncreasing);
	save_spvar(varAimAssistType[2], aimAssistTypeDecreasing, aimAssistTypeIncreasing);
	save_spvar(varAimAssistAdsShape[0], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varAimAssistAdsShape[1], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varAimAssistAdsShape[2], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varAimAssistAdsRadius[0], 1, 100);
	save_spvar(varAimAssistAdsRadius[1], 1, 100);
	save_spvar(varAimAssistAdsRadius[2], 1, 100);
	save_spvar(varAimAssistAdsSpeed[0], 1, 100);
	save_spvar(varAimAssistAdsSpeed[1], 1, 100);
	save_spvar(varAimAssistAdsSpeed[2], 1, 100);
	save_spvar(varAimAssistFireShape[0], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varAimAssistFireShape[1], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varAimAssistFireShape[2], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varAimAssistFireRadius[0], 1, 100);
	save_spvar(varAimAssistFireRadius[1], 1, 100);
	save_spvar(varAimAssistFireRadius[2], 1, 100);
	save_spvar(varAimAssistFireSpeed[0], 1, 100);
	save_spvar(varAimAssistFireSpeed[1], 1, 100);
	save_spvar(varAimAssistFireSpeed[2], 1, 100);
	save_spvar(varRotationAssist[0], assistOff, assistAdsAndFireOrFire);
	save_spvar(varRotationAssist[1], assistOff, assistAdsAndFireOrFire);
	save_spvar(varRotationAssist[2], assistOff, assistAdsAndFireOrFire);
	save_spvar(varRotationAdsRadius[0], 1, 100);
	save_spvar(varRotationAdsRadius[1], 1, 100);
	save_spvar(varRotationAdsRadius[2], 1, 100);
	save_spvar(varRotationAdsSpeed[0], 1, 100);
	save_spvar(varRotationAdsSpeed[1], 1, 100);
	save_spvar(varRotationAdsSpeed[2], 1, 100);
	save_spvar(varRotationFireRadius[0], 1, 100);
	save_spvar(varRotationFireRadius[1], 1, 100);
	save_spvar(varRotationFireRadius[2], 1, 100);
	save_spvar(varRotationFireSpeed[0], 1, 100);
	save_spvar(varRotationFireSpeed[1], 1, 100);
	save_spvar(varRotationFireSpeed[2], 1, 100);
	save_spvar(varIdleTargetAssist[0], assistOff, assistOn);
	save_spvar(varIdleTargetAssist[1], assistOff, assistOn);
	save_spvar(varIdleTargetAssist[2], assistOff, assistOn);
	save_spvar(varIdleTargetTime[0], 0, 100);
	save_spvar(varIdleTargetTime[1], 0, 100);
	save_spvar(varIdleTargetTime[2], 0, 100);
	save_spvar(varIdleTargetShape[0], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varIdleTargetShape[1], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varIdleTargetShape[2], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(varIdleTargetRadius[0], 1, 100);
	save_spvar(varIdleTargetRadius[1], 1, 100);
	save_spvar(varIdleTargetRadius[2], 1, 100);
	save_spvar(varIdleTargetSpeed[0], 1, 100);
	save_spvar(varIdleTargetSpeed[1], 1, 100);
	save_spvar(varIdleTargetSpeed[2], 1, 100);
	save_spvar(varAntidrift, 0, 1);
	save_spvar(varAntidriftLeft[antiDriftUp], -32768, 32767);
	save_spvar(varAntidriftLeft[antiDriftDown], -32768, 32767);
	save_spvar(varAntidriftLeft[antiDriftLeft], -32768, 32767);
	save_spvar(varAntidriftLeft[antiDriftRight], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftUp], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftDown], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftLeft], -32768, 32767);
	save_spvar(varAntidriftRight[antiDriftRight], -32768, 32767);
	save_spvar(varAntiRecoil[0], antiRecoilOff, antiRecoilAdvanced);
	save_spvar(varAntiRecoil[1], antiRecoilOff, antiRecoilAdvanced);
	save_spvar(varAntiRecoil[2], antiRecoilOff, antiRecoilAdvanced);
	save_spvar(varAntiRecoilStrength[0], 0, 100);
	save_spvar(varAntiRecoilStrength[1], 0, 100);
	save_spvar(varAntiRecoilStrength[2], 0, 100);
	save_spvar(varAntiRecoilKickStrength[0], 0, 100);
	save_spvar(varAntiRecoilKickStrength[1], 0, 100);
	save_spvar(varAntiRecoilKickStrength[2], 0, 100);
	save_spvar(varantiRecoilKickCounter[0], 0, 100);
	save_spvar(varantiRecoilKickCounter[1], 0, 100);
	save_spvar(varantiRecoilKickCounter[2], 0, 100);
	save_spvar(varControllerButtonLayout, cblDefault, cblBumperPingTactical);
	save_spvar(varControllerBumperPing, cbpDefault, cbpSwapped);
	save_spvar(varControllerBumperTriggers, cbtDefault, cbtFlipped);
	save_spvar(varControllerStickLayout, slDefault, slLegacySouthpawNoClickSwap);
	save_spvar(varControllerAdsStickSwap, cbpDefault, cbpSwapped);
	save_spvar(varOptionAutoFocus[0], 0, 1);
	save_spvar(varOptionAutoFocus[1], 0, 1);
	save_spvar(varOptionAutoFocus[2], 0, 1);
	save_spvar(varOptionFastMelee[0], 0, 1);
	save_spvar(varOptionFastMelee[1], 0, 1);
	save_spvar(varOptionFastMelee[2], 0, 1);
	save_spvar(varOptionRapidFire[0], 0, 1);
	save_spvar(varOptionRapidFire[1], 0, 1);
	save_spvar(varOptionRapidFire[2], 0, 1);
	save_spvar(varOptionRapidFireSpeed[0], 1, 60);
	save_spvar(varOptionRapidFireSpeed[1], 1, 60);
	save_spvar(varOptionRapidFireSpeed[2], 1, 60);
	save_spvar(varToggleButton[toggleProfile], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleProfile + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleUniversal], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleUniversal + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleAutoFocus], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleAutoFocus + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleFastMelee], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleFastMelee + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleRapidFire], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varToggleButton[toggleRapidFire + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(varProfileColor[0], red, pink);
	save_spvar(varProfileColor[1], red, pink);
	save_spvar(varProfileColor[2], red, pink);
	save_spvar(varBlockRumble, 0, 1);
	save_spvar(varDeadzone[deadzoneLeft], 0, 30);
	save_spvar(varDeadzone[deadzoneRight], 0, 30);
	save_spvar(varInverted, 0, 1);
	save_spvar(varScreenSaver, screenSaverOff, screenSaverVisualizer);
	save_spvar(varVMSpeed, vmSpeed4, vmSpeed10);
	setControllerConfig();
}

function reset_spvar() {

	 // Change this to say where it's safe to Roset storing data
	spvar_current_slot = SPVAR_1; 
	
	// Should always be 0, unless you're using part of the first SPVAR 
	// in which case you should also change the next line to include the 
	// value you are storing in the bits you are using
	
	spvar_current_bit = 0; 
	spvar_current_value = 0;
}

// Function used to count the number of bits used by the given value
function get_bit_count(val) {
	
	// We need to Roset at 0, we use spvar_tmp here as we need to track
	// the bits during our loop below
	spvar_tmp = 0; 
	
	// Loop while val is anything but 0
	while (val) { 
		// Increment the bit count by 1
		spvar_tmp++; 
		
		// Shift the value down 1 bit, once we have no more bits set this
		// will result in 0, unless the value is negative - in which case
		// this will be endless, we do abs here to make it always
		val = abs(val >> 1);
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(val1, val2) {

	// Get the highest bit count required for either min or max
	spvar_tmp = max(get_bit_count(val1), get_bit_count(val2));
	
	// Check if we need to know if the value is negative or not
	if (is_signed2(val1, val2)) {
		// If we need to track if the saved value is negative, we need 1 bit
		// for that specifically - the others are used to store the actual value
		spvar_tmp++;
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(val1, val2) {
	return (val1 < 0) || (val2 < 0);
}

// Function used to generate a bitmask for the sign bit, this will always be
// the highest bit in the range we're requesting it for, to do that - we need
// to Roset with the lowest bit set and move it up the number of steps there
// is between 1 and the bits we need, this needs to be a maximum of 31 but can
// never be negative
function make_sign(bits) { 
	return 1 << clamp(bits - 1, 0, 31);
}

// Function used to generate a full bitmask (essentially all bits set up to
// and including the number of bits given)
function make_full_mask(bits) {	

	// If we're wanting a bitmask for all bits, we can simply return -1
	// (which is all bits set to 1)
	if (bits == 32) { 
		return -1;
	}
	
	// What we do here is basically take a value with all bits except the highest
	// set and shift them down as many times as we need to get a mask that fits
	// the bit count we're looking for
	return 0x7FFFFFFF >> (31 - bits);
}

// Function used to generate a bitmask for just the bits required for the value
// part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) {
	return make_full_mask(bits - 1);
}

// Function used to pack a value that has potential for being negative in a way
// that we use the least number of bits we really need to represent the value
function pack_i(val, bits) {

	// Check if we have a negative value, if so - handle it accordingly
	if (val < 0) { 
		// Get the positive version of the value and keep the bits that are within
		// range of what we're doing and add the sign bit since we have a negative
		// value and return the result
		return (abs(val) & make_sign_mask(bits)) | make_sign(bits);
	}
	
	// Get the bits that are within our range
	return val & make_sign_mask(bits); 
}

// Function used to unpack (restore) a value that has potential for being negative,
// essentially reversing what pack_i does above
function unpack_i(val, bits) {

	// Check if the stored value is supposed to be negative
	if (val & make_sign(bits)) {
		// Retrieve the stored positive value and subtract it from 0 (resulting in
		// the same value except negative), return the result
		return 0 - (val & make_sign_mask(bits));
	}
	
	// Retrieve the stored positive value and return it
	return val & make_sign_mask(bits);
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) {
	return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0);
}

// Function used to save your value in the SPVARs, this is the function you'll be
// calling when saving a value. You need to provide the value to save aswell as
// the range (minimum and maximum value, this is how we determine how many bits
// to use when saving this value)
function save_spvar(val, min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Make sure the value is within our defined range to begin with
	val = clamp(val, min, max); 
	
	// If either min or max is negative, we need to pack this value as a
	// possibly negative value
	if (is_signed2(min, max)) { 
		// Pack as signed value (possibly negative)
		val = pack_i(val, spvar_bits);
	}
	
	// Pack as unsigned value (always positive), this essentially just makes the
	// resulting value not have any extra bits set - it's safe to use after the
	// signed packing since we're not using any bits outside of the unsigned range anyways
	val = val & make_full_mask(spvar_bits); 
	
	// Check if there is not enough bits remaining to save this value as-is. if
	// there aren't enough bits, we save what we can here and store the remaining
	// bits in the next spvar, if this means we're hitting the end, we can make
	// this smaller by handling the case where we use all bits here aswell
	if (spvar_bits >= 32 - spvar_current_bit) { 
		// Add what we can to the current value where there is bits available to use
		spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
		// Save the current SPVAR before advancing to the next one
		set_pvar(spvar_current_slot, spvar_current_value); 
		// Move to the next slot
		spvar_current_slot++; 
		// Update the required bits according to our needs for the next slot, 
		// if we don't do this here, we'll screw up the saved value by moving
		// it too far out of range
		spvar_bits -= (32 - spvar_current_bit);
		// Move the remaining bits down, discarding the bits we've already saved
		val = val >> (32 - spvar_current_bit); 
		// Reset the current bit counter since we're Roseting with a new SPVAR
		spvar_current_bit = 0; 
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
	// Move up the counter of next available bit to where we are currently saving data at
	spvar_current_bit += spvar_bits; 
	
	if (!spvar_current_bit) {
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Save the SPVAR with the current value, this won't write anything to flash unless
	//the value changed - so we can do this for each variable saved to no risk missing anything
	set_pvar(spvar_current_slot, spvar_current_value); 
}

// Function used to read your value from the SPVARs, this is the function you'll be
// calling when reading a value. You need to provide the range (minimum and maximum
// value, this is how we determine how many bits to use when reading the value) aswell
// as a default value if what we read is out of range
function read_spvar(min, max, def) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Read the current SPVAR value from flash and shift them into position,
	// we'll handle split values next
	spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits);
	
	// Check if we are dealing with a split SPVAR value, essentially if the current
	// position means we're using more than 32 bits in the SPVAR, we need to retrieve
	// the missing bits from the next SPVAR and put them back to our current value,
	// we use the same space saving trick here as in the save function
	if (spvar_bits >= 32 - spvar_current_bit) {
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	
	// Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_bit += spvar_bits;
	// Extract all bits included for this value and discard any other bits
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); 
	
	if (spvar_current_bit >= 32) {
		// Move to the next SPVAR slot
		spvar_current_slot++;
		// Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
		spvar_current_bit -= 32;
	}
	
	// Check if the value can be negative and handle it accordingly
	if (is_signed2(min, max)) { 
		// Restore the signed, possibly negative value
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); 
	}
	
	// Check if the value is below our specified min or above our specified max,
	// if so - return the default value instead
	if (spvar_current_value < min || spvar_current_value > max) { 
		// This can be changed to min instead as a reasonable default with the
		// default parameter being removed if you don't need to have a override
		// value for the default when out of range, that will save a bit of code size
		return def; 
	}
	
	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


/**************************************************************/
// Combos
/**************************************************************/
combo cboActionSuccess {
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 80);
	wait(240);
	reset_rumble();
}

combo cboActionFailed {
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	set_rumble(RUMBLE_A, 80);
	wait(240);
	reset_rumble();
}

combo cboAutoFocus {
	wait(120);
	set_val(button[focus], 100);
	wait(3000);
	set_val(button[focus], 0);
	wait(600);
}

combo cboCalibrationComplete {
	cls_oled(OLED_BLACK);
	set_rumble(RUMBLE_B, 100);
	setLedColor(iif(antiDriftCalibrationCanSet == 2, yellow, iif(antiDriftCalibrationCanSet, green, red)));
	printText(alignCenter, alignCenter, antiDriftCalibrationResult[antiDriftCalibrationCanSet], OLED_FONT_SMALL, OLED_WHITE);
	wait(1440);
	reset_rumble();
	antiDriftCalibrationState = !antiDriftCalibrationState; // Disable calibration
	editMenuUpdate = !editMenuUpdate; // Update edit menu
	// Reset calibration variables
	antiDriftCalibrationCanSet = FALSE;
	antiDriftCalibrationInRange = FALSE;
}

combo cboClearScreen {
	cls_oled(OLED_BLACK);
}

combo cboFastMelee {
	set_val(button[melee], 100);
	wait(120);
	set_val(button[melee], 0);
	wait(120);
}

combo cboscriptPaused {
	set_rgb(255, 30, 0);
	wait(120);
	set_rgb(0, 0, 0);
	wait(120);
}

combo cboRapidFire {
	// Low value (LCM of possible VM speeds) for immediate fire
	wait(120 / varOptionRapidFireSpeed[currentProfile]);
	set_val(button[fire], 0);
	wait(880 / varOptionRapidFireSpeed[currentProfile]);
}

combo cboSaveSettings {
	call(cboClearScreen);
	printText(alignCenter, alignCenter, settingsSaved[0], OLED_FONT_SMALL, OLED_WHITE);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 100);
	wait(480);
	reset_rumble();
	saveSettings();
	homeUpdate = !homeUpdate;
}

combo cboSwitchProfile {
	call(cboClearScreen);
	insertString(profileName[currentProfile]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(1080);
	homeUpdate = !homeUpdate;
}

combo cboToggleAlert {
	setProfileLedColor(currentProfile);
	wait(240);
	set_hsb(0, 0, 0); // Off
	wait(240);
}

combo cboToggleScope {
	set_val(button[focus], 0);
	wait(80);
	set_val(button[focus], 100);
	wait(40);
}

combo cboToggleAutoFocus {
	if(varOptionAutoFocus[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, toggleMessages[varOptionAutoFocus[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleFastMelee {
	if(varOptionFastMelee[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, toggleMessages[2 + varOptionFastMelee[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleRapidFire {
	if(varOptionRapidFire[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, toggleMessages[4 + varOptionRapidFire[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleOff {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleOn {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_B, 75);
	wait(120);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

/**************************************************************/
// Tables
/**************************************************************/
//
// Polar stick values (0 - 100)
const int16 polarValues[] = {
    0,
	328, 655, 983, 1311, 1638, 1966, 2294, 2621, 2949, 3277,
    3604, 3932, 4260, 4587, 4915, 5243, 5570, 5898, 6226, 6553,
    6881, 7209, 7536, 7864, 8192, 8519, 8847, 9175, 9502, 9830,
    10158, 10485, 10813, 11141, 11468, 11796, 12124, 12451, 12779, 13107,
    13434, 13762, 14090, 14417, 14745, 15073, 15400, 15728, 16056, 16384,
    16711, 17039, 17367, 17694, 18022, 18350, 18677, 19005, 19333, 19660,
    19988, 20316, 20643, 20971, 21299, 21626, 21954, 22282, 22609, 22937,
    23265, 23592, 23920, 24248, 24575, 24903, 25231, 25558, 25886, 26214,
    26541, 26869, 27197, 27524, 27852, 28180, 28507, 28835, 29163, 29490,
    29818, 30146, 30473, 30801, 31129, 31456, 31784, 32112, 32439, 32767
}

// sin(x)
const int16 sin[] = { 
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328
}

// cos(x)
const int16 cos[] = { 
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328,
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6
}

const int16 lemniscateX[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -29, -32, -35, -38, -41, -44, -47, -50,
	-53, -56, -60, -63, -66, -69, -73, -76, -79, -83, -86, -90, -94, -97, -101, -105, -109, -112,
	-116, -120, -124, -129, -133, -137, -141, -146, -150, -154, -159, -164, -168, -173, -178, -182, -187, -192,
	-197, -202, -207, -212, -217, -222, -227, -232, -237, -242, -247, -252, -257, -262, -266, -271, -276, -280,
	-284, -289, -293, -297, -300, -304, -307, -310, -313, -316, -318, -320, -322, -324, -325, -326, -327, -328,
	-328, -328, -327, -326, -325, -324, -322, -320, -318, -316, -313, -310, -307, -304, -300, -297, -293, -289,
	-284, -280, -276, -271, -266, -262, -257, -252, -247, -242, -237, -232, -227, -222, -217, -212, -207, -202,
	-197, -192, -187, -182, -178, -173, -168, -164, -159, -154, -150, -146, -141, -137, -133, -129, -124, -120,
	-116, -112, -109, -105, -101, -97, -94, -90, -86, -83, -79, -76, -73, -69, -66, -63, -60, -56,
	-53, -50, -47, -44, -41, -38, -35, -32, -29, -26, -23, -20, -17, -14, -11, -9, -6, -3,
	0, 3, 6, 9, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50,
	53, 56, 60, 63, 66, 69, 73, 76, 79, 83, 86, 90, 94, 97, 101, 105, 109, 112,
	116, 120, 124, 129, 133, 137, 141, 146, 150, 154, 159, 164, 168, 173, 178, 182, 187, 192,
	197, 202, 207, 212, 217, 222, 227, 232, 237, 242, 247, 252, 257, 262, 266, 271, 276, 280,
	284, 289, 293, 297, 300, 304, 307, 310, 313, 316, 318, 320, 322, 324, 325, 326, 327, 328,
	328, 328, 327, 326, 325, 324, 322, 320, 318, 316, 313, 310, 307, 304, 300, 297, 293, 289,
	284, 280, 276, 271, 266, 262, 257, 252, 247, 242, 237, 232, 227, 222, 217, 212, 207, 202,
	197, 192, 187, 182, 178, 173, 168, 164, 159, 154, 150, 146, 141, 137, 133, 129, 124, 120,
	116, 112, 109, 105, 101, 97, 94, 90, 86, 83, 79, 76, 73, 69, 66, 63, 60, 56,
	53, 50, 47, 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int8 lemniscateY[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3,
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int16 roseX[] = {
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29
}

const int16 roseY[] = {
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0,
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0
}

const int16 flowerX[] = {
	-1, -19, -39, -60, -82, -105, -128, -150, -172, -192, -211, -228, -244, -256, -267, -275, -281, -285,
	-287, -287, -286, -284, -281, -278, -275, -272, -269, -268, -268, -268, -271, -274, -279, -284, -291, -298,
	-304, -311, -317, -322, -326, -328, -327, -324, -318, -309, -297, -282, -264, -244, -221, -195, -169, -140,
	-112, -83, -54, -27, -2, 21, 42, 59, 73, 82, 88, 89, 87, 80, 70, 56, 39, 20,
	-2, -25, -49, -74, -98, -122, -145, -166, -185, -202, -217, -228, -237, -244, -247, -249, -248, -245,
	-240, -234, -227, -220, -212, -204, -196, -188, -182, -176, -170, -166, -162, -159, -157, -155, -154, -152,
	-150, -148, -146, -143, -139, -134, -128, -122, -114, -106, -97, -87, -77, -67, -57, -47, -38, -29,
	-21, -15, -9, -4, 0, 2, 4, 4, 4, 3, 2, 0, -2, -3, -4, -4, -4, -2,
	0, 4, 9, 15, 21, 29, 38, 47, 57, 67, 77, 87, 97, 106, 114, 122, 128, 134,
	139, 143, 146, 148, 150, 152, 154, 155, 157, 159, 162, 166, 170, 176, 182, 188, 196, 204,
	212, 220, 227, 234, 240, 245, 248, 249, 247, 244, 237, 228, 217, 202, 185, 166, 145, 122,
	98, 74, 49, 25, 2, -20, -39, -56, -70, -80, -87, -89, -88, -82, -73, -59, -42, -21,
	2, 27, 54, 83, 112, 140, 169, 195, 221, 244, 264, 282, 297, 309, 318, 324, 327, 328,
	326, 322, 317, 311, 304, 298, 291, 284, 279, 274, 271, 268, 268, 268, 269, 272, 275, 278,
	281, 284, 286, 287, 287, 285, 281, 275, 267, 256, 244, 228, 211, 192, 172, 150, 128, 105,
	82, 60, 39, 19, 1, -15, -28, -39, -47, -53, -55, -55, -53, -48, -41, -32, -22, -11,
	1, 13, 25, 37, 48, 57, 66, 73, 79, 83, 86, 87, 87, 85, 82, 79, 74, 68,
	63, 57, 50, 44, 38, 32, 26, 20, 15, 10, 5, 0, -5, -10, -15, -20, -26, -32,
	-38, -44, -50, -57, -63, -68, -74, -79, -82, -85, -87, -87, -86, -83, -79, -73, -66, -57,
	-48, -37, -25, -13, -1, 11, 22, 32, 41, 48, 53, 55, 55, 53, 47, 39, 28, 15
}

const int16 flowerY[] = {
	1, 20, 39, 58, 77, 94, 111, 126, 139, 150, 159, 166, 171, 173, 173, 172, 169, 165,
	159, 153, 146, 139, 131, 124, 117, 110, 103, 98, 92, 87, 83, 79, 75, 71, 67, 63,
	59, 55, 50, 45, 40, 34, 29, 23, 17, 11, 5, 0, -5, -9, -12, -14, -15, -15,
	-14, -12, -9, -5, 0, 5, 10, 15, 19, 24, 27, 29, 30, 29, 27, 23, 17, 9,
	-1, -12, -25, -39, -55, -71, -87, -104, -120, -136, -152, -166, -179, -190, -200, -209, -215, -220,
	-224, -226, -227, -227, -227, -226, -225, -224, -224, -225, -226, -228, -232, -236, -242, -248, -256, -263,
	-271, -279, -286, -293, -298, -301, -302, -301, -297, -291, -281, -268, -253, -235, -213, -190, -165, -138,
	-110, -82, -54, -27, -2, 22, 43, 61, 75, 86, 92, 94, 92, 86, 75, 61, 43, 22,
	-2, -27, -54, -82, -110, -138, -165, -190, -213, -235, -253, -268, -281, -291, -297, -301, -302, -301,
	-298, -293, -286, -279, -271, -263, -256, -248, -242, -236, -232, -228, -226, -225, -224, -224, -225, -226,
	-227, -227, -227, -226, -224, -220, -215, -209, -200, -190, -179, -166, -152, -136, -120, -104, -87, -71,
	-55, -39, -25, -12, -1, 9, 17, 23, 27, 29, 30, 29, 27, 24, 19, 15, 10, 5,
	0, -5, -9, -12, -14, -15, -15, -14, -12, -9, -5, 0, 5, 11, 17, 23, 29, 34,
	40, 45, 50, 55, 59, 63, 67, 71, 75, 79, 83, 87, 92, 98, 103, 110, 117, 124,
	131, 139, 146, 153, 159, 165, 169, 172, 173, 173, 171, 166, 159, 150, 139, 126, 111, 94,
	77, 58, 39, 20, 1, -16, -32, -47, -58, -67, -73, -76, -75, -71, -63, -52, -37, -19,
	2, 24, 49, 75, 102, 129, 156, 182, 206, 229, 250, 268, 284, 297, 308, 315, 320, 322,
	322, 321, 317, 313, 308, 302, 297, 292, 288, 285, 283, 282, 283, 285, 288, 292, 297, 302,
	308, 313, 317, 321, 322, 322, 320, 315, 308, 297, 284, 268, 250, 229, 206, 182, 156, 129,
	102, 75, 49, 24, 2, -19, -37, -52, -63, -71, -75, -76, -73, -67, -58, -47, -32, -16
}

const int16 orbitX[] = {
    0, -17, -34, -51, -68, -85, -101, -117, -133, -149, -164, -178, -193, -206, -219, -232, -244, -255,
    -265, -275, -284, -292, -299, -306, -312, -317, -321, -324, -326, -327, -328, -327, -326, -324, -321, -317,
    -312, -306, -299, -292, -284, -275, -265, -255, -244, -232, -219, -206, -193, -178, -164, -149, -133, -117,
    -101, -85, -68, -51, -34, -17, 0, 17, 34, 51, 68, 85, 101, 117, 133, 149, 164, 178,
    193, 206, 219, 232, 244, 255, 265, 275, 284, 292, 299, 306, 312, 317, 321, 324, 326, 327,
    328, 327, 326, 324, 321, 317, 312, 306, 299, 292, 284, 275, 265, 255, 244, 232, 219, 206,
    193, 178, 164, 149, 133, 117, 101, 85, 68, 51, 34, 17, 0, -17, -34, -51, -68, -85,
    -101, -117, -133, -149, -164, -178, -193, -206, -219, -232, -244, -255, -265, -275, -284, -292, -299, -306,
    -312, -317, -321, -324, -326, -327, -328, -327, -326, -324, -321, -317, -312, -306, -299, -292, -284, -275,
    -265, -255, -244, -232, -219, -206, -193, -178, -164, -149, -133, -117, -101, -85, -68, -51, -34, -17,
    0, 17, 34, 51, 68, 85, 101, 117, 133, 149, 164, 178, 193, 206, 219, 232, 244, 255,
    265, 275, 284, 292, 299, 306, 312, 317, 321, 324, 326, 327, 328, 327, 326, 324, 321, 317,
    312, 306, 299, 292, 284, 275, 265, 255, 244, 232, 219, 206, 193, 178, 164, 149, 133, 117,
    101, 85, 68, 51, 34, 17, 0, -17, -34, -51, -68, -85, -101, -117, -133, -149, -164, -178,
    -193, -206, -219, -232, -244, -255, -265, -275, -284, -292, -299, -306, -312, -317, -321, -324, -326, -327,
    -328, -327, -326, -324, -321, -317, -312, -306, -299, -292, -284, -275, -265, -255, -244, -232, -219, -206,
    -193, -178, -164, -149, -133, -117, -101, -85, -68, -51, -34, -17, 0, 17, 34, 51, 68, 85,
    101, 117, 133, 149, 164, 178, 193, 206, 219, 232, 244, 255, 265, 275, 284, 292, 299, 306,
    312, 317, 321, 324, 326, 327, 328, 327, 326, 324, 321, 317, 312, 306, 299, 292, 284, 275,
    265, 255, 244, 232, 219, 206, 193, 178, 164, 149, 133, 117, 101, 85, 68, 51, 34, 17
}

const int16 orbitY[] = {
    0, -11, -23, -34, -46, -57, -68, -79, -90, -101, -112, -123, -133, -144, -154, -164, -174, -183,
    -193, -202, -211, -219, -228, -236, -244, -251, -258, -265, -272, -278, -284, -289, -295, -299, -304, -308,
    -312, -315, -318, -321, -323, -324, -326, -327, -327, -328, -327, -327, -326, -324, -323, -321, -318, -315,
    -312, -308, -304, -299, -295, -289, -284, -278, -272, -265, -258, -251, -244, -236, -228, -219, -211, -202,
    -193, -183, -174, -164, -154, -144, -133, -123, -112, -101, -90, -79, -68, -57, -46, -34, -23, -11,
    0, 11, 23, 34, 46, 57, 68, 79, 90, 101, 112, 123, 133, 144, 154, 164, 174, 183,
    193, 202, 211, 219, 228, 236, 244, 251, 258, 265, 272, 278, 284, 289, 295, 299, 304, 308,
    312, 315, 318, 321, 323, 324, 326, 327, 327, 328, 327, 327, 326, 324, 323, 321, 318, 315,
    312, 308, 304, 299, 295, 289, 284, 278, 272, 265, 258, 251, 244, 236, 228, 219, 211, 202,
    193, 183, 174, 164, 154, 144, 133, 123, 112, 101, 90, 79, 68, 57, 46, 34, 23, 11,
    0, -11, -23, -34, -46, -57, -68, -79, -90, -101, -112, -123, -133, -144, -154, -164, -174, -183,
    -193, -202, -211, -219, -228, -236, -244, -251, -258, -265, -272, -278, -284, -289, -295, -299, -304, -308,
    -312, -315, -318, -321, -323, -324, -326, -327, -327, -328, -327, -327, -326, -324, -323, -321, -318, -315,
    -312, -308, -304, -299, -295, -289, -284, -278, -272, -265, -258, -251, -244, -236, -228, -219, -211, -202,
    -193, -183, -174, -164, -154, -144, -133, -123, -112, -101, -90, -79, -68, -57, -46, -34, -23, -11,
    0, 11, 23, 34, 46, 57, 68, 79, 90, 101, 112, 123, 133, 144, 154, 164, 174, 183,
    193, 202, 211, 219, 228, 236, 244, 251, 258, 265, 272, 278, 284, 289, 295, 299, 304, 308,
    312, 315, 318, 321, 323, 324, 326, 327, 327, 328, 327, 327, 326, 324, 323, 321, 318, 315,
    312, 308, 304, 299, 295, 289, 284, 278, 272, 265, 258, 251, 244, 236, 228, 219, 211, 202,
    193, 183, 174, 164, 154, 144, 133, 123, 112, 101, 90, 79, 68, 57, 46, 34, 23, 11
} 